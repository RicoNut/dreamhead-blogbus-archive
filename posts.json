[
  {
    "timestamp": "201605232129",
    "date": "2016-05-23",
    "time": "21:29",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.11.0发布",
    "body": "<p>前版信息：<a href=\"http://www.blogbus.com/dreamhead-logs/336859555.html\">Moco 0.10.2发布</a></p>\n<p>我很高兴地宣布，Moco 0.11.0发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p>Moco是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>本次发布主要增加了两个大的特性：REST API 和 JUnit 集成。</p>\n<p>众所周知，REST 服务几乎已经成了现代服务端开发的标配。为了简化 REST API 的模拟，Moco 专门提供了特定的 API，比如，下面这个例子：</p>\n<p>RestServer server = restServer(port, log());<br>ResourceObject resource = new ResourceObject();<br>resource.code = 1;<br>resource.message = \"hello\";</p>\n<p>server.resource(\"targets\",<br>&nbsp; &nbsp; get(\"1\").response(toJson(resource))<br>);</p>\n<p>RestServer 的 resource 方法是为配置资源而设计的，主要配置资源的名字，以及访问的设置。这里的例子里，我们声明了一个名为 targets 的资源，我们还配置了一个 get 方法，当资源 ID 为1时，返回相应的对象。这个配置可以通过 /targets/1 访问得到。</p>\n<p>REST API 同样支持 JSON 配置文件，上面的例子用 JSON 配置文件的形式可以写成如下格式：</p>\n<p>[<br>\"resource\": {<br>&nbsp; \"name\": \"targets\",<br>&nbsp; \"get\": [<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"id\": \"1\",<br>&nbsp; &nbsp; &nbsp; \"response\": {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"json\": {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"code\": 1,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"message\": \"foo\"<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; ]<br>}<br>]</p>\n<p>访问 <a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/rest-apis.md\">REST API 的文档</a>可以了解更多细节。</p>\n<p>Moco 的 JUnit 集成是利用 JUnit 的特性，进一步简化测试代码的编写。</p>\n<p>public class MocoJunitJsonHttpRunnerTest {<br>&nbsp; &nbsp; @Rule<br>&nbsp; &nbsp; public MocoJunitRunner runner = MocoJunitRunner.jsonHttpRunner(12306, \"foo.json\");</p>\n<p>&nbsp; &nbsp; @Test<br>&nbsp; &nbsp; public void should_return_expected_message() throws IOException {<br>&nbsp; &nbsp; &nbsp; &nbsp; Content content = Request.Get(\"http://localhost:12306\").execute().returnContent();<br>&nbsp; &nbsp; &nbsp; &nbsp; assertThat(content.asString(), is(\"foo\"));<br>&nbsp; &nbsp; }<br>}</p>\n<p>这里声明了一个 JUnit 的规则（Rule），它会在测试运行之前启动一个 Moco 服务器，在测试运行完毕之后关闭它。利用 Rule 的特性，就不必在每个测试里去启停 Moco 服务器了。</p>\n<p>更多发布相关信息，请参考 <a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/ReleaseNotes.md\">Release Notes</a>。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201509052152",
    "date": "2015-09-05",
    "time": "21:52",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.10.2发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/272207202.html\">Moco 0.10.1发布</a></p>\n<p>我很高兴地宣布，Moco 0.10.2发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p><a href=\"https://github.com/dreamhead/moco/\">Moco</a>是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>本次发布主要是一些API的增强和内部细节的改进。</p>\n<p>对于json的Java API增加了对于普通Java对象的支持。这样一来，我们就可以通过编写普通的Java对象，让它自动转换成对应的json。比如，下面的代码是对请求的支持：</p>\n<p>&nbsp; server.request(json(pojo)).response(\"foo\");</p>\n<p>应答的支持是这样的：</p>\n<p>&nbsp; server.request(by(uri(\"/json\"))).response(toJson(pojo));</p>\n<p>因为这个普通Java对象到json的自动转换是由<a href=\"https://github.com/FasterXML/jackson-databind\">Jackson</a>实现的，所以，这里的对象类需要按照Jackson的方式进行声明，比如，下面是一个例子：</p>\n<p>&nbsp; public class PlainA {<br>&nbsp; &nbsp; public int code;<br>&nbsp; &nbsp; public String message;<br>&nbsp; }</p>\n<p>更多Jackson的用法，可以参考<a href=\"https://github.com/FasterXML/jackson-databind#use-it\">Jackson的文档</a>。</p>\n<p>另外，本次的API增强还包括了对于redirect的模板支持，这样，redirect的API就可以实现更强大的跳转效果：</p>\n<p>&nbsp; server.redirectTo(template(\"${var}\", \"var\", \"http://github.com\"));</p>\n<p>更多发布相关信息，请参考<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/ReleaseNotes.md#release-0102-1-sep-2015\">Release Notes</a>。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201508080836",
    "date": "2015-08-08",
    "time": "08:36",
    "tags": [
      "脚下的路",
      "程序员"
    ],
    "title": "大龄程序员",
    "body": "<p><span style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;\">这是我在知乎上的一篇回帖：</span></p>\n<p><a href=\"http://www.zhihu.com/question/34075798/answer/58207723\">要是写代码 写到三十岁没升到管理怎么办啊？</a></p>\n<p><span style=\"line-height: 22.3999996185303px;\">我每天还在写代码，与人讨论技术实现细节，35岁那年，我写的<a href=\"https://github.com/dreamhead/moco\">Moco</a></span><span style=\"line-height: 22.3999996185303px;\">拿了Oracle的Duke选择奖。</span></p>\n<p><strong style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">思维误区</strong><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">我还没开始工作的时候，有人就在说：程序员能做到30岁吗？<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">我快到30岁时，有人在问：35岁还能做程序员吗？<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">过了35之后，我已经看到了新的讨论：40岁程序员怎么办？<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">估计10年之后，新的讨论会是：程序员50岁以后的职业发展是什么样子的。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">这反映了一个重要的事实，程序员是中国的一个新兴职业，发展时间还不够长。当时间逐渐拉长，越来越多大龄程序员就会出现。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><strong style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">写代码和做管理</strong><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">如果你热爱写代码，那就去写。但是，这里必须知道一个前提，写代码和写代码是不一样的。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">以现在的普遍情况看，20多岁的程序员大多属于初出茅庐，写代码大多是以完成功能为主，而到了30多岁，写程序大约十年左右，需要考虑的方方面面必然要更多，比如，这个需求是否合理，从架构层面会造成什么样的影响，是否能找到更简洁的解决方案，这个代码写出来别人是否容易理解等等。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">30岁之后，精力会下降，这是生理决定的，如果这时候还和年轻人比拼堆代码的速度，靠加班熬夜，那必然是输了。而且，这种做法始终在低水平徘徊，自己做时间长了也会心生厌倦，所以，这不是一个可持续的模式。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">很多人想30岁就做管理，可是，哪有那么多人让你管理啊！为什么之前有那么多少年得志的故事？还是前面的那个逻辑，之前做的人少，所以，机会多。现在IT行业的人才积累已经达到了相当的规模，机会就会减少。当然，投身创业公司是另外一个选择，但前提是这个创业公司能做起来。不过，即便是有机会，为什么是你？<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">不管做什么，自己有本事才是前提。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><strong style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">成长之路</strong><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">以我个人的成长经验来看，不断地和更高水平的人过招，是保证成长的前提。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">初入职场，我也以为自己的成长路径会是写几年程序，然后，做管理。很幸运的是，在职业生涯之初，我遇到一个水平很高的人，他让我看到了一种心生向往的状态，于是，我就下定决心，成为一个优秀的程序员。更为幸运的是，我们俩成了很好的朋友，十几年下来，每当我进步了一些，他却又在我前面更远的地方。虽然我们做的领域截然不同，但从他身上得到的启发却一直激励我前进，比如，看到了他做的一个东西，我便下定决心有一个自己的代表作，这就是后来的Moco。如今，他年近40，依然是各大公司争相高薪邀请的人，而我知道，有他在前面奔跑，我就不能停下来。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">加入ThoughtWorks的选择，也是为了与高手过招。2007年加入时，那里汇聚了当时我听说过的许多牛人，后来，还有机会和Martin Fowler这样的大师请教问题。在ThoughtWorks工作的八年，让我打开了自己的眼界，能够更加虚心地向更多高手学习，得到了个人全方位的综合提高。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">就发展而言，如果身边没有高手怎么办？那就去找一个能和高手近距离过招的地方。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">不过，这里说的并不等价于大公司。大公司里固然有很多高手，但问题是你有多少机会和这些人一起工作。比如，我们知道Jeff Dean很厉害，但加入Google就能和他一起工作吗？所以，比起在哪里工作，和什么样的人在一起工作会更重要。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">从正常选择公司的方式来说，面试是一个了解公司、了解团队的机会。如果负责招聘的人会和你一起工作，那就可以好好考察一番。如果不是，那一定要尝试见见团队，最重要的是，见见团队里的高手。如果这个高手的状态不能让你羡慕，那他就不是你的目标。<br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\"><br style=\"color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; line-height: 20.0909080505371px;\">当然，有了高手，如何成长，那就是每个人自己的事情了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201505122043",
    "date": "2015-05-12",
    "time": "20:43",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.10.1发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/272040531.html\">Moco 0.10.0发布</a></p>\n<p>我很高兴地宣布，Moco 0.10.1发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p>Moco是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>本次发布对使用Java API的用户最大影响在于，原来的httpserver已经废弃了，推荐使用httpServer。</p>\n<p>&nbsp; &nbsp; HttpServer server = httpServer(12306);</p>\n<p>另外一个废弃掉的API是没有TimeUnit的latency，推荐使用有时间单位的latency接口。</p>\n<p>&nbsp; &nbsp; server.response(latency(1, TimeUnit.SECONDS));</p>\n<p>以上废弃的API将会在下一次发布中移除，请尽早更新。</p>\n<p>接下来，比较大的变动是增加了字符集，file和pathResource都可以进行字符集的处理。</p>\n<p>&nbsp; &nbsp; server.response(file(\"gbk.response\", Charset.forName(\"GBK\")));</p>\n<p>甚至，日志也指定对应的字符集：</p>\n<p>&nbsp; &nbsp; HttpServer server = httpServer(port(), log(\"path.log\", Charset.forName(\"UTF-8\")));</p>\n<p>模板在原来对内容处理的基础上，增加了对文件名的处理：</p>\n<p>&nbsp; &nbsp; server.response(file(template(\"${var}.response\", \"var\", \"foo\")));</p>\n<p>这样一来，你可以把更多模板的特性用在文件名上，比如jsonPath、xpath等，也就是说，可以把不同请求应答的结果，放到不同的文件里。当然，你可以把它用在JSON配置文件里：</p>\n<p>[<br>&nbsp; {<br>&nbsp; &nbsp; \"response\":<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"file\":<br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"name\": {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"template\": {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"with\" : \"${var}.response\",<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"vars\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"var\" : \"foo\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; }<br>]</p>\n<p>这次发布还有一个针对于JSON API的调整，就是现在可以mount的时候，额外增加应答配置，比如像下面这样：</p>\n<p>[<br>&nbsp; {<br>&nbsp; &nbsp; \"mount\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"dir\" : \"src/test/resources/mount\",<br>&nbsp; &nbsp; &nbsp; \"uri\" : \"/mount-response\",<br>&nbsp; &nbsp; &nbsp; \"headers\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"Content-Type\" : \"text/plain\"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; }<br>]</p>\n<p>还有一个针对全局配置的特性，就是配置全局Request，如果你想实现一个全局token，保证每次请求都带过来，现在，就不必在每个请求上编写，只要配置一个全局的就好了：</p>\n<p>[<br>&nbsp; {<br>&nbsp; &nbsp; \"request\" : {<br>&nbsp; &nbsp; &nbsp; \"headers\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"foo\" : \"bar\"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; },<br>&nbsp; &nbsp; \"include\": \"blah.json\"<br>&nbsp; }<br>]</p>\n<p>还有一个实现细节方面的调整，如果在模板里采用了xpath或jsonpath，可能会返回多个值，可以参考<a href=\"http://freemarker.org/\">freemarker</a>的文档编写对多值对象的处理。</p>\n<p>更多发布相关信息，请参考<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/ReleaseNotes.md#release-0101-1-may-2015\">Release Notes</a>。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201503291641",
    "date": "2015-03-29",
    "time": "16:41",
    "tags": [
      "脚下的路"
    ],
    "title": "开始新旅程",
    "body": "<p>离开ThoughtWorks，已经有一个星期了。</p>\n<p>我在ThoughtWorks待了八年，ThoughtWorks中国区从三十多人成长到五百多人，办公室由一个变成了五个，第六个也很快就要开了。八年里，我做了许多项目，面对过形形色色的人：交付或是咨询，国内或是海外。我也随着这个公司逐渐成长，曾经的我只是一个窝在角落里只知道写代码的程序员，到如今，有了更强大的内心，有了属于自己的独立思考，有了更宽的视野：</p>\n<ul>\n<li>我做出了郑大晔校，给毕业生提供一些入门培训，“帮助他人成长”成了我在ThoughtWorks技术之外的最重要个人标签；</li>\n<li>开启了常规性校园活动的先河，给新的ThoughtWorker一个展示自己的舞台，也搭起公司与学校之间的桥梁，间接造成了校园招聘简历数量不断增长；</li>\n<li>推动起技术大会，给了那些只知道坐在自己办公室里ThoughtWorker们有了一个跨越办公室思考的机会；</li>\n<li>参与了西安和成都两个办公室的建立，成为了一个拓荒者，也为两个办公室培养了一些中坚力量；</li>\n<li>当然，还有我的Moco，一些不期而至的鼓励给了我些虚名，也让我越发相信坚持的力量。</li>\n</ul>\n<p>八年里，我经历了自己许多的人生阶段，结婚生子，从一个傻小子变成了需要关心另一个傻小子成长的人父。</p>\n<p>八年的时间，我的身上已经留下深深的ThoughtWorks烙印，我已经习惯了称自己为一个“ThoughtWorker”。对我来说，ThoughtWorks几乎就是我的另一个家，那个家里有的是不只是同事，也许，还是亲人。</p>\n<p>但是，我还是选择了离开。</p>\n<p>ThoughtWorks是鼓励一个人不断成长的，不断跳出自己的舒适区。随着在一个地方待的时间越来越长，那些曾经的挑战就变得没那么复杂，我越来越舒服。即便是在其他人看来压力颇大的一些项目，我都可以和客户谈笑风生，让客户包容我们团队做得欠佳的地方。但这种舒服让我的内心越来越不安，因为那几乎意味着我没有任何成长，我担心的不是自己的今天，而是未来。</p>\n<p>创新，是在ThoughtWorks这几年里不断在提的另一个话题。我也刚好有了一个创新的机会：Moco，它在最近两年多的时间里，由我的一个小玩具变成给许多人提供帮助的开源项目。Moco让我看到了创新的价值，给其他人带来的一些改变。我希望自己能够再有机会做一些别人没做，或是别人没做好的事情。在我看来，这是做开发里最有趣的部分，也是我当年投身软件开发行业的初衷所在。</p>\n<p>如今创业成了主旋律，大环境向好，我的一些朋友纷纷离开自己的熟悉领域，投身到创业大潮中。一些朋友与我交流了他们要做或是在做的事情，ThoughtWorks教会了我如何把事情做好，所以，我也难免好为人师地多嘴两句，给出一些自己的看法，一来二去，越聊越深，朋友们给出了邀约，而我也动了心思。</p>\n<p>最终，我决定离开ThoughtWorks，成为创业大军的一员，去做一些我认为与众不同的事情。这会是一段不同于以往的经历，我选择了一个自己完全不熟悉的领域，在未来一段时间内，我唯有不断学习，才能让自己适应新的环境。</p>\n<p>生命不息，折腾不止，加油！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201503041122",
    "date": "2015-03-04",
    "time": "11:22",
    "tags": [
      "脚下的路"
    ],
    "title": "记一个值得记录的项目",
    "body": "<p>刚刚结束了一个项目，个人觉得颇有意思的一个项目，记录一些发生过的事情，算作备忘。</p>\n<p>这是一个互联网金融的项目，P2P借贷相关，也许有人知道，就是搭建一个借贷平台，个人对个人借款。这个项目大幅度刷新了我对投资理财的一些观念，让我个人受益匪浅。但是，投资这种事，肯定是有风险的，自己想好，所以，我不会特别鼓励别人投资，只会和一些周边的人私下交流。只有几点特别提示，做这种P2P投资，要看背后的平台，发展历史，利率越高，风险越大。</p>\n<p>说一些与做软件相关的吧。</p>\n<p>这是一个金融项目，金融项目时间相关性非常强，这个特性刚好与做敏捷不谋而合。举个例子，我们这个项目第一阶段，做了借款相关的业务流程，而还款部分，我们一开始只处理了提前全额还款这一种情况。为什么？因为这个系统上线后，最早的正常还款、逾期还款等情况，最早要在一个月以后出现，只有提前全额还款可能在第一个月内发生，所以，在第一期上线之后，我们还有一个月时间去处理正常还款等情况。</p>\n<p>只做当前优先级最高的，这就是敏捷软件开发的思路。我们还开发了一个理财计划的方案，采用了同样的思路，上线之初，我们只做用户购买理财计划，至于到期赎回，一开始根本没有做，因为根据产品的特点，最早的赎回会发生在6个月后，只要能在6个月内把赎回开发出来就够了。</p>\n<p>根据客户的反馈，这次合作开发给他们留下印象最深的并不是代码或是技术能力，而是我们帮他们打造出了一个有特点的团队。合作之初，客户的开发团队还没有组建起来，只有一两个人，在双方合作的过程中，他们的新团队成员才逐渐加入进来。我们的合作模式也在这个过程中不断调整，第一期，我们的开发团队负责了所有的开发，第二期，客户的团队开始介入开发，负责一些边缘业务的开发，我们依然是开发主体，第三期，双方当做一个团队，平分主要业务的开发，第四期，他们成了主力，我们则只负责一些边缘业务的开发，至此，客户完全把项目接了过去。</p>\n<p>相比于单纯的业务开发，客户开发团队的开发方式完全遵从了我们的方式。通过每天的代码评审，我们共同分享着对整洁的理解。因为工作时间比大多数人长，我一直在这个过程中扮演着恶人，很多人辛辛苦苦写了一天的代码，到最后都批得一无是处，不得不拿回去重写。犹记得当时，许多人都很不理解我为什么要求这么严格，但几个月下来，大家都认同了好代码，最初的不理解只是因为从来没有人这么要求过。在合作过程中，他们见识了怎么去做自动化，怎么用git管理源码和发布，认识到了测试的重要性。有了这些基础，发布不再是战战兢兢如履薄冰。</p>\n<p>这些习惯闷着头干活的人，经过几个月的合作，已经变得开朗了许多，彼此肆无忌惮地开着玩笑，欢声笑语多了起来。每天下午4点，准时有人号召大家做平板支撑，最厉害的家伙甚至可以一次性撑个五六分钟。桌子上的技术书多了起来，这是他们的技术经理给大家买的。有不少人购买了Kindle，把它用在了上下班的路上。我们还给他们定期做了一些分享，各个方面，从前端到后端，从安全到构建。</p>\n<p>相比于从前几个月的出差，这次的时间过得飞快，我打心眼里喜欢这个项目，它让我有所学，更重要的是，有一群有趣的人，这样的合作是值得记录的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201412310758",
    "date": "2014-12-31",
    "time": "07:58",
    "tags": [
      "年终终结"
    ],
    "title": "站在2014的尾巴上",
    "body": "<p>有一种说法，人对时间的感觉取决于时间相对于整个生命的比例，所以，小时候，我们会觉得一天很长，而年纪越大，觉得时间越快。生命长了，比例降低了。超过30岁以后，一年的光阴也开始转瞬即逝了。</p>\n<p>2014年已经到了最后一天，于我而言，这是相对平淡，却也奔波的一年。</p>\n<p>很多事情都是之前的继续，比如Moco，我还在继续写，为一个开源项目坚持超过两年，我越发佩服自己的耐性了。只不过，发布周期由原来的三个月变成了五个月。每天在github上提交至少一次代码已经成了我日常生活的一部分。看着越来越多的项目因为我的这份坚持而受益，心里还是很高兴的。</p>\n<p>在外演讲也是去年的继续，4月份北京的QCon是2013年就答应了的，7月份WOT是Moco给我的机会。倒是10月份上海的QCon，专题出品人对我而言，是一个新鲜的角色，这个角色算不上很成功，因为我的坚持，在这个主题里引入了很多全新的内容，对听众的吸引力要差一些，但我依然坚信，应该让更多的人了解这些“新”东西，让开发世界进化得再快一点。</p>\n<p>2013年，我制定了读30本书的计划，结果读了52本书。2014年，我的目标是52本，也就是一个星期一本，结果读到82本，这完全出乎了我的意料。一些朋友问我，读这么多书，能记住吗？实际上，我压根也没打算记住所有的内容。读书的目的是为了思考，在阅读的过程中，让文字和自己的思维碰撞。最终留下的才是收获。尝试过每年读几十本书，我才知道，其实，我也不是每天抱着书本不放，如果每天早晚各坚持读半个小时书，一年下来就可以读很多书，大多数抱怨没时间读书的人，真的是没花时间读书。</p>\n<p>2014年读书多，另外一个很重要的原因是拜奔波所赐。这一年，我坐飞机超过30次，每个月都会出现在机场里，路上的时间很大一部分都献给书了。作为一个ThoughtWorker，这几乎就是正常工作的一部分，我的同事里有很多人比我坐飞机的次数还多，我是按月计算，有的人是按周计算。当然，常在岸边走的结果就是，2014年，我住了两回机场提供的宾馆，这也是之前没有经历过的。</p>\n<p>如果说2014年做了一件之前没做过的事情，应该算是组织了ThoughtWorks中国区内部的技术大会。准确地说，这也是2013年想法的一个延续。2013年，我就和现在ThoughtWorks的CEO郭晓谈到过这个想法，直到2014年，各方面因素都成熟了，才把这个活动做了起来。第一次是7月份在西安，第二次是11月份在成都。我个人是亲手策划组织了第一次的技术大会。整体来说，得到的评价还不错，大家也都希望这样的活动继续做下去。2015年已经为此申请了专门的预算，这也是我在ThoughtWorks内部第一次组织有预算的活动。</p>\n<p>2014年，在我的强烈要求下，我一直工作在国内项目，因为我实在想做一些自己能用得上的东西了，而海外交付的东西离我们的生活太远了，当然，这也在客观上决定了我的奔波。年初为一个大的快递公司做了一次网站改版，时至今日，每每我去查快递的时候，心里还有一种极大的成就感。下半年，我又参与到一个P2P网站的建设中，就是现在比较火爆的互联网金融项目。这个项目让我有机会深入理解了一下这个领域。当然，为了实践，我在其它几个网站上做了一些投资的。随着这个网站更加完善，我预期，我还是会多多尝试自己的项目。</p>\n<p>读书与行路，与更多的人交流，我的视野也在不断开阔，我已经开始尝试思考自己的未来几年，2015年，我希望有一些大的变化，让自己的人生有一些全新的体验。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201412032150",
    "date": "2014-12-03",
    "time": "21:50",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.10.0发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/271736741.html\">Moco 0.9.2发布</a></p>\n<p>我很高兴地宣布，Moco 0.10.0发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p><a href=\"https://github.com/dreamhead/moco\">Moco</a>是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>本次发布最大的变更是加入了Socket的支持。</p>\n<p>除了HTTP，Socket是另一种常见的集成方式，对Socket的支持让Moco能够更为全面地对集成进行支持。创建一个Socket的服务器，可以采用socketServer：</p>\n<p>&nbsp; final SocketServer server = socketServer(12306);</p>\n<p>与HTTP支持类似，Socket服务器也是需要设定请求以及对应的应答：</p>\n<p>&nbsp; server.request(by(\"foo\")).response(\"bar\");</p>\n<p>与HTTP本身支持很多参数不同，Socket只支持与内容相关的部分，比如，text、file、xml、json、match、exist、latency、template等等。更多细节，请参见<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/socket-apis.md\">Socket API的文档</a>。</p>\n<p>因为增加了不同的服务器类型，Moco独立服务器的启动参数也有所调整，原来的一个start已经不足以满足需要了。在最新的版本中，你可以根据服务类型记性启动，比如，启动一个Socket服务器的方式如下：</p>\n<p>&nbsp; java -jar moco-runner--standalone.jar socket -p 12306 -c foo.json&nbsp;</p>\n<p>HTTP和HTTPS服务器的启动参数分别对应着http和https，为了兼容原有版本，start依然得到保留，但不确定未来是否会长期存在下去。</p>\n<p>这个版本增加了一个许多人要求的新特性，在Java代码中可以使用JSON配置文件。这种用法与Moco设计JSON API的初衷有很大差别，但在实际的使用中，确实有很多人这么用，所以，在这个版本里提供了一个更简洁的API，不过，这个API存在于Moco Runner包中：</p>\n<p>&nbsp; jsonHttpServer(12306, file(\"foo.json\"));</p>\n<p>在API方面，</p>\n<ul>\n<li>增加attachment API，直接对下载附件提供支持。</li>\n<li>增加了template提取器的支持，比如，如下代码就会从请求中提取内容作为应答返回值。<br>&nbsp; server.response(template(\"${foo}\", \"foo\", jsonPath(\"$.book.price\")));</li>\n</ul>\n<p>在Moco独立服务器和shell版本，增加了版本查询功能，以便对一些外部工具进行支持。</p>\n<p>另外，由于JSON Path底层实现的升级，可能会引入一些破坏性的变化，如果你用到JSON Path API，请注意。</p>\n<p>更多发布相关信息，请参考<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/ReleaseNotes.md\">Release Notes</a>。</p>\n<p><strong>感谢</strong></p>\n<p>感谢Alex Soto，提供Moco服务关闭的解决方案，增强了Moco服务器的稳定性。<br>感谢方志刚，提供Moco的Shell版本在Cygwin下运行的支持。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201411301759",
    "date": "2014-11-30",
    "time": "17:59",
    "tags": [
      "书评"
    ],
    "title": "读《不敢止步》",
    "body": "<p>十几年前，我刚开始工作那会儿，我如饥似渴地找各种的与软件开发相关的材料来读，包括《程序员》杂志。于是，我注意了一个叫“透明”的家伙，写东西文笔很好。后来，因为讨论一些技术问题，我们俩就联系上了，然后，就把“熊节”，“透明”，“gigix”划上了等号。再后来，我加入了ThoughtWorks，第一次见到了活的熊节。</p>\n<p>我依然记得那天，我在新笔记本上装了Ubuntu，我问他怎么联网，他说，你上网，我传个驱动给你。汗……</p>\n<p>从那天开始，我们俩已经同事了七年半的时间，在很多项目上合作过，以ThoughtWorks如今的标准看，我们俩的合作次数和时间也算是很多了。我早就知道他在写一本书，关于他自己这十几年的故事，作为一个和他认识了十几年，共事了七年半的人，我也很好奇他会怎么写我。如今书出版了，我当然会读一下。</p>\n<p>于我而言，这是一本岁月随想，把我带回了那些过去的日子。我很自然地将书分成了两个部分，以他加入ThoughtWorks为界。</p>\n<p>即便是今天，我偶尔也会调侃熊节是搞媒体的。他做媒体人那段日子，恰逢软件开发世界风云突变，有很多大家不断争论的东西。是.NET还是Java，是EJB还是Without EJB，是瀑布还是敏捷。那些年，各路大神你来我往，各种观点风起云涌，争论很大，每个人都有自己的思考，不断地拓展着理解，即便是作为看客，也很过瘾。时至今日，虽然新技术依然层出不穷，但大方向已定，那种思维之争已一去不复返了。抑或是今天的人都忙着各自创新去了，没有闲做思维之辩了。对于错过那段历史的年轻程序员，这本书可以带着回到那个唇枪舌剑的年代。</p>\n<p>他加入ThoughtWorks之后的事情，我都知道。即便是在我加入之前的故事，这么多年吃饭聊天下来，也都听了几遍了。但是，跟着他一起回顾ThoughtWorks这么多年走下来的历程，也颇为感慨。其实，许多人不知道，ThoughtWorks中国区在最初的几年里，有几次已经危在旦夕了。直白地说，不赚钱。在那些不怎么赚钱的日子里，其实作为基层员工，大家活得还是很开心的，拼了命地研究各种各样的技术，经常会有神秘兮兮地跑过来，展示他刚刚做好的东西，那时候，招聘的标准也很高，几乎个个身怀绝技。后来，这些家伙几乎个顶个是现在公司的顶梁柱。</p>\n<p>为了生存，公司调整了方向，随之而来的就是规模的扩张，这也不断地挑战着这些“老员工”的思考方式。从只写代码到带人，甚至做管理，ThoughtWorks中国区的思路不断地调整着，这些老家伙们也不断改变着自己的角色。如今，最初的程序员，留在公司的，似乎只有我还在一线每天写代码了。其他更多人已经各方面的管理者了。即便是我，也干了很多跟程序不搭边的事，比如，郑大晔校。</p>\n<p>熊节在2012年去了成都，开辟新办公室。作为老战友，我也在下半年跑到成都支持他，一干就是一年半。以战绩论，成都的结果真是惊人，第一年就超过了西安办公室两年的发展速度，而且这样的高速一点都没有停下来的迹象。由程序员转成管理者，熊节做得还真不赖。这些年是ThoughtWorks不断发展变化的一段时间，所以，我们这些土鳖程序员为了支撑公司发展，不断地拓展着自己的视野和思路。随着一个公司长大，这样的机会不常有，现在更多的人加入多半是在享受发展的结果。当然，机会永远是有的，只要有心。</p>\n<p>我还是很贪心的，2013年并没有出现在这本书里，否则，我的<a href=\"https://github.com/dreamhead/moco\">Moco</a>一定会位列其中，因为2013年，我们玩出了创新的新花样。后来，熊节去了非洲，支援其他办公室建设去了。</p>\n<p>抛开我和熊节熟人的关系不论，我个人还是很喜欢看这种个人发展的真实故事。尤其是像熊节这样的文笔写出来，一定是比较好看的。多谢熊节用这本书带我回忆那过去的事情。勘个误吧，至少关于我，也算是补充一下那段历史：</p>\n<ul>\n<li>2007年，敏捷中国大会，原本是我和Ola Bini一起讲东西，结果，他没来，我只好一个人上了。</li>\n<li>2008年，Starwood项目，关于IE上出Bug的故事，其实我用的是Dell笔记本，但是，装的是Ubuntu，所以，没发现IE的问题。</li>\n<li>2011年，熊节说他叫我去西安，可是，我2010年就已经转到了西安。</li>\n<li>2011年，索勤的故事，当时，我其实在墨尔本，那个时候的熊节不太相信人是可以培养的，而我则刚好相反。现在索勤已经是公司里面独挡一面的高手了。</li>\n</ul>\n<p>这其实算不上一篇书评，只是借着这本书，回想一下过去的日子罢了。我个人还有个期待，再过十年或是十二年，我希望看到这个故事的新篇章。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201409121742",
    "date": "2014-09-12",
    "time": "17:42",
    "tags": [
      "java8",
      "default_method",
      "面向组合编程"
    ],
    "title": "default method，开启Java面向组合编程的大门",
    "body": "<p>“default method”是Java 8引入的一个特性，其初衷是为了解决既有程序库扩展的问题。在之前的Java版本中，如果要给一个已有接口添加新方法，这会带来一些问题，因为新方法没有对应的实现，所以，实现这个接口的类就会编译不通过。而“default method”的引入给了方法一个实现，编译就可以通过了，从而我们可以在不改变已有代码的前提下，为程序库增加新的方法。</p>\n<p>但是，既然接口方法可以有实现，那它也给了我们另一种思路。</p>\n<p>在Java开发中，我们可能会经常面临一种情况。以Web开发为例，假设我们有一个领域对象Foo。</p>\n<p>class Foo {<br>&nbsp; ...<br>}</p>\n<p>我们有个需求，根据其某些属性决定是否在页面上隐藏它。你当然用一个类实现它，但在页面上是否隐藏它，显然不应该属于领域对象的一部分。所以，我们通常会用另外一个类封装它，比如HiddenableFoo。</p>\n<p>class HiddenableFoo extends Foo {<br>&nbsp; boolean isHidden() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n<p>好，新需求来了，我们要在页面上决定是否要给它的名字加粗，于是，这个类就成了HiddenableBoldableFoo。</p>\n<p>class HiddenableBoldableFoo extends HiddenableFoo {<br>&nbsp; boolean isBold() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n<p>这里其实有个问题，为什么不是先由BoldableFoo，然后，从它继承呢？我们暂且不关心这个细节。</p>\n<p>又有一个需求来了，在另一个页面，我们需要确定这个对象是否需要隐藏以及是否需要斜体：</p>\n<p>class HiddenableItalicableFoo extends HiddenableFoo {<br>&nbsp; boolean isItablic() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n<p>又有一个页面，需要的判断一下某些地方是否要加粗，某些地方判断要斜体，那这个类要怎么做呢？</p>\n<p>class BoldableItalicableFoo {<br>&nbsp; boolean isBold() {<br>&nbsp; &nbsp; ...<br>&nbsp; }</p>\n<p>&nbsp; boolean isItablic() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n<p>如果这里的isBold和isItablic与前面的实现是一样的，是不是重复代码就此出现了呢？这就是在Java 8之前，我们面对的问题，我们可以继承接口，但实现不成。</p>\n<p>Java 8来了，“default method”就给了我们一个机会，让我们可以继承实现。下面是一种实现：</p>\n<p>interface Fooable {<br>&nbsp; ...<br>}</p>\n<p>class Foo implments Fooable {<br>&nbsp; ...<br>}</p>\n<p>interface Hiddenable extends Fooable {<br>&nbsp; default boolean isHidden() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n<p>interface Boldable extends Fooable {<br>&nbsp; default boolean isBold() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n<p>interface Italicable extends Fooable {<br>&nbsp; default boolean isItablic() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n<p>这里之所以引入一个Fooable接口，因为接口只能继承接口。有了这样的基础，我们就可以自由组合了，比如：</p>\n<p>class HiddenableBoldableItalicableFoo extends Foo implements Hiddenable, Boldable, Italicable {<br>}</p>\n<p>如果你熟悉Ruby，这俨然就是Mixin，对于Scala粉丝来说，Trait已然呼之欲出，C++人则会看到多重继承的影子。是的，所有这些语言特性背后都有一个共同的理念：面向组合的编程。</p>\n<p>Trygve Reenskaug和James Coplien在2009年提出的DCI架构，它是一种很好的面向对象编程的视角，其基础就是这种面向组合编程的理念。DCI架构在Java社区里面一直没有很好的讨论，也是因为Java语言没有给力的支持。</p>\n<p>诚如前面所说，Java语言之前是不支持面向组合编程的，但是，在Java社区里，有人不断地做着这方面的探索，Rickard Oberg，这个前JBoss架构师，实现了一个<a href=\"http://www.infoq.com/cn/articles/Composite-Programming-Qi4j\">Qi4J</a>的框架。不过，现在Java语言本身也可以这么做了。</p>\n<p>当然，相比于其它的语言，Java在这方面的表现力是有限的，因为它的基础是接口，所以：</p>\n<ul>\n<li>它不能有字段</li>\n<li>所有方法只能是public的</li>\n</ul>\n<p>另外，组合只能是基于类来做，就像HiddenableBoldableItalicableFoo，虽然这个类除了声明什么都没有。相比于Ruby的Mixin这种可以在运行时扩展的特性，更是表现力要弱了许多。</p>\n<p>但与之前的版本相比，Java算是在这个方面迈了一步，至少我们可以不用再为同一份代码多处出现而纠结了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201408102122",
    "date": "2014-08-10",
    "time": "21:22",
    "tags": [
      "ThoughtWorks",
      "我眼看世界"
    ],
    "title": "当我加入项目时，我要了解什么（二）",
    "body": "<p>2012年时，我写过一篇blog，谈到了加入项目时，如何了解一个项目。</p>\n<p><a href=\"http://dreamhead.blogbus.com/logs/224229646.html\">当我加入项目时，我要了解什么</a></p>\n<p>最近在客户现场做咨询，有人跑过来，问了我同样的话题。经过简单沟通，我发现他真正的问题是，为什么我们作为一个外来人可以很快地上手他们的项目，而他们自己的新员工却很长时间才能上手。</p>\n<p>这是一个很有趣的问题。</p>\n<p>正如我在前面那篇文章里写到的，通常我加入一个项目，我首先要获得这个项目的大图景。作为一个ThoughtWorker，我一定会了解这个项目业务价值，它要解决的问题是什么。即便是技术，我也会尝试先从架构入手。等有了大图景，具体到一个问题时，我就知道它在整个项目中，是拼图的哪一块。</p>\n<p>对比而言，客户的很多新人加入一个项目时，常常是试图从一个具体的问题着手，在解决问题的过程中，有太多小障碍了，每次遇到的几乎都是一个全新的问题。所以，几乎就是一路磕磕绊绊。当然，这里不排除我比客户的大多数新人工作经验丰富，所以，对于大部分技术理解能力要比他们好。</p>\n<p>我看到的另外一点大的差别是，我了解项目时，我会按照自己的思路，通过问题，一步步将项目分解开来，也就是从业务到技术，从大框架到小模块。通常，只要与我交流的人对项目足够了解，基本上，我都可以把项目大致梳理出来。</p>\n<p>相较而言，一些新人的接收模式是，等着别人按照他们的思路来介绍。以我和许多客户的合作经历来看，大多数经年累月的项目往往是不足够清晰，甚至是相当混乱的，在这个项目上长时间工作的人也很难把它梳理得很清楚，所以，指望他们把项目介绍清楚只能祈求好运了。前面那篇文章我提到过，许多人是把业务和技术混在一起的，这是我经历过的实际情况。</p>\n<p>除了按照上面所说的方式理解项目，之所以会给人一个很快上手项目的感觉，可能还有一点：使用“行话”，也就是客户他们常用的术语。与人用“行话”交流，往往会更容易建立彼此的信任，也会让人认为你对交流的东西很懂行，这或许算是附赠的技巧吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201407022237",
    "date": "2014-07-02",
    "time": "22:37",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.9.2发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/255406345.html\">Moco 0.9.1发布</a></p>\n<p>我很高兴地宣布，Moco 0.9.2发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p>Moco是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>本次发布最大的变更是加入了HTTPS的支持。</p>\n<p>HTTPS服务器的创建即不同于普通的HTTP服务器，它使用的是httpsServer方法，除了类似于HTTP服务器的参数之外，一个很重要的参数是certificate，这里需要给出相应文件以及对应keystore密码和certificate密码。</p>\n<p>final HttpsCertificate certificate = certificate(pathResource(\"cert.jks\"), \"mocohttps\", \"mocohttps\");<br>final HttpsServer server = httpsServer(12306, certificate);</p>\n<p>独立服务器用户也可以通过命令行生成一个HTTPS服务器：</p>\n<p>java -jar moco-runner-&lt;version&gt;-standalone.jar start -p 12306 -c foo.json --https /path/to/cert.jks --cert mocohttps --keystore mocohttps</p>\n<p>还有一个比较重要的调整，在JSON配置中，增加了直接对JSON的支持，比如，</p>\n<p>{<br> &nbsp; &nbsp;\"request\": {<br> &nbsp; &nbsp; &nbsp; &nbsp;\"uri\": \"/json_response_shortcut\"<br> &nbsp; &nbsp;},<br> &nbsp; &nbsp;\"response\": {<br> &nbsp; &nbsp; &nbsp; &nbsp;\"json\": {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"foo\" : \"bar\"<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</p>\n<p>这样，给出应答就会是一个JSON对象：</p>\n<p>{<br> &nbsp; &nbsp;\"foo\" : \"bar\"<br>}</p>\n<p>而原来的做法如果需要返回一个JSON对象，需要大量的转义字符或是存放到文件中。</p>\n<p>在API方面，也做了许多调整：</p>\n<ul>\n<li>在Java API中，增加了HTTP版本协议类，无需以字符串的方式制定HTTP版本。</li>\n<li>在匹配方面，增加了更多的运算符，比如startsWith、endsWith、contain、exist。</li>\n<li>对于RequestHit的验证，增加了between运算符，可以判断请求次数在某个区间内。</li>\n<li>增加了多个Request Monitor的接口，以便处理遗留代码的时候，可以同时进行验证和查看日志。</li>\n<li>在模板接口上，将模板变量的类型由Object接口改成了String，这样，API用户必须确定好模板变量具体的表现形式。</li>\n</ul>\n<p>更多的细节请参考<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/ReleaseNotes.md\">ReleaseNotes</a>。</p>\n<p><strong>感谢</strong></p>\n<p>感谢<a href=\"https://github.com/msvab\">Michal Svab</a>，实现了HTTPS API部分。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201406121446",
    "date": "2014-06-12",
    "time": "14:46",
    "tags": [
      "测试",
      "guava",
      "ticker",
      "joda"
    ],
    "title": "测试“时间”",
    "body": "<p>在单元测试中，与时间相关的测试总是让人很头疼。举个例子，我们希望做一个定期过期缓存，比如30分钟过期，这该怎么测试呢？等30分钟？那要是过期时间是3天，你打算把开发时间全部交给等待，然后向老板汇报，我在等测试。祝你有一个糊涂的老板！</p>\n<p>我们不妨分析一下，看看有没有什么不那么令人发指的解决方案。以上面的缓存为例，缓存怎么知道过了多长时间，它肯定是在哪取个时间？对于Java应用来说，很有可能最终就是调到System.currentTimeMillis()或者nanoTime()。但是，这两个方法都是静态方法，想用Mock的人可以休息了。</p>\n<p>那么直接调用操作系统的方式修改时间呢？可以，只是一旦与具体的OS相关，各种跨平台的问题就随之而来，总而言之，麻烦。</p>\n<p>许多计算机问题都是可以通过引入间接层来搞定的，这一次又到了“间接层”的表演时间了。正如前面所说，与时间相关的应用最终可能都要到最底层那两个方法。如果我们可以做一层隔离，让所有的调用都来到间接层，我们就可以在间接层上做手脚了。</p>\n<p>事实上，这是一个如此通用的问题，以致于我们甚至都不需要提供自己的解决方案。</p>\n<p>在Guava中，有一个类叫Ticker，它提供了一个方法叫做read()，他就是我们的间接层。缺省情况下，我们会直接使用Ticker.systemTicker()，顾名思义，它是系统提供的ticker，read方法最终会调用倒System.nanoTime()。如果测试需要，我们可以自己Mock出来一个Ticker，就像下面这样：</p>\n<p>Ticker ticker = mock(Ticker.class);<br>long time = Ticker.systemTicker().read();<br>when(ticker.read()).thenReturn(time, time + TimeUnit.SECONDS.toNanos(10));</p>\n<p>这段代码第一次调用时返回一个时间，第二次调用返回的时间就是第一次调用的10秒之后了。所以，如果你的代码依赖于Ticker，剩下的魔法你都可以自己完成了。</p>\n<p>不过，这还不是终点。</p>\n<p>在Java中，谈及时间和日期，Joda Time已经是一个必选项了。实际上，Joda Time也为自己的用户提供了一套解决时间测试的方案，它有一个DateTimeUtils.setCurrentMillisFixed方法，我们可以传入一个固定的时间，比如，10秒后。时间就固定在那了。当然，如果你需要让时间重新流动起来，需要调用一下DateTimeUtils.setCurrentMillisSystem。</p>\n<p>原理很简单，Joda Time底层最终会调用DateTimeUtils.currentTimeMillis方法，而我们调用的set方法就会让这个方法返回不同的值，当然，缺省的是系统时间。</p>\n<p>Ticker和DateTimeUtils.currentTimeMillis在单位上有个差别，Ticker用的是System.nanoTime()，而DateTimeUtils.currentTimeMillis则如名所示，使用的是System.currentTimeMillis()。</p>\n<p>好了，这就是测试“时间”的方法。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201405281141",
    "date": "2014-05-28",
    "time": "11:41",
    "tags": [
      "服务端软件设计",
      "Optional"
    ],
    "title": "服务端软件设计（二）",
    "body": "<p>数据，是软件处理的核心，我们写各种各样的应用都是为了处理数据。处理数据有一个非常重要的前提，数据是合法的。一个计算数字的应用如何面对一堆字符呢？为了保证应用可以正常运行，各种校验是必不可少的。</p>\n<p>问题来了，校验该在哪做呢？</p>\n<p>显然到处做校验不是一个好主意，那到底服务层、数据层，还是接口层，才是校验的藏身之所呢？</p>\n<p>为了不让校验四处进行，一个建议的做法是在数据的入口进行校验，保证所有进入系统的数据都是合法的，这样一来，所有逻辑处理的代码只要关心逻辑就好了，而不需要关心数据合法性。比如说，客户端请求就在请求到达的入口进行校验，而从数据库读出的内容，就在数据层进行校验，而如果是集成了其它的服务，则要在读回数据的地方立刻进行校验。数据一到系统，先进行校验，如果有错了，就会立即发现，而不是等到数据跑到了程序里面，出错了，我们再去定位数据的来源，这种做法符合我们常说的“Fail Fast”原则。</p>\n<p>有一个有趣的问题，作为一个对细节特别较真的程序员，如果我的数据是字符串，虽然你说你在接口部分校验了数据，万一你遗忘了，流到了我这里，我不放心啊！所以，我可能还要在我这里写一遍校验。</p>\n<p>对于这个问题，我只能说，谁让你把字符串到处传了？</p>\n<p>事实上，在开发初期，很多东西用字符串表示起来很简单，比如语言，比如Tag。这种不精心的实现就会给未来带来很多麻烦。正如前面这个问题，其实大多数时候，你需要的不是一个字符串，而是一个“东西”，它应该被封装起来。所以，与其纠结于这个字符串是否还要校验，请考虑封装。</p>\n<p>另外一个有趣的问题是，如果我这个数据允许为空怎么办？想想都头疼，到处判断一个对象是否为空。</p>\n<p>如果我们能分清能为空的对象和不能为空的对象，那就再好不过了。幸好我们有了<a href=\"http://dreamhead.blogbus.com/logs/235329092.html\">Optional</a>，它给我们提供了一个有意义的空。结合前面的内容，在接口部分，如果数据可能为空，我们就用Optional把它包装起来，而普通对象则直接传递。我们就在程序里有了一个约定：</p>\n<ul>\n<li>Optional的对象可以为空，需要判断的时候，自己处理一下。</li>\n<li>普通对象都不能为空，为空就直接空指针异常，因为那是错的。</li>\n</ul>\n<p>关于Optional，我强烈建议每个Java程序员都去了解。在Java 8里，它已经成为了JDK的一部分，如果你的Java版本还早，Guava做了很好的支持。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201405161138",
    "date": "2014-05-16",
    "time": "11:38",
    "tags": [
      "服务端软件设计"
    ],
    "title": "服务端软件设计（一）",
    "body": "<p>做服务端软件，几乎无可避免地会遇到集成。那些年受到SOA“熏陶”，对于很多团队来说，标准的做法似乎是这样的：从另外一个地方弄来一个WSDL，然后，用它生成代码。</p>\n<p>是时候编写自己的代码了，你的团队会怎么做？既然有了生成代码，它基本上也算是很好地反映了我们的业务需求，那就直接用这些类作为我们的领域对象，一切轻轻松松。</p>\n<p>下面是我的一个真实经历。</p>\n<p>还有最后一天，我们的项目就要发布了。这时客户一个技术负责人跑了过来，“有一个接口我们不能用了”，那是我们最重要的一个接口，少了它，整个应用几乎就不可用。不幸中的万幸是，有一个功能等价接口可以用。不过，这个新接口是一个完全不同的协议，一个全新的WSDL。</p>\n<p>先别抱怨为什么这么关键的问题在最后一天才发现。我们先想想这个变动会对系统造成怎样的影响。</p>\n<p>如果我之前的开发是依赖于这些生成代码，将其作为我的领域对象，作为一个核心功能，这就意味着我所有的代码几乎都要依赖于这些类。替换它几乎要把所有代码修改一遍。可明天我们就要上线了！</p>\n<p>你明白我的意思了，直接依赖于这些生成代码，几乎就宣判了项目的死缓。</p>\n<p>间接层，是解决许多所有计算机问题的利器。在这里也不例外。我们对于这种问题的解决方案是，编写自己的领域对象，即便它看上去生成对象一模一样。事实上，在这个问题上，阻碍许多人编写自己领域对象的原因多半就是两个类会一模一样。</p>\n<p>在软件设计中，一个重要的原则就是向着稳定的方向依赖。生成的代码是别人的东西，别人的东西稳定性是什么样的，谁知道呢！即便是JDK，大部分类也不是像我们想的那样稳定，比如日期，随着大家对于这些类日益深入，一些问题就会暴露出来。如果是自己团队编写的代码，至少有一个非常重要的优点，我们拥有控制权，我们可以根据业务发展需要自行修改。依赖别人永远不如依赖自己靠谱。</p>\n<p>回到我的经历上。实际上，我那天真正做的修改就是重新写了一下从生成协议代码到自己领域对象适配部分的代码，因为生成代码与其它部分代码没有任何关系。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201405152111",
    "date": "2014-05-15",
    "time": "21:11",
    "tags": [
      "部署"
    ],
    "title": "不部不知道",
    "body": "<p>这是一个关于部署的话题，一句话，部署要趁早。</p>\n<p><strong>故事1</strong></p>\n<p>我们的应用有一个静态导出功能，在自己开发环境中，我们做了无数次导出，没有任何问题。但上到真正的环境中，导出功能一下子不起作用了。</p>\n<p>经过紧张的调试，我们把目光聚集到一个配置上，它是一个用来处理导出的URL，这个URL的地址是一个内部地址。在真正的环境里，每一台机器都会有内部IP和外部IP，我们用来登陆进行配置的是一个内部IP，但用浏览器登陆时，我们却用的是外部IP。所以，当试图访问一个内部IP地址时，自然就访问不到了，于是，导出过程就挂掉了。</p>\n<p>改正很简单，只要把配置改成外部IP即可。</p>\n<p><strong>故事2</strong></p>\n<p>做Web应用，开启gzip压缩是不可避免的。我们在自己的Nginx服务上测试好的配置文件，部署到了真正的环境中，gzip死活不起作用了。最初，我以为是自己的配置没有起作用，结果，用内部地址访问以下，一切正常。可为什么用域名访问就访问，难道域名解析还和gzip压缩有关？</p>\n<p>经过半天紧张的调试，我们把焦点定位在了负载均衡器上。请求通过域名在真正环境是要先到达负载均衡器的，然后，由负载均衡器分发到后台的Nginx上。这种访问模式实际上成了反向代理，所以，在Nginx上，要想gzip在这种模式下工作，需要把gzip的代理模式打开，比如：<br>&nbsp; &nbsp; &nbsp;gzip_proxied any</p>\n<p><strong>故事3</strong></p>\n<p>如果我们做的是一个老应用的改版，为了搜索引擎，无可避免的一件事是要兼容老应用的一些URL。初想起来，有一个很简单的做法，在Nginx上配置一些URL rewrite规则即可。</p>\n<p>&nbsp; rewrite /old/url /new/url permanent;</p>\n<p>在我们测试环境一切正常，但是，上了真正的环境，这个跳转一下子不起作用了。原来，在真正的环境里，给外部访问所用的端口与内部部署的端口是不一样的，而这个跳转是正常的，只不过，它跳到了内部的端口，而这个端口在外部是不可见的，于是，出了问题。</p>\n<p>给出一个quick and dirty的解决方案很容易，给出一个绝对地址用于跳转即可：</p>\n<p>&nbsp; rewrite /old/url http://outside/new/url permanent;</p>\n<p>上面的几个小故事遇到的问题其实是一样的，部署环境和测试环境的差异。即便我们的软件写得完美无缺，环境永远是不可轻视的。除非我们能做到让所有环境完全一致，从头到尾，否则还是那句话，部署要趁早。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201404080657",
    "date": "2014-04-08",
    "time": "06:57",
    "tags": [
      "运维",
      "开发",
      "DevOps"
    ],
    "title": "当开发遇到运维",
    "body": "<p>对于很多团队来说，开发和运维现在还是两个世界的人，开发人员写着属于自己的代码，然后丢给运维人员。但作为开发人员，我们必须知道，运维的方式对于开发上的抉择是有影响的。</p>\n<p>和这个世界上的许多项目一样，我现在正在开发的项目也有一些后台定时运行的任务。这是一个Java应用，但我并不想把这些定时任务扔进Java EE容器里，没有必要让这些后台应用和前台应用抢资源。所以，我们就把它做成了一个独立的应用。好，问题来了，谁来做定时调度？</p>\n<p>因为我们的应用最终会部署在Linux操作系统上，所以，我的第一个直觉就是采用Cron。这是一个已经存在了几十年的解决方案，没有任何问题，而且，开发团队几乎不需要做任何额外工作。这个方案一直存在到我们和运维团队交流为止。</p>\n<p>“我们不允许使用任何系统任务”，运维团队开门见山地否决了我们的解决方案。运维团队给出的理由是，他们无法保证一台机器上只运行一个应用，如果其中一个应用挂了，运维人员也许会清理一些资源，换句话说，如果你的应用用了这些东西，也许会被一不小心地删掉了。“所以，按照我们规定，每个应用只能开辟自己的目录，运用自己目录下东西。”</p>\n<p>这是一个合理的要求，所以，我们需要调整自己的设计方案，把原来交由系统处理的调度转成由自己的应用处理。当然，在Java世界，这不是太大的难度，Quartz框架很好地帮我们处理了这些。</p>\n<p>其实，与调度方案同时被推翻的还有我的另外一个方案。这次我原本想尝试把我们的日志写到系统日志里。如果你不知道的话，rsyslog可以让我们把自己的日志写到/var/log下。很显然，这样的方案在这样约束下也是不行的。我们只好回到Java的传统方式上，把日志写到自己的目录下。</p>\n<p>这是两个由运维反过来影响开发方案的小例子。运维是开发的一种很重要的组成部分，运维团队的一些工作方式直接影响到开发上的一些决策。所以，如果开发和运维还是两个团队，开发团队不妨多找运维团队聊聊，更多地了解关于部署的方方面面。当然，更好的解决方案是走向通往DevOps的康庄大道。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201403302131",
    "date": "2014-03-30",
    "time": "21:31",
    "tags": [
      "jackson"
    ],
    "title": "Jackson雕虫技（四）",
    "body": "<p><a href=\"http://www.blogbus.com/dreamhead-logs/230244031.html\">Jackson雕虫技（一）</a><br><a href=\"http://www.blogbus.com/dreamhead-logs/230244140.html\">Jackson雕虫技（二）</a><br><a href=\"http://www.blogbus.com/dreamhead-logs/258185547.html\">Jackson雕虫技（三）</a></p>\n<p><strong>忽略空字段</strong></p>\n<p>有时候，我们返回对象的字段可能会有为空的情况。缺省情况下，这些字段会以null的形式呈现出来。但如果我们希望忽略这些字段该如何处理呢？如果是针对某个具体的类，我们可以使用JsonInclude这个annotation。</p>\n<p>@JsonInclude(JsonInclude.Include.NON_NULL)<br>class Entity {<br> &nbsp; &nbsp;...<br>}</p>\n<p>如果所有类都能够遵循这样的规则，那就要在全局配置了，配在Object Mapper上：</p>\n<p>&nbsp; mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</p>\n<p><strong>Joda-Time</strong></p>\n<p>在《你应该更新的Java知识》里面，我推荐大家在Java 8之前使用Joda Time，而非JDK原生的Date和Calendar。但是，如果我们使用了Joda Time，到了Jackson该怎么办呢？</p>\n<p>Java对象和JSON的相互转换，只是一个序列化和反序列化的过程。我们在之前的雕虫技中已经见识过如何针对自己的类自定义序列化和反序列化。所以，本质上来说，为Joda Time自定义一套，自然也不是什么难事。不过，通用如Joda Time这样的程序库，自然也应该有现成的支持。我们直接拿过来用就好了。</p>\n<p>实际上，Jackson已经为Joda Time提供了官方支持。如果你和我一样喜欢Gradle，下面就是依赖的添加方式，其中，jacksonVersion自然是Jackson的版本号。</p>\n<p>&nbsp; \"com.fasterxml.jackson.datatype:jackson-datatype-joda:$jacksonVersion\"</p>\n<p>有了依赖，我们只要在Object Mapper上注册一个模块即可。</p>\n<p>&nbsp; mapper.registerModule(new JodaModule());</p>\n<p>现在就可以自己的对象里使用DateTime、LocalDate、LocalTime这样的类型了，有了JodaModule，Jackson就会为我们照顾好这些类型的转换。</p>\n<p>我们习惯的日期表示方式一般是年月日时分秒，但Joda Time缺省的做法却是一个数字，一个以毫秒为单位计算出的数字，它叫时间戳。如果你希望让它变成我们喜欢的样子，可以这样做：</p>\n<p>&nbsp; mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);</p>\n<p>如果你还让自己的日期表现方式中加入时区，那就再加上时区：</p>\n<p>&nbsp; mapper.setTimeZone(TimeZone.getDefault());</p>\n<p><strong>Guava</strong></p>\n<p>同样在《你应该更新的Java知识》，我还提到一个观点，只要是Java项目就应该使用Guava。我也展示过Guava中一些库的用法。我现在已经无可救药地爱上了Guava中的不变集合。但同Joda Time一样，Guava不是标准的JDK的一部分，也需要额外的支持。值得高兴的是，这个支持也有现成的，也来自Jackson的官方，依赖如下：</p>\n<p>&nbsp; \"com.fasterxml.jackson.datatype:jackson-datatype-guava:$jacksonVersion\"</p>\n<p>同样，它也要Object Mapper上注册一个模块。</p>\n<p>&nbsp; mapper.registerModule(new GuavaModule());</p>\n<p>如此一来，Jackson就可以支持Guava提供的大部分内容，包括Optional和一些不变集合，以及一些新增的集合。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201402151718",
    "date": "2014-02-15",
    "time": "17:18",
    "tags": [
      "jackson"
    ],
    "title": "Jackson雕虫技（三）",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/230244031.html\">Jackson雕虫技（一）<br></a><a href=\"http://dreamhead.blogbus.com/logs/230244140.html\">Jackson雕虫技（二）</a></p>\n<p><strong>使用Builder模式</strong></p>\n<p>在日常开发中，我们希望自己编写的类尽可能不变的，对于参数比较多的类，我们通常采用的方法是Builder模式。但如果我们使用Builder模式构造这样的不变对象，当我们将json反序列化成Java对象该怎么办呢？</p>\n<p>Jackson已经为这种做法做好了准备，我们可以告诉它这个类是采用Builder模式构建的：</p>\n<p>@JsonDeserialize(builder = DefaultHttpRequest.Builder.class)<br>public class <a href=\"https://github.com/dreamhead/moco/blob/master/moco-core/src/main/java/com/github/dreamhead/moco/model/DefaultHttpRequest.java\">DefaultHttpRequest</a> implements HttpRequest {<br> &nbsp;...<br>}</p>\n<p>我们使用了一个Annotaiton：@JsonDeserialize，通过builder参数告诉它，用哪个类做Builder。这里用的就是这个类的一个内嵌类：Builder。</p>\n<p>public class DefaultHttpRequest implements HttpRequest {<br>&nbsp; &nbsp;...</p>\n<p>&nbsp; public static final class Builder {</p>\n<p>&nbsp; &nbsp; ...</p>\n<p>&nbsp; &nbsp; public Builder withVersion(String version) {<br>&nbsp; &nbsp; &nbsp; this.version = version;<br>&nbsp; &nbsp; &nbsp; return this;<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; ...</p>\n<p>&nbsp; &nbsp; public DefaultHttpRequest build() {<br>&nbsp; &nbsp; &nbsp; ...<br>&nbsp; &nbsp; &nbsp; return request;<br> &nbsp; &nbsp;}<br>&nbsp; }<br>}</p>\n<p>其中，以with开头的就是用来传参数的方法，而build方法则用以构建最终的对象，这是一个缺省的约定。我们还可以按照自己的需要进行订制，只不过要给我们的Builder加上另外一个Annotation：@JsonPOJOBuilder。下面是一个例子：</p>\n<p>@JsonPOJOBuilder(buildMethodName=\"create\", withPrefix=\"con\")<br>public static final class Builder {<br>&nbsp; &nbsp;...<br>}</p>\n<p>这样一来，所有传参的方法都是以con开头，而构建对象的方法名则改成了create。</p>\n<p><strong>使用对象简化解析</strong></p>\n<p>在《<a href=\"http://dreamhead.blogbus.com/logs/230244140.html\">Jackson雕虫技（二）</a>》，我们提到了可以用自定义解析的方式解析对象，但一个一个字段解析写起来并不直观。其实，我们还可以借用已有的对象解析机制简化这个过程。下面是<a href=\"https://github.com/dreamhead/moco\">Moco</a>的<a href=\"https://github.com/dreamhead/moco/blob/master/moco-runner/src/main/java/com/github/dreamhead/moco/parser/deserializer/ProxyContainerDeserializer.java\">ProxyContainerDeserializer</a>，它根据当前正在解析的目标进行处理，要么解析成一个URL，要么解析成一个Proxy的配置。</p>\n<p>public class ProxyContainerDeserializer extends JsonDeserializer {<br>&nbsp; &nbsp;@Override<br>&nbsp; &nbsp;public ProxyContainer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {<br>&nbsp; &nbsp; JsonToken currentToken = jp.getCurrentToken();<br>&nbsp; &nbsp; &nbsp;if (currentToken == JsonToken.VALUE_STRING) {<br>&nbsp; &nbsp; &nbsp; return builder().withUrl(jp.getText().trim()).build();<br>&nbsp; &nbsp; } else if (currentToken == JsonToken.START_OBJECT) {<br>&nbsp; &nbsp; &nbsp; InternalProxyContainer container = get(jp.readValuesAs(InternalProxyContainer.class), 0);<br>&nbsp; &nbsp; &nbsp; return container.toProxyContainer();<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; throw ctxt.mappingException(TextContainer.class, currentToken);<br>&nbsp; }<br>}</p>\n<p>这里的关键是readValuesAs，我们没有直接解析接下来的Token，而是确定解析目标之后，又借用了解析器本身的能力，把它解析成一个对象。至于InternalProxyContainer，它只是一个简单的对象类，用以装载解析的结果。</p>\n<p>private static class InternalProxyContainer {<br>&nbsp; public String url;<br>&nbsp; public String from;<br>&nbsp; public String to;<br>&nbsp; public String failover;<br>&nbsp; public String playback;</p>\n<p>&nbsp; public ProxyContainer toProxyContainer() {<br>&nbsp; &nbsp; ...<br>&nbsp; }<br>}</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201402012238",
    "date": "2014-02-01",
    "time": "22:38",
    "tags": [
      "Moco"
    ],
    "title": "Moco 0.9.1发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/236571479.html\">Moco 0.9发布</a></p>\n<p>我很高兴地宣布，<a href=\"https://github.com/dreamhead/moco\">Moco</a> <a href=\"https://github.com/dreamhead/moco/tree/v0.9.1\">0.9.1</a>发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p>Moco是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>按照版本号来说，这是一个小的修复版本，但实际的修改一点都不少。</p>\n<p>首先，这个版本增加了runner API，让我们可以自己在测试代码里控制Moco服务器的启停。最常见的做法是在集成测试的最初，启动一个服务器，结束之后关闭，下面是一个例子：</p>\n<p>@Before<br>public void setup() {<br> &nbsp; &nbsp;HttpServer server = httpserver(port());<br> &nbsp; &nbsp;server.response(\"foo\");<br> &nbsp; &nbsp;runner = runner(server);<br> &nbsp; &nbsp;runner.start();<br>}</p>\n<p>@After<br>public void tearDown() {<br> &nbsp; &nbsp;runner.stop();<br>}</p>\n<p>在配置API方面，增加了对proxy的批处理方法，我们可以一次性的代理一组URL，比如：</p>\n<p>server.proxy(from(\"/proxy\").to(\"http://remoteUrl/target\"));</p>\n<p>proxy还增加了一个playback的配置，它也是用来在本地存储远程服务器的内容，与failover不同的是，当本地内容可用时，它就不再访问远程服务器，换言之，它是本地优先的。</p>\n<p>server.request(by(uri(\"/proxy_playback\")))<br> &nbsp; &nbsp; &nbsp;.response(proxy(\"http://remoteUrl/target\"), playback(path-to-local-playback)));</p>\n<p>这次的发布对模板也进行了改进，增加了对模板变量的支持，你可以根据自己的需要定制模板内容：</p>\n<p>server.request(by(uri(\"/template\"))).response(template(\"${var}\", \"var\", \"TEMPLATE\"));</p>\n<p>这次发布还增加了一个全局配置选项：Response。它的作用是，给所有的应答添加一个同样的内容，比如HTTP头。它主要用于独立运行模式，模拟很多类似的请求：</p>\n<p>[<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;\"response\" : {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"headers\" : {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"foo\" : \"bar\"<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;},<br> &nbsp; &nbsp; &nbsp; &nbsp;\"include\": \"src/test/resources/settings/foo.json\"<br> &nbsp; &nbsp;}<br>]</p>\n<p>本次发布修正了Moco存在的一些问题，比如HTTP连接关闭，内容验证，服务器完全关闭等问题，让Moco的质量更上了一个台阶。本次发布还有一个重大的调整，采用Proguard将Standalone的JAR规模大幅度缩小，上一次发布Moco的Standalone包有8M多，而这次只有不到5M。</p>\n<p>更多的细节请参考<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/ReleaseNotes.md\">ReleaseNotes</a>。</p>\n<p><strong>感谢</strong></p>\n<p>感谢崔鹏飞，协助发现修复了HTTP连接关闭的问题。</p>\n<p>感谢<a href=\"https://github.com/htynkn\">黄云坤</a>，实现Proguard压缩Standalone JAR包。</p>\n<p>感谢<a href=\"https://github.com/marcingrzejszczak\">Marcin Grzejszczak</a>，协助发现并修复了服务器完全关闭的问题，并贡献了gmoco的脚本。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201312311835",
    "date": "2013-12-31",
    "time": "18:35",
    "tags": [
      "脚下的路"
    ],
    "title": "回望2013",
    "body": "<p>2013年就这么又过去了，站在又一年的门槛上，想想这过去的一年，如果选择一个主题词，我想是“坚持”。</p>\n<p><a href=\"https://github.com/dreamhead/moco\">Moco</a>，我在2012年无意间开启的一个开源项目，居然让我坚持住了。我经常会兴之所至，开始写一些小项目，但如果不是有像Github之类的站点，我都不记得我曾经这么想过。但Moco，我就这么一直做下来了。回想起来，Moco从一开始就是一个相对完整的小项目，从一开始就有用户，有反馈，我也就乐呵呵地一直做着。每天为Moco写点代码已经成了我日常生活的一部分，所以，我有了超过300天连续提交。</p>\n<p>坚持的回报是，Moco在2013年拿了两个大奖，一个是ThoughtWorks中国区技术大赛最具技术创新奖，另一个则是更具外部影响力，2013年Oracle的Duke选择奖，这个奖让更多人认识了Moco，也让Moco有了更多的用户，更多的反馈，也促使我不断地，美滋滋地继续为Moco写代码。在可见的未来，Moco还有不少要实现的东西。</p>\n<p>2013年11月，我用了大半年翻译的《<a href=\"http://book.douban.com/subject/25772791/\">The Joy of Clojure</a>》终于<a href=\"http://dreamhead.blogbus.com/logs/239426524.html\">正式出版了</a>，也算是为之前的辛苦划上一个句号。正是因为我花了很多时间和精力在上面，所以，我觉得，翻书这活这不好干：不好好干，对不起别人；好好干，对不起自己。于是，我暗下决心，洗手不干了。就在我决定洗手不干了之后，我又组织翻译了《<a href=\"http://book.douban.com/subject/19976542/\">ThoughtWorks文集2</a>》，虽然我没有翻译初稿，但后续的审校花费的时间和精力不比任何一个译者少，所以，最终写译者序的人，居然是我。</p>\n<p>2013年，我还偶尔出去讲了几次东西。在Open Party成都，我讲过Moco，讲过《Java as a Platform》。因为Duke选择奖的原因，我又得到了一个机会，在QCon上分享Moco的故事：《不可思议的Moco》。运气很不错，除了免费差旅，我还拿到了优秀讲师的称号，奖品是一个Kindle Paperwhite 2，据说InfoQ中文站的老大Kevin肉身翻墙背回来的。去年年底，因为出差澳洲的原因，错过了敏捷之旅成都站，今年组织者竟然还记得有我这个人存在，于是，年底又在敏捷之旅讲了一个《你应该更新的开发知识》，还被放到了主题演讲的位置。</p>\n<p>从2013年5月份底开始，ThoughtWorks中国区这边开始有了一个小栏目，<a href=\"http://voice.thoughtworkers.org/\">ThoughtWorker好声音</a>。我们每周会选择几篇ThoughtWorker写的技术方面的文章组织起来，分享给更多的人看。从一开始的成都办公室内部分享，到后来中国区的内部分享，再到后来，我们搭建了自己的网站，通过ThoughtWorks的微博、微信对外分享。这个小栏目已经逐渐受到越来越多人的关注，它已经成为ThoughtWorker对外展示的舞台。在内部发行版里，我们甚至会把它翻译成英文，让我们更多的外国同事了解到中国区这边的技术发展情况。之所以我把公司的小栏目放到自己的年终总结里面，因为我是这个活动背后的发起者，好声音最初的几期完全是由我一手打造的。现在，我已经不再是这个栏目的瓶颈了，背后已经有了更多的人。我很欣慰，因为我们坚持下来了。</p>\n<p>2013年初，我给自己制定了一个读书目标，一年读30本书。最终的结果是，<a href=\"http://www.yuedudna.com/users/1042340/book/2013\">一年读了52本书</a>。原来制定目标，只是为了让自己多读书，且不会压力太大，结果养成了读书的习惯，每天早晚都会拿起书读一会。虽然我一直号称自己喜欢读书，但还真没抓紧时间读过，有不少以前“想”读的书，这次是真读了。感谢Kindle，让读书变得比以往更容易了。</p>\n<p>2013年，也是我写blog的<a href=\"http://dreamhead.blogbus.com/logs/242009297.html\">第十个年头</a>，也许因为时间关系，现在已经没有从前写得那么频繁了，但脚步没有停下。用它总结“坚持”的一年是很恰当的。在年中做的一篇<a href=\"http://www.csdn.net/article/2013-08-23/2816684-Moco-Java-framework\">CSDN访谈</a>中，我说过：“找到一个适合自己的平台，坚持写程序，坚持思考，十年后，便会与众不同。”现在，我越发相信坚持的力量了。</p>\n<p>2013年就这么结束了，从结果上来看，这是我值得骄傲的一年，做出了以往不曾做过的一些事。2014年，我还希望自己能够做一些不同以往的事。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201312112158",
    "date": "2013-12-11",
    "time": "21:58",
    "tags": [
      "脚下的路"
    ],
    "title": "十年",
    "body": "<p>刚开始工作的时候，我很愿意了解关于计算机发展的各种各样故事，俗称八卦，因为我特别想知道，我所从事的职业是如何走到今天的。如今，我偶尔会梳理一下经历过的事情，讲给其他人听，他们的神情和我当年了解各种八卦时，别无二致。原来，我前面经历过的时代业已成为历史的一部分。</p>\n<p>十年前，初出茅庐不久的我，选择了一种表达方式，blog，那时候绝对算是个新东西，知道这个名字的人都算是站在时代的风口浪尖，更别说自己写了。不记得在blog上说过多少次了，我能坚持下来的东西不多，编程是一个，写blog居然成了另外一个。</p>\n<p>是的，我写blog，整整十年了。</p>\n<p>十年过去了，blog已经成了落寞贵族，连Google都不玩Reader，微博这个后来才兴起的东西，现在也快被微信挤掉了。人们喜欢表达，只是表达方式越来越简洁，越来越便利。不过，当我觉得自己需要整理一下自己的思路时，blog依然是我的首选，在我看来，安安静静写字时，会有更多的思考。</p>\n<p>曾经有许多人问过我，为什么不自己搭建一个独立blog，或者是在Github上弄个至少有代码样式的blog。懒，是一个很重要的原因。另外一个原因是，习惯。十年了，我甚至连blog的模板都没有换过，所以，今天看我的blog，样子上和十年前如出一辙，我还是从前的那个我。也许未来我会换，但我不知道那一天什么时候到来。</p>\n<p>十年前，我选择了blogbus作为blog的存放地，如今看来是件很幸运的事。但很多人不知道或者不记得当年的BSP之争，十年后，回过头来看，当年的BSP留到现在的几乎没有几家了，而我的blog十年了，依然还在，只有运气可以形容。</p>\n<p>还记得第一年写了100篇，之后，几乎就是一个稳步减产的过程。不管怎样，十年下来，我还是写了500多篇blog。偶尔翻看从前的blog，那是一个追忆似水年华的过程，我会感叹，年轻就是生猛，或者我还有这么傻的时候。感谢这些blog，让我有了一些可以追溯的往事，让我不曾遗忘曾经发生过的事情。</p>\n<p>我想我还会写下去，我现在格外相信坚持的力量，我的一些坚持让我变得和从前不一样，不再只是纯粹的三分钟热血。总的说来，我喜欢这种改变，并没有滑向“成为自己讨厌的人”的深渊。</p>\n<p>希望十年之后，我还可以说，我又坚持了十年。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201311241027",
    "date": "2013-11-24",
    "time": "10:27",
    "tags": [
      "Clojure",
      "翻译"
    ],
    "title": "译《Clojure编程乐趣》",
    "body": "<p><a style=\"margin: 5px; float: left;\" href=\"http://book.douban.com/subject/25772791/\" target=\"_blank\"><img style=\"border: none;\" src=\"http://img3.douban.com/mpic/s27141806.jpg\" alt=\"\"></a></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>去年六月份，我正在与DSL这本书做斗争，痛苦不堪，我甚至已经暗下决心，再也不接手翻译这种费力不讨好的事情了。张凯峰突然发了封邮件问我要不要翻译书，我当时有一种杀了他的心。除非是《The Joy Of Clojure》，因为我实在是想了解一下Clojure，而且关于这本书，很多人都说它是可以改变人们对于编程认识，我很好奇。天杀的的张凯峰真的找来了《The Joy Of Clojure》，我知道，又有一部分业余时间没了。</p>\n<p>这次的合作是和陈冀康（<a href=\"http://weibo.com/childchen\">@childchen</a>），人邮信息分社。按照出版社的要求，他们肯定是希望这本书越早完成越好，感谢陈冀康对我宽容，答应我半年的翻译期限。我的算法很简单，每天两页，三百多页的书，大概一除，半年左右。另外，鉴于翻译DSL的痛苦经历，我暂且不想与任何人合作翻译，要知道，团队协作，每个人的责任感就会大幅度下降，这是导致DSL晚出版近一年的主要原因。</p>\n<p>之后就是漫长的翻译过程，我不得不承认，这是一本非常好的书，但却是不是一本给初学者的书。作为一个没有Clojure经验的开发者，为了能翻译得更地道，只好又额外地学了很多东西。幸运的是，在翻译过程中，我找到了一个国内很少有的真正的Clojure开发者，庄晓丹（<a href=\"http://weibo.com/fnil\">Dennis Zhuang</a>），他愿意作为审校加入到这个过程中来。事实上，对我来说，他不仅仅是一个审校者，更是我的一个老师，教会了我许多关于Clojure的东西。</p>\n<p>我从前翻译的时候，大多不加译者注，因为我会把读者同自己的能力等同起来，我觉得只要我能理解，读者理解起来是没有什么问题的，我不想把读者假设得太小白，但这本书里，我写了很多译者注，因为很多东西我理解起来都不容易，所以，这是我加注最多的一本书。</p>\n<p>相比于之前翻译过的一些书，这本书在英文上也绝对是个大挑战，别的不说，就是目录标题都让我头疼了好一阵子。Dipping our toes in the pool，用脚趾头蘸一下游泳池，如果这样的文字出现在最终的书里面，肯定有人要骂娘的。书里面还有很多很地道的英文用法，换句话说，站在第二语言的角度，真的很难理解。幸好，我们的办公室里有许多外国同事，就为了这些翻译，我也不知道多少次骚扰了人家。</p>\n<p>这本书其实还有许多审校者，真正大篇幅坚持下来的不多，其中，我的原同事<a href=\"http://weibo.com/andyhu1007\">胡振波</a>是一个。他也参与过一些文章，一些书，文字功底还不错，帮我改了很多文字上的细节。还有一个审校者，虽然只看了序和前言，但也不得不提一下，我们家领导，作为一个对编程一窍不通的英语老师，帮我到这种程度，也是尽心尽力了。原本打算如果有写译者序的机会，一并感谢了，但人邮居然没给我这个机会。不管怎样，在此谢过了。</p>\n<p>翻译是在是个劳心费力的事情，我不打算再做，我又一次暗下了决心，除非《The Joy Of Clojure》出第二版。好吧，你或许已经知道了，第二版在第一版的中文版还没有出来之前，就已经开始写了。</p>\n<p>不管怎样，书出版了，心里总是高兴的。希望有更多的人通过这本书，开始体会编程的乐趣，即便你不是一个Clojure程序员。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201311220723",
    "date": "2013-11-22",
    "time": "07:23",
    "tags": [
      "Moco",
      "开发故事"
    ],
    "title": "战斗HTTP（下）",
    "body": "<p>当我在Moco的代码库里删除了关闭链接的代码时，我惊奇地发现Moco的一个测试失败了。怎么会失败呢？难道测试里面还有人需要强制关闭链接。</p>\n<p>带着种种疑问我又踏上了新一轮的代码跟踪之旅，这次的所有代码都在我自己的代码库里，一个简单的单元测试，无非是里面用到了Apache的HTTP Client。又是无数次的重试，我站到了一个InputStream的面前，这是在处理应答体时，要从HTTP应答流中读内容，然后，挂掉了。显然，当我强制关闭链接，读取就会返回，所以，测试可以通过。</p>\n<p>为什么会是这样？</p>\n<p>我不再简单粗暴地关闭链接，而是根据情况，如果客户端希望保持链接，我就保持，否则才会关闭。结果，测试依然是挂的。原因是这个测试请求保持链接，所以，服务器端不会关闭它的链接，所以，还会遇到相同的问题，它会挂住。</p>\n<p>到底什么样的行为才是正确的呢？我找到一本厚厚的《<a href=\"http://book.douban.com/subject/10746113/\">HTTP权威指南</a>》，仔细读了一下保持链接的章节。我对HTTP如何处理链接有了一个相对完整的认识，但对于这个问题，我依然没有答案。</p>\n<p>其它测试也会有保持链接的需求，为什么就可以顺利通过，而只有这个测试会挂住。</p>\n<p>坐在电脑面前解决不了的问题，往往需要在路上解决。我突然意识到，通过者和不通过者似乎是有些许差别的，赶紧回到电脑前，打开日志，这个不通过的测试与其它测试最大的差别是，它只有应答头，没有应答体。不奇怪，因为这个测试就是测试能够返回正确的HTTP头。</p>\n<p>我似乎明白了，当客户端要求保持链接时，它还是需要从链接中读取数据的，但应该读取多少，谁能告诉它这个答案呢？如果没有额外的提示，似乎就只能挂住。答案就在Content-Length上，有了这个HTTP头，客户端就知道该读多少了。</p>\n<p>想通这一点，代码就好改了。在保持链接的情况下，如果没有Content-Length，就设置相应的Content-Length。</p>\n<p>果然测试一遍通过，又把之前同事的测试用例拿了过来，重新跑了一遍，一切正常。放到他们的工程里面测试，也是顺利通过。</p>\n<p>从发现一个不稳定的问题，到最终比较完整地修复了它，前前后后两个星期。如果没有我那个执着的同事，可能我也不会严肃地对待这个问题；没有仔细地解决这个问题，也不会对HTTP协议处理有个新的认识。非常感谢我这个执着的同事，他叫<a href=\"http://cuipengfei.me/\">崔鹏飞</a>，下一次Moco发布公告中，我可要着力感谢一下他。</p>\n<p>一个同事跑到我面前，我在使用Moco时发现一个问题，它有时会挂住。你用的是不是CXF，我问他。是啊！他回答。我笑了，因为我刚刚修好了这个问题。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201311210722",
    "date": "2013-11-21",
    "time": "07:22",
    "tags": [
      "Moco",
      "开发故事"
    ],
    "title": "战斗HTTP（上）",
    "body": "<p>去参加QCon的路上，一个同事给我打了个电话，他在使用Moco的过程中，遇到了一个奇怪的问题：测试会时不时的挂住。在不明就里的情况下，我给出了一些常规性的建议，换个新版本试试，要不，能不能把情况简化到最简单的情形，发给我试试。</p>\n<p>几天后，我从QCon回来，那个同事愁眉苦脸地找到我：换了新版本，问题依然，更奇怪的是，当试图用最简单的情形重现时，现象居然就消失了。用抓包工具试试吧，看看底层发送的消息是不是对的。我又想到了一个常规的解决方案。他同意了，尝试了，又失败了，它在中间加了个代理，结果现象又消失了。两边发送的消息从HTTP报文的内容上，看不出什么端倪。</p>\n<p>我这个同事在办公室里是出了名的执着，几天之后，他又跑了过来，我已经写了个测试，已经能够稳定的重现这个现象了。我们一起坐下来，用单步跟踪的方式追着代码。经过无数次的运行，我们惊奇地发现，挂住的地方根本没有走到Moco里面，当第一次访问Moco服务器成功之后，离开Moco代码，在Netty框架里，试图select下一个要处理的请求时，就挂住了。而且很有趣的现象是，如果两次访问Moco服务器时间间隔较长，比如5秒，万事大吉，如果时间很短，基本上就会挂住。我们甚至开始怀疑是不是Netty本身出了问题。</p>\n<p>第二天，这个同事又取得了新的进展，他已经把这个测试简化到完全不依赖于他们的工程。这样，我们就可以在别的机器上进行调试，而且简化到最简单的情形之后，我们只关注最重要的东西。这次现象是相同的，挂住，但跟进去的结果却截然不同，这回出问题的地方是客户端，当发送了第一个请求之后，试图进行第二次发送时，请求就挂住了。</p>\n<p>我能怎么办呢？我又仔细品味了阅读了一下Moco的代码，突然注意到里面有这样一句：</p>\n<p>&nbsp; future.addListener(ChannelFutureListener.CLOSE);</p>\n<p>这句话的意思是，当请求处理完成之后，关闭链接。似乎灵光闪现，我查看了一下客户端发起的请求，在HTTP头里面有这样一句：</p>\n<p>&nbsp; Connection: keep-alive</p>\n<p>这显然是HTTP协议里面，用来请求服务器端保持链接的一种方式。如果你不知道的话，在一些HTTP协议的实现中，有时为了节省链接建立的资源，会复用之前已经建立好的链接，当然，前提条件是，服务器和客户端都支持。</p>\n<p>显然，Moco是不支持的。但客户端又有这种期望，所以，挂住了。简单地删除了负责关闭的代码，代码顺畅地通过了测试。这里面有两个问题，Moco服务器端支持是一方面，客户端实现是另一方面，换句话，当服务器端不支持长链接时，客户端应该做相应的处理，至少这个客户端没有做到，顺便说一下，这个库是CXF。</p>\n<p>这不是故事的结尾。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201311041741",
    "date": "2013-11-04",
    "time": "17:41",
    "tags": [
      "QCon",
      "脚下的路"
    ],
    "title": "QCon上海随想",
    "body": "<p>因为Moco，我得到了一个演讲的机会，在QCon上海的上做一个关于Moco的分享。上一次参加QCon还是几年前的事，短短几年时间，QCon已经成为了中国技术人员心目中干货众多的顶尖技术大会。参加这样的大会，分享只是其中很小的一部分，更多的是，出来见见世面，看看别人在做些什么，结交些新朋友。</p>\n<p>如今，国内技术社区的分享精神要比以往好了很多，这次大会大公司都站了出来，BAT的分享有很多，新浪、搜狐、豆瓣等也有自己的分享。这和前些年都是靠个体热情做社区、做大会的状况已经有了很大的转变。我依然记得很早以前，一说大会，基本上就会和广告挂钩的印象。而且，同阿里人聊天时，听说他们现在要在公司内成为高级技术专家，很重要的一个指标是，在社区内的影响力。能够把这个指标纳入考量体系内，确实是一个很好的引导方式，这也不难理解，为什么阿里系最近几年眼瞅着在技术社区内的名声越来越好。其它大公司在这个方面也有长进，但还有很长的路要走。</p>\n<p>出来讲是进步，但讲东西的水平实在让人不敢恭维。讲东西，最重要的是面向观众。遗憾的是，很多讲师就是在为自己讲，根本没有考虑过用怎样的一个思路讲能够更有代入感，更能让人接受。有一个腾讯的演讲，里面常常听到讲师说，这也没什么，那也很简单，一笔带过很多东西。实在是愧对那么多冲着大公司名头去的观众，也实在砸自己公司的牌子。当然，在后续的评分环节里，我很客气地给他打了很低的分数。</p>\n<p>其实，作为讲师，我是知道的，在这次大会之前，InfoQ专门请了专业的演讲培训师给讲师们做培训，我因为人不在京沪两地而遗憾错过。这些大公司的很多演讲者很多人都离京沪不远，如果没参加这个培训算是遗憾，如果参加了，那还真对不起老师。</p>\n<p>我个人最喜欢的一个分享是来自Facebook的，他介绍了Facebook的一个开源项目<a href=\"http://facebook.github.io/react/\">React.js</a>，对于这个东西，我是完全意义上的门外汉。但他一步一步地把React.js的来龙去脉讲得非常清楚，在我脑子里留下了深刻的印象。在未来的技术选型里，如果有相关的场景，我会考虑使用这个项目的。</p>\n<p>其它在脑子中留下印象的东西还有，</p>\n<ul>\n<li>github提出的“干掉”Product Owner，实际上是说全功能团队</li>\n<li>github的Hubot，构建团队自己的“机器人”，把一切尽可能自动化</li>\n<li>豆瓣的CODE，用一个无人管理的项目，打造构建一种工程师文化</li>\n<li>百度的Clouda，快速构建跨终端应用</li>\n<li>阿里的朴灵分享关于Node.js的设计与实现，理清了Node中最基本的几个概念：事件、非阻塞、Watcher等</li>\n<li>腾讯的QZone跨终端应用，用Node.js做代理，把JS模板渲染搬回了服务器</li>\n</ul>\n<p>在QCon期间，还找来了几个自媒体人来“扯淡”：鬼脚七、池建强、蔡学镛、道哥、厉哥，从IT老男人开始讨论，大家弄得很欢乐。遗憾的是，这几位少有还拼搏在第一线的程序员，多多少少给人一些误导，似乎程序员发展方向都不再是程序员了一般。也许矛盾就在于此，能一门心思写程序的，估计没他们几个这么能扯。:)</p>\n<p>最后，感谢一下InfoQ，给了我一个机会，在门票高达几千块钱的情况下，不仅让我没花钱买票，还包吃包住包往返路费的，顺便夹带私货介绍自己的开源项目。如果你也想免费蹭大会，不妨去做个讲师。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201311020657",
    "date": "2013-11-02",
    "time": "06:57",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.9发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/234885339.html\">Moco 0.8.1发布</a></p>\n<p>我很高兴地宣布，<a href=\"https://github.com/dreamhead/moco/tree/v0.9\">Moco 0.9</a>发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p>Moco是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>本次发布包含两个重大的新特性，事件和验证。</p>\n<p>事件指的是，在某种情况下，触发相应的处理。目前支持的事件是“完成”事件，也就是说，当一个请求处理完成时，我们可以做相应的处理。</p>\n<p>比如，我们可以用如下代码在请求处理之后，发出另外一个请求。</p>\n<p>server.request(by(uri(\"/event\"))).response(\"event\").on(complete(get(\"http://another_site\")));</p>\n<p>我们还可以声明这个请求是异步的，这样不会阻塞本次调用给客户端回应答。</p>\n<p>server.request(by(uri(\"/event\"))).response(\"event\").on(complete(async(post(\"http://another_site\", \"content\"), latency(1000))));</p>\n<p>这种情况可以用于诸如OAuth认证之类的情形，在服务器接到一个请求之后，发起另外一个请求。</p>\n<p>它也支持相应的JSON配置：</p>\n<p>{<br>\"request\": {<br> &nbsp; &nbsp;\"uri\" : \"/event\"<br>},</p>\n<p>\"response\": {<br> &nbsp; &nbsp;\"text\": \"event\"<br>},<br>\"on\": {<br> &nbsp; &nbsp;\"complete\": {<br> &nbsp; &nbsp; &nbsp; &nbsp;\"async\" : \"true\",<br> &nbsp; &nbsp; &nbsp; &nbsp;\"latency\" : 1000,<br> &nbsp; &nbsp; &nbsp; &nbsp;\"post\" : {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"url\" : \"http://another_site\",<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"content\": \"content\"<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}<br>}</p>\n<p>验证，是一个用于测试代码中的特性，类似于Mock框架中的verify功能，对请求进行验证。下面是一个例子。</p>\n<p>RequestHit hit = requestHit();<br>final HttpServer server = httpserver(12306, hit);<br>server.get(by(uri(\"/foo\"))).response(\"bar\");</p>\n<p>running(server, new Runnable() {<br> &nbsp;@Override<br> &nbsp;public void run() throws Exception {<br> &nbsp; &nbsp;assertThat(helper.get(remoteUrl(\"/foo\")), is(\"bar\"));<br> &nbsp;}<br>});</p>\n<p>hit.verify(by(uri(\"/foo\")), times(1));</p>\n<p>这里的verify的第一个参数是一个matcher，也就是说，我们可以写任意的条件组合，甚至与设置服务器的完全不同。</p>\n<p>此外，我们还支持未预期请求的验证，如下：</p>\n<p>hit.verify(unexpected(), never());</p>\n<p>目前支持的验证条件包括：</p>\n<ul>\n<li>never： 没有收到这样的请求。</li>\n<li>time： 准确匹配收到这些次数的请求。</li>\n<li>atLeast：至少收到这些次数的请求。</li>\n<li>atMost：至多收到这些次数的请求。</li>\n</ul>\n<p>此外，还有一些小特性的变更：</p>\n<ul>\n<li>缺省情况下，关闭了使用API方式的日志。</li>\n<li>seq API支持了ResponseHandler接口。</li>\n<li>为PUT和DELETE方法增加了快捷方式。</li>\n</ul>\n<p>在内部实现细节上也有一些微调：</p>\n<ul>\n<li>如果不提供端口，服务器会自行选择可用端口。</li>\n<li>在Failover的实现里，“statusCode”改成了“status”。如果因此造成了测试失败，可以手工修改Failover文件。</li>\n</ul>\n<p><strong>感谢</strong></p>\n<p>感谢<a href=\"https://github.com/paul-hammant\">Paul Hammant</a>，为Moco提供了大量的反馈，并激发了验证特性实现的灵感。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201310182135",
    "date": "2013-10-18",
    "time": "21:35",
    "tags": [
      "Moco"
    ],
    "title": "Moco，一岁了！",
    "body": "<p>一年前的今天，我在github开启了一个新的小项目，为的是解决自己在日常开发中遇到的集成问题，它叫<a href=\"https://github.com/dreamhead/moco\">Moco</a>。</p>\n<p>一年后的今天，Moco一岁了！</p>\n<p>下面是一些Moco在这一年里的成果：</p>\n<ul>\n<li>发布了3个版本，从2013年5月1日发布0.7开始。</li>\n<li>有了524次提交，10个贡献者，42个Issue。</li>\n<li>在github上有了199个star。</li>\n<li>从2013年2月17日开始，迄今已经有连续243天的提交。</li>\n<li>分别有人写了Maven和Gradle插件</li>\n<li>有人给Moco写了Scala绑定</li>\n</ul>\n<p>更荣幸的是，在这一年里，Moco</p>\n<ul>\n<li>夺得了ThoughtWorks中国区第二届技术大赛最具技术创新奖。</li>\n<li>荣获2013年Duke选择奖。</li>\n</ul>\n<p>这一年里，Moco得到了更多的关注：</p>\n<ul>\n<li>越来越多的人把Moco用在了自己的项目上，于是，我得到了更多的反馈。</li>\n<li>越来越多的人开始关注Moco，许多网站报道了Moco，它还登上《Java Magazine》。</li>\n</ul>\n<p>启动Moco之时，我没想过这个项目可以走多长时间。一年后，Moco路越走越宽。</p>\n<p>Moco，继续前进！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201310022129",
    "date": "2013-10-02",
    "time": "21:29",
    "tags": [
      "你应该更新的Java知识",
      "Java",
      "Guava",
      "不变集合"
    ],
    "title": "你应该更新的Java知识之不变集合",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/226738702.html\">你应该更新的Java知识之常用程序库（一）<br></a><a href=\"http://dreamhead.blogbus.com/logs/226738756.html\">你应该更新的Java知识之常用程序库（二）<br></a><a href=\"http://dreamhead.blogbus.com/logs/227427912.html\">你应该更新的Java知识之构建工具<br></a><a href=\"http://dreamhead.blogbus.com/logs/231594181.html\">你应该更新的Java知识之Observer<br></a><a href=\"http://dreamhead.blogbus.com/logs/232899025.html\">你应该更新的Java知识之集合初始化<br></a><a href=\"http://dreamhead.blogbus.com/logs/234113759.html\">你应该更新的Java知识之集合操作<br></a><a href=\"http://dreamhead.blogbus.com/logs/234741366.html\">你应该更新的Java知识之惰性求值<br></a><a href=\"http://www.blogbus.com/logs/235329092.html\">你应该更新的Java知识之Optional<br></a><a href=\"http://dreamhead.blogbus.com/logs/235334714.html\">你应该更新的Java知识之Optional高级用法<br></a></p>\n<p>在传统的Java里，为了表示一个集合，我们常常会写出这样的代码：</p>\n<p>public class People {<br>&nbsp; &nbsp; private List people;</p>\n<p>&nbsp; &nbsp; public void setPeople(List people) {<br>&nbsp; &nbsp; &nbsp; &nbsp; this.people = people;<br>&nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; public List getPeople() {<br> &nbsp; &nbsp; &nbsp; &nbsp;return this.people;<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; &nbsp;...<br>}</p>\n<p>&nbsp;严格说来，这样的代码存在缺陷。虽然貌似List被封装到People里，但实际上，这个List的引用却暴露在外面，这个类的用户可以轻松地拿到List的引用，随意修改。所以，下面是一种更严谨的写法：</p>\n<p>public class People {<br>&nbsp; &nbsp; private List people;</p>\n<p>&nbsp; &nbsp; public void setPeople(List people) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.people.addAll(people);<br>&nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; @SuppressWarnings(\"unchecked\")<br>&nbsp; &nbsp; public List getPeople() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return (List)this.people.clone();<br>&nbsp; &nbsp; }&nbsp;</p>\n<p>&nbsp; &nbsp; ...<br>}</p>\n<p>&nbsp;这里的做法基本思路是，做一个副本，保证内部引用（这里的people）不会传播到外面。但在实际编写代码的时候，大多数人都不会这么做，能否意识到这样的问题只是一个方面，这样的代码写起来，也要比原来的那种写法麻烦得多。按照许多公司的做法，这种要求只能放到代码规范里，但无论如何，在程序世界里，人为规定永远是最容易忽略的约定。</p>\n<p>&nbsp;不过，在真实世界中，即便是我们写的只是上面的最简单那种形式，却很少出现问题。原因何在呢？因为大多数情况下，我们编写这样程序的时候，会有一种隐形的约定，这个“List”是不变的。我们设置（set）完这个List之后，基本上不会留着它的引用在做任何操作；而得到（get）它之后，也基本上不会去修改它。</p>\n<p>&nbsp;在这种情况下，我们使用的实际上是一个不变的List。既然是一个不变的List，那不如就更直接地把它表现出来。</p>\n<p>&nbsp;Guava为我们提供了不变集合的概念，对应着各种具体类型，有ImmutableList、ImmutableSet，还有ImmutableMap。从名字上，我们不难看出它们的用法。</p>\n<p>&nbsp;Guava不变集合的做法并不是另起炉灶，而是遵循了Java已有集合框架的约定。比如，通过查阅文档，我们不难发现，ImmutableList就是一个List，只不过使用这个“List”，只不过，当我们尝试调用诸如add、set之类试图修改集合的方法时，它会抛出异常。正是有了这样的基础，不变集合可以和很多已有的类库、框架配合在一起。</p>\n<p>&nbsp;有了这个基础，我们把不变集合的概念应用于之前的代码，它就是下面这个样子：</p>\n<p>public class People {<br>&nbsp; &nbsp; private ImmutableList people;</p>\n<p>&nbsp; &nbsp; public void setPeople(ImmutableList people) {<br>&nbsp; &nbsp; &nbsp; &nbsp; this.people = people;<br>&nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; public ImmutableList getPeople() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return this.people;<br>&nbsp; &nbsp; }&nbsp;</p>\n<p>&nbsp; &nbsp; ...<br>}</p>\n<p>这样一来，代码依然很简单，但是，意义却与从前完全不一样了。我们不必再为可能存在的隐忧顾虑了：一旦元素放到集合里，就不可能修改它了，因为它是不可变的。</p>\n<p>对于使用这段代码的人来说，getter自不必说，如往常一样使用，setter也不费力。只是当做字面量使用的集合，我们已经在《<a href=\"http://dreamhead.blogbus.com/logs/232899025.html\">你应该更新的Java知识之集合初始化</a>》中讨论过了。如果要适配于现有程序库，把一个已有的List转成ImmutableList也不复杂，一个简单的copyOf方法就可以实现：</p>\n<p>&nbsp; &nbsp; List existingPeople = ... <br>&nbsp; &nbsp; ImmutableList immutablePeople = copyOf(existingPeople);</p>\n<p>为了让讨论更完整，这里不得不提到另外一个不变接口的选择：Iterable。它是从Java 5开始进入JDK的一个接口：</p>\n<p>public interface Iterable &nbsp;{<br>&nbsp; &nbsp; Iterator iterator();<br>}</p>\n<p>作为一个Java程序员，我们对Iterator简直再熟悉不过了，有了Iterator，我们就可以遍历一个集合。所以，在一些情况下，我们也可以使用Iterable表示一个不变集合。大多数Java已有的集合类都实现了这个接口。</p>\n<p>既然它是JDK里的东西，为什么不把它优先推荐呢？原因有几个。最重要的一个原因在于我们熟知的Iterator，它有一个方法叫做remove，可能大多数Java程序员已经习惯性地忽略了这个方法，但它就在哪里，它是一个可以“改变”集合的方法，所以，从语义上说，它不是一个很好的选择。另外，从已有的代码习惯来说，很多程序员还是很喜欢用List、Set作为接口，所以，ImmutableList从心理上来说，更接近已有的习惯。剩下的一个点似乎不那么重要，有些代码真的需要使用到特定类型的接口。不过，就大多数代码而言，我们只是要得到的一个集合，做一些操作，而这些操作我们在《<a href=\"http://dreamhead.blogbus.com/logs/234113759.html\">你应该更新的Java知识之集合操作</a>》中做了一些讨论。</p>\n<p>在函数式编程中，不变是提升程序稳定性一个很重要的概念。既然我们大多数情况下实际用到的是不变集合，那就不妨直接把它表现出来。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201309220754",
    "date": "2013-09-22",
    "time": "07:54",
    "tags": [
      "个人成长"
    ],
    "title": "打开视野",
    "body": "<p>在ThoughtWorks里，我面试过许多应聘者，许多人在原来公司都是公司里的干将、主力。按说，也都算是很优秀的程序员了，不过，在面试过程中，折戟沉沙的也不在少数。</p>\n<p>这样的面试者往往是工作时间不长，大约是三五年，在小问题的解决上具备了一定能力，但没有什么机会面对大问题，所以，基本上都是在处理别人嚼碎的具体问题。所以，这样的求职者在面试过程中所展现的能力，以ThoughtWorker的标准看，编程技巧上没有多么突出，陈述问题显得零散而没有重点，至于宏观问题的思考，几乎是没有的。</p>\n<p>其实，这不是一个偶然现象，我已经见到不知多少类似的求职者。通过和他们的交流，我会发现，实际上，这些人往往不是不想提高，甚至他们都是非常努力地在工作。只是在我看来，他们所处的环境限制了他们的视野，一叶障目，不见泰山。在工作中，项目负责人给他们的工作就是解决一个具体问题，至于真正有思考的问题，那些负责人自己已经解决了。</p>\n<p>这样的求职者以目前展现的能力，可能不足以让他们成为一个ThoughtWorker，但还是有不少求职者在这个过程中认识到自己的差距，主动寻求一些建议。而本着好为人师的态度，遇到这样有心成长的求职者，我也会给他们一些建议。</p>\n<p>对于一个人的成长来说，视野很重要。如果只看到周边的这些人，往往会有一种错觉，我已经做得很好了，而这种“很好”只不过是一个局部峰值，有时，这个局部峰值只是一个很低的标准。我们只有把自己放在一个更大的平台上，才会对自己的定位有个更清晰的评判。</p>\n<p>如今已经不是那个“铁饭碗”抱到老的年代了，我们也不指望为一直在一个公司工作。所以，我们也不应该把一家公司的衡量标准作为自己的奋斗目标。我们是用能力在这个业界生存，我们的目标至少也应该是以业界的标准来看。</p>\n<p>很多人往往倾向于从周边的人学习，但当周边的人不能给我们更好的帮助时，我就需要寻找更好的成长途径。很幸运，程序员这个群体是最容易拓展视野的群体。我们几乎每天都在和互联网打交道，在上面我们可以见识到更大的天地，见识到更多高水平的人。我们可以明里暗里地向这些人学习，学习的不仅仅是他们的能力，更重要的是，他们的思考方式。</p>\n<p>读书，对于程序员来说，也是一种开拓视野的重要方式。基本上，能记录到书里的内容都是作者的深入思考，而且，相比于网上零散的内容，书上的知识会更系统。这是很好地向业界领先或成熟的思想直接学习的机会。当然，这里说的是那些值得看的经典图书。至少从我自己的了解上看，网上给程序员推荐书的帖子已不胜枚举。</p>\n<p>对于程序员来说，另外一个开阔视野的方式是，走出去，参加一些程序员的聚会。无论是北京、上海，还是西安、成都，这几个我常驻过的城市都有很好的程序员社区。每年还有各种各样的技术大会在不同的地方召开。在那里，我们会看到许多不同的程序员，知道他们在做着各种各样有意思的事情，还会接触到许多经验丰富的程序员，他们一定对个人成长有着自己的思考。参加这种聚会，与人的沟通，我们不需要付出任何代价，成本几乎为0。</p>\n<p>至于学什么，怎么学，那都是视野打开之后的事情了，固步自封是最可怕的事情。</p>\n<p>最后是我自己的成长小故事。记得当年我在东软的时候，我给自己的一个评价是自己写程序的能力处于“过饱和”状态，因为我的工作不需要我把程序写得那么好。如果我按照周边人的标准评判自己，我已经发展到非常不错的水平，似乎已经有了足够的理由固步自封。很幸运，我没有。在沈阳，没有很好的程序员圈子，我除了和身边几个高手接触外，更多的是在网上如饥似渴地看着各种各样的东西。</p>\n<p>当东软无法满足我的求知欲时，我就开始寻找下一个能帮助自己进一步提升的地方，很幸运的是，我找到了ThoughtWorks。在这里，我每年都能不断地看到新东西，学习新东西。所以，我从未停下过。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201309110724",
    "date": "2013-09-11",
    "time": "07:24",
    "tags": [
      "akka"
    ],
    "title": "Hello，Akka",
    "body": "<p>只要稍微了解过一些<a href=\"http://scala-lang.org/\">Scala</a>，这门JVM上广受关注的程序设计语言，你一定会对其中的一个Actor特性印象深刻。<a href=\"http://en.wikipedia.org/wiki/Actor_model\">Actor</a>是另一种进行并发计算的方式。通过在不同的Actor之间彼此发送消息，我们会惊喜地发现，那令人纠结的锁将不再困扰我们。</p>\n<p>不过，那是Scala的世界，作为一个Java程序员难道只有艳羡的份吗？显然不是。<a href=\"http://akka.io/\">Akka</a>把Actor带到了Java世界。</p>\n<p>实际上，Akka主要是以Scala编写的，但它很好地支持Java API，让所有特性对于Java程序员也唾手可得。即使相比于与Scala内建的Actor，Akka也不遑多让。Akka除了最基本的Actor特性外，它可以能在多台机器上透明地实现Actor，此外，还提供了很好的监管特性，这些都是Scala内建的Actor所不具备的。</p>\n<p>说了那么多，让我们用一个Hello的例子和Akka打个招呼吧！</p>\n<p>既然我们这里关注的是Actor，我们就来实现两个Actor，让它们之间实现问候。下面是一个：</p>\n<p>import akka.actor.Props;<br>import akka.actor.UntypedActor;<br>import akka.actor.ActorRef;</p>\n<p>public class HelloWorld extends UntypedActor {</p>\n<p>&nbsp; &nbsp; @Override<br> &nbsp; &nbsp;public void preStart() {<br> &nbsp; &nbsp; &nbsp; &nbsp;final ActorRef greeter =<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getContext().actorOf(Props.create(Greeter.class), \"greeter\");<br> &nbsp; &nbsp; &nbsp; &nbsp;greeter.tell(Greeter.Msg.GREET, getSelf());<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; @Override<br> &nbsp; &nbsp;public void onReceive(Object msg) {<br> &nbsp; &nbsp; &nbsp; &nbsp;if (msg == Greeter.Msg.DONE) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getContext().stop(getSelf());<br> &nbsp; &nbsp; &nbsp; &nbsp;} else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unhandled(msg);<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; }<br>}<br>（HelloWorld.java）</p>\n<p>这个HelloWorld继承了UntypedActor，表明我们实现的是一个Actor。</p>\n<p>其中的preStart是在启动这个Actor时调用的方法。在这里，我们创建了另一个Actor的实例。我们稍后会看到另一个Actor Greeter的实现。然后，我们调用tell方法给它发了一个消息，Greeter.Msg.GREET，后面的getSelf()给出了一个Actor的引用（ActorRef），用以表示发消息的Actor。这只是启动一个Actor，后面的部分才是更重要的。</p>\n<p>onReceive方法是处理我们接收到消息的情况。这里我们看到，如果接收到的消息是一个Greeter.Msg.DONE，我们就会停下（stop）所有的处理，同样，getSelf()指明停下的目标，否则的话，就说我们没处理（unhandled）。</p>\n<p>看完了一个Actor，或许你已经迫不及待地想看与它打交道的另一个Actor了，下面就是：</p>\n<p>import akka.actor.UntypedActor;</p>\n<p>public class Greeter extends UntypedActor {</p>\n<p>&nbsp; &nbsp; public static enum Msg {<br> &nbsp; &nbsp; &nbsp; &nbsp;GREET, DONE<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; @Override<br> &nbsp; &nbsp;public void onReceive(Object msg) {<br> &nbsp; &nbsp; &nbsp; &nbsp;if (msg == Msg.GREET) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(\"Hello World!\");<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getSender().tell(Msg.DONE, getSelf());<br> &nbsp; &nbsp; &nbsp; &nbsp;} else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unhandled(msg);<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}<br>（Greeter.java）</p>\n<p>同样的Actor结构，我们已经在HelloWorld类里面看到了。在onReceive方法里，如果它接收到的消息是Msg.GREET，它就打印出“Hello World!”，然后，给发送者回复一条Msg.DONE。没处理的话，就说没处理。</p>\n<p>就是这么简单！</p>\n<p>好，万事具备，我们把它跑起来。你看到了我们还没有入口点，实际上，Akka自身为我们提供了一个。设置好classpath之后，我们只要这样运行即可：</p>\n<p>&nbsp; &nbsp; java akka.Main HelloWorld</p>\n<p>这里的akka.Main就是我们的入口点，我们把HelloWorld这个类名传给它作为启动参数。运行的结果自然是我们最熟悉的：</p>\n<p>&nbsp; &nbsp; Hello World!</p>\n<p>好，就到这里吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201309091857",
    "date": "2013-09-09",
    "time": "18:57",
    "tags": [
      "dropwizard"
    ],
    "title": "Hello，Dropwizard",
    "body": "<p><a href=\"http://dropwizard.codahale.com/\">Dropwizard</a>是Java世界里给人带来新思维的一个框架，它在主页上如是说：</p>\n<p>Dropwizard is a Java framework for developing ops-friendly, high-performance, RESTful web services.</p>\n<p>这句话不足以概括Dropwizard的新思维，在我看来，Dropwizard的新，在于它把轻量级的开发/部署的概念带回了Java世界。我们用个最简单的例子来体验一下Dropwizard。</p>\n<p>首先要声明一点的是，Dropwizard集成了众多开源框架，所以，这里看到的许多API并不是Dropwizard本身的API。</p>\n<p>因为Dropwizard侧重点在于服务，所以，我们来开发一个打招呼的服务。你已经看到了这里它的长项是RESTful的服务，所以，我们先写一个Resource：</p>\n<p>import com.google.common.base.Optional;</p>\n<p>import javax.ws.rs.GET;<br>import javax.ws.rs.Path;<br>import javax.ws.rs.Produces;<br>import javax.ws.rs.QueryParam;<br>import javax.ws.rs.core.MediaType;</p>\n<p>@Path(\"/consent\")<br>@Produces(MediaType.APPLICATION_JSON)<br>public class HelloResource {<br> &nbsp; @GET<br> &nbsp; public HelloResult sayHello(@QueryParam(\"name\") Optional name) {<br> &nbsp; &nbsp; &nbsp; return new HelloResult(String.format(\"Hello, %s\", name.or(\"Stranger\")));<br> &nbsp; }<br>}<br>（HelloResource.java）</p>\n<p>Dropwizard里用来做RESTFul服务的框架是<a href=\"http://jersey.java.net/\">Jersey</a>，所以，可以参考Jersey的文档来更好地理解这里的代码。不过，这段代码本身很简单，定义了一个Resource，其中的sayHello是一个GET请求，用来和人打招呼。另外，你看到了这里用到了<a href=\"http://dreamhead.blogbus.com/logs/235329092.html\">Optional</a>。</p>\n<p>HelloResult是一个服务与客户端交互的对象，正如我们服务中所定义的，它会产生一个JSON对象，这个转换是由<a href=\"https://github.com/FasterXML/jackson\">Jackson</a>完成的。下面是HelloResult类的实现。</p>\n<p>public class HelloResult {</p>\n<p>&nbsp; &nbsp; private String result;</p>\n<p>&nbsp; &nbsp; public HelloResult(String result) {<br> &nbsp; &nbsp; &nbsp; &nbsp;this.result = result;<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; public String getResult() {<br> &nbsp; &nbsp; &nbsp; &nbsp;return result;<br> &nbsp; &nbsp;}<br>}<br>（HelloResult.java）</p>\n<p>好了，最基础的东西有了，我们可以把它们连在一起，运行起来。还记得你上次写main函数是什么时候吗？</p>\n<p>import com.yammer.dropwizard.Service;<br>import com.yammer.dropwizard.config.Bootstrap;<br>import com.yammer.dropwizard.config.Configuration;<br>import com.yammer.dropwizard.config.Environment;</p>\n<p>public class HelloMain extends Service {<br> &nbsp; &nbsp;public static void main(String[] args) throws Exception {<br> &nbsp; &nbsp; &nbsp; &nbsp;new HelloMain().run(args);<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; @Override<br> &nbsp; &nbsp;public void initialize(Bootstrap bootstrap) {<br> &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; @Override<br> &nbsp; &nbsp;public void run(Configuration configuration, Environment environment) throws Exception {<br> &nbsp; &nbsp; &nbsp; &nbsp;environment.addResource(new HelloResource());<br> &nbsp; &nbsp;}<br>}</p>\n<p>简单吧？这里我们就继承了一个Service，然后，在run方法里把我们的Resource添加到环境里，最后，在main函数里启动起来。</p>\n<p>有了main函数，我们就可以直接把它运行起来，不过，这里是要有参数的：server，指定程序按照server的方式运行。</p>\n<p>好了，我们看到程序启动起来了，虽然我们本身什么都没做，实际上，Dropwizard却利用Jetty帮我们把服务加载起来了。剩下的就是打开浏览器，输入</p>\n<p>&nbsp; http://localhost:8080/hello</p>\n<p>你会看到</p>\n<p>&nbsp; {\"result\":\"Hello, Stranger\"}</p>\n<p>我们几乎没做什么，但JSON已经产生了。它还不认识我们，我们需要一个自我介绍，输入</p>\n<p>&nbsp; http://localhost:8080/hello?name=dreamhead</p>\n<p>你会看到</p>\n<p>&nbsp; {\"result\":\"Hello, dreamhead\"}</p>\n<p>好，一个最简单的RESTful服务已经开发完毕。如果你是一个传统Java应用的开发者，回想一下，按照原有的工作方式，开发这样一个服务需要怎样的工作量。别的不说，搭建一个Web服务器，配置web.xml，半天就没了，而我们分分钟就可以启动一个服务，这是怎样的效率提升啊！</p>\n<p>作为一个Hello的例子，本篇的目标已经达成，就到这里吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201308220909",
    "date": "2013-08-22",
    "time": "09:09",
    "tags": [
      "你应该更新的Java知识",
      "Java",
      "Guava",
      "Null",
      "Optional",
      "Maybe_Monad"
    ],
    "title": "你应该更新的Java知识之Optional高级用法",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/226738702.html\">你应该更新的Java知识之常用程序库（一）<br></a><a href=\"http://dreamhead.blogbus.com/logs/226738756.html\">你应该更新的Java知识之常用程序库（二）<br></a><a href=\"http://dreamhead.blogbus.com/logs/227427912.html\">你应该更新的Java知识之构建工具<br></a><a href=\"http://dreamhead.blogbus.com/logs/231594181.html\">你应该更新的Java知识之Observer<br></a><a href=\"http://dreamhead.blogbus.com/logs/232899025.html\">你应该更新的Java知识之集合初始化<br></a><a href=\"http://dreamhead.blogbus.com/logs/234113759.html\">你应该更新的Java知识之集合操作<br></a><a href=\"http://dreamhead.blogbus.com/logs/234741366.html\">你应该更新的Java知识之惰性求值<br></a><a href=\"http://www.blogbus.com/logs/235329092.html\">你应该更新的Java知识之Optional</a></p>\n<p>介绍了<a href=\"http://www.blogbus.com/logs/235329092.html\">Optinal的基本用法</a>，我们来看一个有趣的例子，找到一个人的出生国家。按照传统的思路，代码大约是这个样子：</p>\n<p>Place place = person.getPlaceOfBirth();<br>if (place != null) {<br>&nbsp;City city = place.getCity();<br>&nbsp;if (city != null) {<br>&nbsp; &nbsp;Province province = city.getProvince();<br>&nbsp; &nbsp;if (province != null) {<br>&nbsp; &nbsp; &nbsp;return province.getCountry();<br>&nbsp; &nbsp;}<br>&nbsp;}<br>}</p>\n<p>return null;</p>\n<p>如果你对整洁代码稍有追求，这样的if套if都会让你觉得不爽。让我们尝试用Optional改造它，不过，事先声明一下，以下代码并不在Guava代码库里，而是自行的扩展，也是弥补Guava Optional的缺失，你可以把下面的代码添加到你自己的程序库中，作为基础代码：</p>\n<p>首先，我们要给Optionals添加一个方法：</p>\n<p>public class Optionals {<br>&nbsp; &nbsp;public static &lt;T, U&gt; Optional&nbsp;bind(Optional value,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Function&lt;T, Optional&gt; function) {<br>&nbsp; &nbsp; &nbsp;if (value.isPresent()) {<br>&nbsp; &nbsp; &nbsp; return function.apply(value.get());<br>&nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; return absent();<br>&nbsp; }<br>}<br>（参见<a href=\"https://github.com/dreamhead/jfun/blob/master/src/main/java/com/github/dreamhead/jfun/optional/Optionals.java\">具体代码</a>）</p>\n<p>这个方法的意图是，对一个Optional值（value）执行一个操作（function），如果value不是空，则对value执行操作，否则，返回空。</p>\n<p>如果单纯从这个函数，你还不是很清楚它到底能做些什么，那我们就直接来看代码：</p>\n<p>bind(<br>&nbsp;bind(<br>&nbsp; &nbsp;bind(<br>&nbsp; &nbsp; &nbsp;bind(personOptional, getPlaceOfBirth()), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp;getCityFromPlace()),<br>&nbsp; &nbsp;getProvinceFromCity()),<br>&nbsp;getCountryFromProvince());</p>\n<p>我们连着用了几个bind连Person对象里一层一层地往外找我们所需的值，如你所料，这里的每个函数实际上都是一个函数对象，我们就以其中的一个演示一下基本的做法：</p>\n<p>Function&lt;Province, Optional&gt; getCountryFromProvince() {<br>&nbsp;return new Function&lt;Province, Optional&gt;() {<br>&nbsp; &nbsp;@Override<br>&nbsp; &nbsp;public Optional apply(Province input) {<br>&nbsp; &nbsp; &nbsp;return fromNullable(input.getCountry());<br>&nbsp; &nbsp;}<br>&nbsp;};<br>}</p>\n<p>把所有这些放在一起你就应该理解了，在这中间执行的任何一个环节如果出现空值，那么整个的返回值就是一个空值，否则，它就会一层一层的执行下去。</p>\n<p>这样一来，如果我们把bind函数视为程序库里的函数，那我们的客户端代码里面，一个if都没有出现，我们成功地消除那一大堆的if嵌套。</p>\n<p>不过，这种括号套括号的用法颇有Lisp风味，作为一个Java程序员，我们对于这样的写法还着实需要适应一下。让我们再进一步探索一下，看看怎么能把它做得更Java一些。</p>\n<p>public class FluentOptional {<br>&nbsp; &nbsp;private Optional optional;</p>\n<p>&nbsp; &nbsp;private FluentOptional(Optional optional) {<br>&nbsp; &nbsp; &nbsp;this.optional = optional;<br>&nbsp; }</p>\n<p>&nbsp; public static FluentOptional from(Optional optional) {<br>&nbsp; &nbsp; &nbsp;return new FluentOptional(optional);<br>&nbsp;}</p>\n<p>&nbsp; public&nbsp;FluentOptional&nbsp;bind(Function&lt;T, Optional&gt; function) {<br>&nbsp; &nbsp; &nbsp;if (isPresent()) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return from(function.apply(get()));<br>&nbsp; &nbsp; &nbsp;}</p>\n<p>&nbsp; &nbsp; &nbsp; return from(Optional.absent());<br>&nbsp;}</p>\n<p>&nbsp; ...</p>\n<p>（参见<a href=\"https://github.com/dreamhead/jfun/blob/master/src/main/java/com/github/dreamhead/jfun/optional/FluentOptional.java\">具体代码</a>）</p>\n<p>通过这段代码，我们可以用FluentOptional提供一个对Optional类的封装，这里面我们新增了两个方法from和bind，其它方法都是可以由Optional提供，实现很容易，这里省略了。我们看看通过这个新实现，我们的方法变成了什么模样：</p>\n<p>from(personOptional)<br>&nbsp; .bind(getPlace())<br>&nbsp; .bind(getCityFromPlace())<br>&nbsp; .bind(getProvinceFromCity())<br>&nbsp; .bind(getCountryFromProvince());</p>\n<p>怎么样，如此一来，代码就就像Java代码了吧！</p>\n<p>实际上，这种做法也是来自一种函数式编程的理念：Maybe Monad，这是Haskell程序设计语言为探索纯函数式编程所做的努力之一，这里就不做过多的介绍了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201308210710",
    "date": "2013-08-21",
    "time": "07:10",
    "tags": [
      "你应该更新的Java知识",
      "Java",
      "Guava",
      "Null",
      "Optional"
    ],
    "title": "你应该更新的Java知识之Optional",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/226738702.html\">你应该更新的Java知识之常用程序库（一）<br></a><a href=\"http://dreamhead.blogbus.com/logs/226738756.html\">你应该更新的Java知识之常用程序库（二）<br></a><a href=\"http://dreamhead.blogbus.com/logs/227427912.html\">你应该更新的Java知识之构建工具<br></a><a href=\"http://dreamhead.blogbus.com/logs/231594181.html\">你应该更新的Java知识之Observer<br></a><a href=\"http://dreamhead.blogbus.com/logs/232899025.html\">你应该更新的Java知识之集合初始化<br></a><a href=\"http://dreamhead.blogbus.com/logs/234113759.html\">你应该更新的Java知识之集合操作<br></a><a href=\"http://dreamhead.blogbus.com/logs/234741366.html\">你应该更新的Java知识之惰性求值</a></p>\n<p>java.lang.NullPointerException，只要敢自称Java程序员，那对这个异常就再熟悉不过了。为了防止抛出这个异常，我们经常会写出这样的代码：</p>\n<p>Person person = people.find(\"John Smith\");<br>if (person != null) {<br> &nbsp;person.doSomething();<br>}</p>\n<p>遗憾的是，在绝大多数Java代码里，我们常常忘记了判断空引用，所以，NullPointerException便也随之而来了。</p>\n<p>“Null Sucks.”，这就是Doug Lea对空的评价。作为一个Java程序员，如果你还不知道<a href=\"http://g.oswego.edu/\">Doug Lea</a>是谁，那赶紧补课，没有他的贡献，我们还只能用着Java最原始的装备处理多线程。</p>\n<p>\"I call it my billion-dollar mistake.\"，有资格说这话是空引用的发明者，<a href=\"http://en.wikipedia.org/wiki/Tony_Hoare\">Sir C. A. R. Hoare</a>。你可以不知道Doug Lea，但你一定要知道这位老人家，否则，你便没资格使用快速排序。</p>\n<p>在Java世界里，解决空引用问题常见的一种办法是，使用Null Object模式。这样的话，在“没有什么”的情况下，就返回Null Object，客户端代码就不用判断是否为空了。但是，这种做法也有一些问题。首先，我们肯定要为Null Object编写代码，而且，如果我们想大规模应用这个模式，我们要为几乎每个类编写Null Object。</p>\n<p>幸好，我们还有另外一种选择：Optional。Optional是对可以为空的对象进行的封装，它实现起来并不复杂。在某些语言里，比如Scala，Optional实现成了语言的一部分。而对于Java程序员而言，Guava为我们提供了Optional的支持。闲言少叙，先来如何使用Optional，完成前面的那段代码。</p>\n<p>Optional person = people.find(\"John Smith\");<br>if (person.isPresent()) {<br> &nbsp;person.get().doSomething();<br>}</p>\n<p>这里如果isPresent()返回false，说明这是个空对象，否则，我们就可以把其中的内容取出来做自己想做的操作了。</p>\n<p>如果你期待的是代码量的减少，恐怕这里要让你失望了。单从代码量上来说，Optional甚至比原来的代码还多。但好处在于，你绝对不会忘记判空，因为这里我们得到的不是Person类的对象，而是Optional。</p>\n<p>看完了客户端代码，我们再来看看怎样创建一个Optional对象，基本的规则很简单：</p>\n<p>如果我们知道自己要封装的对象是一个空对象，可以用<br> &nbsp;Optional.absent();</p>\n<p>如果封装的对象是一个非空对象，则可以用<br> &nbsp;Optional.of(obj);</p>\n<p>如果不知道对象是否为空，就这样创建创建<br> &nbsp;Optional.fromNullable(obj);</p>\n<p>有时候，当一个对象为null的时候，我们并不是简单的忽略，而是给出一个缺省值，比如找不到这个人，任务就交给经理来做。使用Optional可以很容易地做到这一点，以上面的代码为例：</p>\n<p>&nbsp; Optional person = people.find(\"John Smith\");<br>&nbsp; person.or(manager).doSomething()</p>\n<p>说白了，Optinal是给了我们一个更有意义的“空”。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201308120706",
    "date": "2013-08-12",
    "time": "07:06",
    "tags": [
      "读书"
    ],
    "title": "2013年读书计划，达成！",
    "body": "<p><a href=\"http://gigix.thoughtworkers.org/\">gigix</a>总喊着<a href=\"http://gigix.thoughtworkers.org/2011/9/20/read-50-books-per-year\">一年50本书</a>，和这样的人工作在一起，自然很有压力。我也号称喜欢读书，回头查了一下自己的豆瓣，一年不过十来本。其实，我也好奇，一年怎么能读那么多的书。2012年底，我就给自己制定了一个新年读书计划：30本。这个数没有那么多，我是不想步子迈得太大。</p>\n<p>2013年8月11日，年度30本的计划达成。</p>\n<p>曾经，觉得读那么多书不可能，现在看来，只是没有抓紧时间读书而已。很多人以为读书都是要拿出大把时间正襟危坐地细细品味，所以，抱怨自己没有时间、没有地点、没有合适的方式读书。其实，根本没那么多要求，闲暇时，抓起本书读就好了。我知道，有很多同事朋友是在利用上下班时间公交地铁时间在读书。</p>\n<p>现在下班之后，我基本上已经不开电脑，陪着家人聊天散步就是我如今的生活。有时，趁着家人忙碌的空隙，我就随手抽出一本书来读。周末也一样，有时甚至是一家人各捧一本书在读。家里领导也盘点了一下，今年似乎也读了十几本书。出差是ThoughtWorker生涯中无可规避的事情，随身带几本书，利用飞机时间来读书是一个不错的选择，毕竟一趟飞机，少则一个多小时。现在有了Kindle，不用随身带那么多书，轻了很多。顺便说一下，在亚马逊商店买书很方便，价格也大多很便宜。</p>\n<p>程序员的直觉是，程序员读书就要读技术书。哪来的规定？我今年读完的书里，技术书还真不多。混迹了程序世界十几年，现在对技术书的选择其实比以前更加挑剔了，大多数技术书我只是当做参考资料翻翻，这样的书，我基本上不会说自己读了。少有一些书，才会从头读到尾。我承认，技术书很难很快读完，消化是需要时间的。比如，现在在读的《<a href=\"http://book.douban.com/subject/10484692/\">Java并发编程实战</a>》，前前后后已经读了几个月，但真正读完，估计还要有好长一段时间。</p>\n<p>由于去年读《三体》的原因，开始迷恋上科幻小说。于是，从去年到现在，开始找一些科幻小说来说，比如基地系列，甚至找来凡尔纳的老科幻来回味，也因此对科普作品感了兴趣，读读《上帝掷骰子吗 : 量子物理史话》、《时间的形状》，现在在读的《外星人防御计划》也是如此。曾经我很好奇，很多国外的程序设计书里，为什么常常有一些科幻的引用。读了这些书，可以更好地理解这些程序员，科幻和程序设计都是需要一定想象力的。</p>\n<p>对于想持续发展的程序员来说，适当的休息是不可或缺的。其实，对于我们每天把大把时间奉献给程序的人来说，读读书实际上也是一种休息，换换脑子。当然，你如果需要，这里面是有科学根据的。</p>\n<p>2013年时间将近过了2/3，时间还有，读书是个好习惯。最后是<a href=\"http://www.douban.com/people/dreamhead/\">我的豆瓣</a>。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201308012114",
    "date": "2013-08-01",
    "time": "21:14",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.8.1发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/234825717.html\">Moco 0.8发布</a></p>\n<p>我很高兴地宣布，<a href=\"https://github.com/dreamhead/moco\">Moco</a> <a href=\"https://github.com/dreamhead/moco/tree/v0.8.1\">0.8.1</a>发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p>Moco是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>变更</strong></p>\n<p>这次是一个小的版本发布，没有特性上的任何变更。</p>\n<p>本次发布主要是修复了一个Proxy实现中的一个bug：如果客户端发起的请求中包含了Host这个Header，转发到某些服务器会造成这些服务器无法返回正确的结果。</p>\n<p>除此之外，一个重大的调整是把底层实现由Netty 3换成了Netty 4。</p>\n<p>Netty 3到Netty 4是一个非常大的版本升级，几乎所有API都做了调整。这样的升级带来了更流畅的API，更好的性能，更好的模块划分。</p>\n<p><strong>感谢</strong></p>\n<p>感谢<a href=\"https://github.com/goghvanmr\">李毅</a>，发现并修复了Proxy实现中的bug。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201307301320",
    "date": "2013-07-30",
    "time": "13:20",
    "tags": [
      "JavaONE"
    ],
    "title": "JavaONE上海流水账",
    "body": "<p><span style=\"line-height: normal;\">感谢Moco，我有机会作为<a href=\"http://apacmediacentre.oracle.com/Content/Detail.aspx?ReleaseID=6217\">Duke选择奖</a>的获奖者参与<a href=\"http://www.oracle.com/events/apac/cn/zh-cn/javaone/index.html\">JavaONE</a>。</span><br> <br> <span style=\"line-height: normal;\">JavaONE大会的主题演讲是几个人概要介绍一下Java最近的发展，很高层的那种。真正给我留下深刻印象的是Jim Weaver，一个很有趣的老头，他是JavaFX方面的专家。他演示了一个用JavaFX实现的<a href=\"https://github.com/javafxpert/projavafx8-scratchpad\">吉它</a></span><span style=\"line-height: normal;\">，甚至现场演奏了《栀子花开》，引爆全场。他就像一个老顽童一样，他开了一个<a href=\"http://weibo.com/JavaFXpert\">微博</a>，在现场招募粉丝，还能说出，“给力able”这样的单词。感谢他在众多无趣的主题演讲中带来了一丝欢乐。</span><br> <br> <span style=\"line-height: normal;\">Java EE 7，是这次很重要的一个话题，因为它刚刚发布不久。不过，要知道，标准这个东西总是落后于开发现状的，只有当一个东西很火时，它才会被考虑放到标准里。所以，如果你的开发一直在使用比较流行的技术，那Java EE 7几乎没有什么太新鲜的东西。在最重要特性的排名里，只有前几项是所谓的新技术，比如Web Socket、批处理、JSON处理和并发。后面大多是已有技术的改进和增强。</span><br> <br> <span style=\"line-height: normal;\">Bert Ertman做了一个有趣的分享，把Spring的程序迁移回Java EE。我在之前碰巧和他坐在一起，聊了一下他准备这个话题的原因。在他看来，自从J2EE伤了众人心之后，现在已经很多人不那么关注Java EE了，而转向Spring，可现在Java EE已经有了很多新的发展，不再是从前那个笨拙了，所以，遵循标准总是要好一些。这也是我特意跑去听他怎样讲的一个原因。确实Java EE进步了不少，但从个人开发的审美上，JavaEE总是依赖于容器这个事情还是让我觉得不爽，尤其在测试上。虽然可以用<a href=\"http://arquillian.org/\">Arquillian</a></span><span style=\"line-height: normal;\">这样的工具帮忙，我还是持保留意见。</span><br> <br> <span style=\"line-height: normal;\">最出乎我意料的是一个session是一个关于Nashorn的，这是一个JavaScript引擎。我原本意味它是介绍JavaScript的，结果却是在讲InvokeDynamic这个JVM的新指令，然后，以一段简单的JavaScript为例，介绍使用InvokeDynamic怎样实现，至于Nashorn，就是一个依赖于新指令的JavaScript引擎。我一直知道InvokeDynamic，但一直没有太深入地了解它，这个session帮我理清了InvokeDynamic的基本思路。</span><br> <br> <span style=\"line-height: normal;\">还一些有意思的session。10gen的人讲MongoDB Java API设计中向后兼容性的问题。从我的角度看来，很多人在设计API时，更多的是直觉映射，还没有怎样设计API才更可用。显然，新版本的MongoDB API已经改善了很多。Oracle的人讲Lambda，作为已经比较了解Java 8 Lambda的人，我看得出，讲的人还是准备了很多东西，只不过，这个人不常出来讲东西，现场表现力和讲东西的清晰程度还有待提高。不过，我还是很喜欢他讲的内容的。TypeSafe的人讲Akka。Akka基本上算是一种企业级Actor的实现，稳定性、扩展性、监控性都要好于Scala自带的Actor。</span><br> <br> <span style=\"line-height: normal;\">还有几个观察，JavaFX和Raspberry Pi是Oracle很看重的两个领域。其中，JavaFX是为了改善Java在富客户端表现不力的局面，这次的JavaONE有不少JavaFX的主题，包括一些3D的支持。但至少目前为止，用Java做富客户端还不是主流，JavaFX还有很长的路要走，虽然Oracle还在大力地鼓吹。我的一个同对JavaFX很感兴趣，但他也觉得，如果让每个客户端都额外装一个Java运行时，恐怕还是很大的负担。</span><br> <br> <span style=\"line-height: normal;\">Raspberry Pi是一个很有意思的事，除了人所共知的平台外，Java 8最先移植的平台就是Raspberry Pi。为什么Oracle会在这个新型硬件上投入许多，我特意就这个问题咨询了Simon Ritter，Oracle的Java技术传播者，他说，Raspberry Pi很便宜，这可以让Java技术更好地传播，另一方面，Raspberry Pi的基础架构和普通的PC很像，移植工作相对于其它平台会简单一些。我看还有一点，Raspberry Pi是ARM架构，这也会是Java未来拓展ARM平台的一步探索。</span><br> <br> <span style=\"line-height: normal;\">我遇到了台湾JUG的负责人。我们在一起交流了一下两岸程序员的差异。原来在台湾，更多的受重视是做硬件的厂商，最近几年做软件得到的重视才越来越多。不过，基本上面临的问题与大陆大同小异，对于软件开发质量的不重视，造成很多误工在里面。就程序员这个职业而言，台湾与北上广就消费和收入方面，已经差不多了，原来有不少台湾厂商把工作放到大陆来做，现在基本上已经看不到，因为成本在提升。</span><br> <br> <span style=\"line-height: normal;\">这次参加大会还认识了不少人，尤其是还听说<a href=\"http://www.dianping.com/\">大众点评网</a>在试用Moco，着实让我高兴了一番。</span></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201307212226",
    "date": "2013-07-21",
    "time": "22:26",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.8发布",
    "body": "<p>前版信息：<a href=\"http://dreamhead.blogbus.com/logs/232802744.html\">Moco 0.7发布</a></p>\n<p>我很高兴地宣布，<a href=\"https://github.com/dreamhead/moco\">Moco</a>第二个正式版本<a href=\"https://github.com/dreamhead/moco/tree/v0.8\">0.8</a>发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p>Moco是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>特性变更</strong></p>\n<p>本次发布有一个重大的新特性，支持工程配置文件（Global Settings）。</p>\n<p>我们可以通过它，将一个复杂的Moco配置文件分解成多个配置，然后，通过这个配置文件将它整合起来：</p>\n<p>[<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;\"include\" : \"foo.json\"<br> &nbsp; &nbsp;},<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;\"include\" : \"bar.json\"<br> &nbsp; &nbsp;}<br>] &nbsp; <br>(settings.json)</p>\n<p>这个配置文件还支持几个不同的选项，让我们在开发时有更灵活的变化：</p>\n<ul>\n<li>支持Context：我们可以把不同的服务，部署到不同的context路径下，实现由一个Moco服务器，模拟多个服务。</li>\n<li>支持File Root：我们可以配置文件根目录，这样一来，每个具体配置文件内，所有与文件相关的路径都可以写成相对路径。</li>\n<li>支持Environment：通过指定环境变量，同一套配置在不同的环境下，由不同的部分起作用，这样就可以开发代码无需任何调整，就可以得到不同的效果。</li>\n</ul>\n<p>本次还包含一些API的变化：</p>\n<ul>\n<li>Proxy：可以将请求（包括请求的所有信息，比如内容、头灯）转发给另一个服务器，还可以通过配置failover文件，用以故障恢复，在远程服务器失败，无法返回时，从failover文件中提取请求内容进行返回。目前failover文件是JSON格式，可以手工编辑。</li>\n<li>JSONPath：请求内容按照JSONPath进行匹配。</li>\n<li>with：在API上增加with，用以进行Resource到ResponseHandler的适配。</li>\n<li>移除url：用Proxy代替。</li>\n<li>移除cache：用failover代替。</li>\n<li>移除content：用with代替。</li>\n</ul>\n<p>本次发布还有一个实验性的新特性：模板，用以根据请求定制应答。目前包含有</p>\n<ul>\n<li>请求版本：${req.version}</li>\n<li>请求方法：${req.method}</li>\n<li>查询参数：${req.queries['foo']}</li>\n<li>请求头部：${req.headers['foo']}</li>\n<li>请求内容：${req.content}</li>\n</ul>\n<p>这个特性还在进一步探索中，欢迎反馈各种问题。</p>\n<p><strong>感谢</strong></p>\n<p>感谢<a href=\"https://github.com/nezhazheng\">nezhazheng</a>，为Moco贡献JSONPath实现。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201307062024",
    "date": "2013-07-06",
    "time": "20:24",
    "tags": [
      "你应该更新的Java知识",
      "Java",
      "Guava",
      "Supplier",
      "惰性求值"
    ],
    "title": "你应该更新的Java知识之惰性求值",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/226738702.html\">你应该更新的Java知识之常用程序库（一）<br></a><a href=\"http://dreamhead.blogbus.com/logs/226738756.html\">你应该更新的Java知识之常用程序库（二）<br></a><a href=\"http://dreamhead.blogbus.com/logs/227427912.html\">你应该更新的Java知识之构建工具<br></a><a href=\"http://dreamhead.blogbus.com/logs/231594181.html\">你应该更新的Java知识之Observer<br></a><a href=\"http://dreamhead.blogbus.com/logs/232899025.html\">你应该更新的Java知识之集合初始化<br></a><a href=\"http://dreamhead.blogbus.com/logs/234113759.html\">你应该更新的Java知识之集合操作</a></p>\n<p>在开发中，我们经常会遇到一些需要延迟计算的情形，比如某些运算非常消耗资源，如果提前算出来却没有用到，会得不偿失。在计算机科学中，有个专门的术语形容它：惰性求值。惰性求值是一种求值策略，也就是把求值延迟到真正需要的时候。</p>\n<p>在Java里，我们有一个专门的设计模式几乎就是为了处理这种情形而生的：Proxy。不过，现在我们有了新的选择：Supplier。</p>\n<p>我们先来看看Supplier的定义：</p>\n<p>public interface Supplier {<br> &nbsp;T get();<br>}</p>\n<p>非常简单的一个定义，简而言之，得到一个对象。</p>\n<p>但它有什么用呢？我们可以把耗资源运算放到get方法里，在程序里，我们传递的是Supplier对象，直到调用get方法时，运算才会执行。这就是所谓的惰性求值。</p>\n<p>对于Java这种缺乏惰性求值的语言，惰性一般就是通过一个间接层来实现的。David Wheeler曾经说过：“计算机科学中的所有问题都可以通过引入一个间接层解决。”</p>\n<p>理解了基本的用法，实现一个Supplier并不困难：</p>\n<p>Supplier ultimateAnswerSupplier = new Supplier() {<br> &nbsp;@Override<br> &nbsp;public Integer get() {<br> &nbsp; &nbsp;// Long time computation<br> &nbsp; &nbsp;return 42; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp;}<br>};</p>\n<p>当我们需要这个终极答案时，只要</p>\n<p>int ultimateAnswer = ultimateAnswerSupplier.get();</p>\n<p>确实很简单，但是，我知道你已经心生另一个疑问。通常实现Proxy模式，我们只会计算一次，像终极答案这样的东西，反复运算我们可承受不起，也没有必要。</p>\n<p>我甚至知道你已经迫不及待地打算动手实现自己的解决方案，把结果保留下来，再下次调用时，直接返回结果。但，且慢。</p>\n<p>不，我并不是说多线程并发让保存结果这件小事变得复杂，因为我相信你的能力。但你是否想过，如果你打算为它这么做，也就意味着，你几乎要为所有的Supplier对象这么做。反复做一件事，显然不应该是一个程序员的作为。</p>\n<p>幸好Guava已经给我们准备好了：</p>\n<p>memorizedUltimateAnswerSupplier = Suppliers.memoize(ultimateAnswerSupplier);</p>\n<p>memoize函数帮我打点了前面所说的那些事情：第一次get()的时候，它会调用真正Supplier，得到结果并保存下来，下次再访问就返回这个保存下来的值。</p>\n<p>有时候，这个值只在一段时间内是有效的，你知道我要说什么了，Guava还给我们提供了一个另一个函数，让我们可以设定过期时间：</p>\n<p>expirableUltimateAnswerSupplier = memoizeWithExpiration(target, 100, NANOSECONDS);</p>\n<p>好了，还在自己编写Proxy处理惰性求值吗？Supplier便是你需要更新的Java知识。顺便说一下，Java 8里也有Supplier哦！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201307011800",
    "date": "2013-07-01",
    "time": "18:00",
    "tags": [
      "脚下的路",
      "读书",
      "电子阅读"
    ],
    "title": "我的电子阅读",
    "body": "<p>今年年初，我给自己定下的读书目标是30本，于今，时间过半，完成度是24本，下半年还要读完至少6本。与以往最大的不同是，今年的许多书读的是电子版。</p>\n<p>对电子阅读的兴趣始于一些阅读平台的兴起。而其中，购买方式的简化，让阅读更加简单。相比于最初的电子阅读器，如今这些阅读平台做得都很好，我们不再需要四处寻找图书的文件，再想办法复制到阅读器里，只要阅读平台买了书，然后，就可以同步到自己的阅读器中，即可开启自己的阅读之旅。</p>\n<p>现在主流的电子书阅读平台包括，<a href=\"http://book.duokan.com/\">多看</a>、<a href=\"http://tangcha.tc/books\">字节社</a>、<a href=\"http://read.douban.com/\">豆瓣阅读</a>和<a href=\"http://www.amazon.cn/Kindle%E5%95%86%E5%BA%97/b?ie=UTF8&amp;node=116087071\">Kindle</a>。在上半年读完的书里，刚好每个平台都有涉及，分别是：</p>\n<ul>\n<li>多看：《<a href=\"http://book.douban.com/subject/5916234/\">番茄工作法图解</a>》、《<a href=\"http://book.douban.com/subject/20385411/\">急诊科女超人</a>》</li>\n<li>字节社：《<a href=\"http://book.douban.com/subject/6893336/\">时间中的侦探</a>》、《<a href=\"http://book.douban.com/subject/21326266/\">与机器赛跑</a>》</li>\n<li>豆瓣阅读：《<a href=\"http://book.douban.com/subject/1059668/\">八十天环游地球</a>》、《<a href=\"http://book.douban.com/subject/3198679/\">地心游记</a>》、《<a href=\"http://book.douban.com/subject/1465007/\">生死疲劳</a>》、《<a href=\"http://book.douban.com/subject/3198684/\">机器岛</a>》、《<a href=\"http://book.douban.com/subject/7647487/\">时间的形状</a>》</li>\n<li>Kindle：《<a href=\"http://book.douban.com/subject/24540864/\">第七天</a>》</li>\n</ul>\n<p>其中前三个，都有几个平台的客户端（包括iPhone、iPad和Android）。单纯从阅读器软件上看，多看和字节社做得都很好，豆瓣阅读则不是第一眼美女。但从结果上你看到，我目前在豆瓣阅读上读的书最多。豆瓣阅读一如豆瓣的其它产品，简单是其最大特点，相比于其它二者，它更可以让人心无旁骛地阅读。</p>\n<p>但从阅读的角度说，更好的选择应该是Kindle。这里说的不是Kindle软件，而是Kindle设备。无论是iPhone，还是iPad，抑或是其它Android设备，最大的问题就是能做的事太多了，容易让人分心。除此之外，相比各种pad，Kindle Paperwhite更轻薄，而相对手机，屏幕又很大，读起书来非常有感觉。加上今年Kindle的中国商店正式上市，选择一个Kindle Paperwhite专心读书是个很不错的选择。</p>\n<p>之所以在Kindle上半年读完的书并不多，只是因为时间尚短。个人现在的倾向是，以后在Kindle上读更多的书。</p>\n<p>相对而言，电子书的价格比纸书低很多，用几块钱买一本几十块的钱数还是能够承受得起的。而且，现在明显处于一个推广期，各个平台经常会有限免或特价的活动，比如，多看每天会有一本限免书，而Kindle则每天有本特价书。正是因为价格不高，我也就买了一些正版书籍，避免盗版，省去了找文件，拷文件的过程。</p>\n<p>目前而言，电子阅读平台上的内容还不够多，尤其是软件开发相关的图书数量有限。不过，随着电子书逐渐普及，这方面会逐渐得到改善的。</p>\n<p>当然，无论有怎样的平台，怎么便利的购买手段，排在第一位的考量永远应该是读书，否则，实体书那种只买不读的往日荣光又回复现于电子平台。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201306300948",
    "date": "2013-06-30",
    "time": "09:48",
    "tags": [
      "ThoughtWorks",
      "学生"
    ],
    "title": "学生的提问（三）",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/234676865.html\">学生的提问（一）<br></a><a href=\"http://dreamhead.blogbus.com/logs/234690744.html\">学生的提问（二）</a></p>\n<p><strong>女生应聘，会不会有劣势？</strong></p>\n<p>问这个问题一定是女生，且程序写得不多。</p>\n<p>同之前回答的一些问题一样，你是否能成为一个好程序员，与性别无关，与你的投入有关。在ThoughtWorks里，有许多优秀的女程序员，其中不少是毕业之后加入ThoughtWorks。许多人初入ThoughtWorks都是一脸茫然，现在已经是干将了。图灵社区里有<a href=\"http://www.ituring.com.cn/article/41418\">一篇文章</a>，采访我们公司的贾永娜。时至今日，我依然记得她初入公司的状态，而如今，她已经挑起了大量。</p>\n<p>许多女生问这个问题，往往是因为她们都是学校里的乖乖女，在学校里，以“好好学习”为主。而学校里的“好好学习”基本上以读书为主，对于软件开发而言，这种做法却缺少了最重要的一环：实践。只读书不实践，或少实践，这种做法在学校里很容易通关，却与实际工作需要脱节，所以，一般“好好学习”的女生在找工作时，优势一下子变成了劣势。这是教育的问题。</p>\n<p>女生不像男生那么爱折腾，所以，动手能力显得不那么强，也就此形成了一种偏见，女生不适合编程。实践证明，只要投入了足够的时间，女生做得丝毫不比男生差，甚至做得比男生还要好。这方面极致的例子是，ThoughtWorks作为一个以软件开发闻名的公司，我们的CTO Rebecca Parsons就是一个女性。</p>\n<p>社会上女性在应聘时的另一个劣势是，她们在未来要面临结婚生子。生孩子通常意味着，要面临着几个月，甚至更长时间的暂停期。这是许多公司不愿意接受女性的重要原因。许多拼事业的女性往往也因此推迟了许多个人计划。</p>\n<p>在ThoughtWorks里，虽然女性要面临着同样的问题，但并不会对个人发展造成太大的影响。我的同事里有许多女性是在ThoughtWorks里完成人生这个重要阶段的。有些人返回工作岗位上反而比之前工作得更为优异，因为经过这个阶段之后，她们会变得比之前更为细腻，更好地理解其他人，也能更好与其他人协作。</p>\n<p>我们在这方面也有很好的例子，我们在西安有个同事，她在ThoughtWorks完成了自己重要一步，回到工作岗位上取得了更大的成绩，最近成为了西安办公室的负责人。还有另外一个例子，我们中国区负责人力资源分配的RM（Resource Manager）是在自已还没回到工作岗位上就成功地内部应聘了这个职位。</p>\n<p>在ThoughtWorks，我们往往愿意给女性更多机会。在毕业生招聘上，男女比例严格执行1：1，换句话说，如果招不来足够数量的女生，一些不错的男生也不得不放弃。</p>\n<p><strong>你们会不会像微软研究院、贝尔实验室那样让人想做什么做什么？</strong></p>\n<p>能问出这样的问题，至少说明提问的人还是关心过各个IT公司的情况。</p>\n<p>但是，无论是微软研究院，还是贝尔实验室，他们都是研究机构，研究机构主要的工作是做出一些不一样的东西，所以，他们得到的空间非常大。但空间大，也并不意味着他们想做什么做什么，而是集中于某个特定领域，比如，我们熟知的微软亚洲研究院在多媒体方向，贝尔实验室在通信领域，只不过，他们在研究过程中产生了一些副产品，比如Unix，让人们误以为他们真的是随心所欲。</p>\n<p>另外，能够进入到这些机构，按照自己的选择方向进行研究，通常也是在某个方面证明了自己的人，比如，一些博士或是某些专家。不是说他们会给任何人在里面随心所欲的机会。而通常，刚毕业的学生还在寻找自己的方向，真的有这样的机会，往往也是不知所措。</p>\n<p>真正的商业公司给人的空间不会有这么大，但也不是说完全没有空间，比如Google会有20%的时间做自己想做的事情。在ThoughtWorks里面，我们的空间有多大呢？这取决于自己的努力。</p>\n<p>我曾经和我们的CEO郭晓聊过，他说自己日常工作中一个很重要的部分是决定把钱投到哪个方向。在ThoughtWorks里，有想法的人太多，支持每一个有想法的人，几乎是一件不可能的事。所以，要想得到更多的支持，就要自己在这个方面投入更多。</p>\n<p>一个例子是我们的产品。现在，产品团队的负责人<a href=\"http://michael.nona.name/\">陈金洲</a>个人一直对做产品非常有兴趣。产品团队打造的第一款产品就是在没有任何支持的情况下，他个人独立做了半年，用实际行动证明了自己在这个方面的兴趣，最终得到了公司的支持，所以有了现在的产品团队。</p>\n<p>还是那句话，在这个公司里，有想法的人太多。但很多人的想法真的就只是想法，过了就忘了。真正能从想法变成现实的，需要个人非常大的投入。我个人在ThoughtWorks做成了几件事，但每一件我都为之投入很多。比如，给毕业生的郑大晔校，至少前两年，我几乎每场必到，比如，ThoughtWorks校园行，刚开始也是每次必到，每个session都是我亲自打磨。</p>\n<p>学生而言，是一个有想法的群体。但是，把想法变成现实，是让他们变得脚踏实的蜕变。别抱怨没人支持自己的想法，自己先用行动支持自己，这才是最现实的选择。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201306291858",
    "date": "2013-06-29",
    "time": "18:58",
    "tags": [
      "ThoughtWorks",
      "学生"
    ],
    "title": "学生的提问（二）",
    "body": "<p><a href=\"%20http://dreamhead.blogbus.com/logs/234676865.html\">学生的提问（一）</a></p>\n<p><strong>你们公司会加班吗？</strong></p>\n<p>关心这个问题的人通常有两种原因：</p>\n<ul>\n<li>听说软件行业加班很厉害。</li>\n<li>我想找个轻松的工作。</li>\n</ul>\n<p>我们先来区分一下加班。首先，并不是八小时外的工作就叫加班。在ThoughtWorks，过了八小时，办公室里也经常是有人的。他们留在办公室的常见原因有如下几种：</p>\n<ul>\n<li>提交代码不小心造成CI失败，一般会修好再走，保证其他人（尤其是在不同时区的人）可以正常工作。</li>\n<li>办公室里有一些活动，比如Coding Kata，某个Workshop之类。</li>\n<li>利用公司环境进行额外学习。</li>\n<li>软件行将上线，需要人值守。</li>\n</ul>\n<p>通常，只有等待上线算得上正常“加班”。</p>\n<p>无论你做什么工作，在工作期间有一些加班都是很正常的，为了赶工完成一些东西，这是情有可原的。真正的差异在于加班的频率。</p>\n<p>软件行业在加班问题上声名不彰，一个很重要的原因是加班频率很高。但其实，很多情况下，加班不是必然。</p>\n<p>我了解过的很多公司，加班是一种企业文化，你不好意思早些走，因为其它人都在加班。遗憾的是，看别人怎么做通常是国人习惯的做法。选择公司的时候，你需要在各个方面好好平衡一下。只有八小时之外拥有自己的时间，你才有机会替自己的未来思考。</p>\n<p>正常情况，ThoughtWorks是不需要加班。但对学生来说，还有另外一种压力在，这种压力可能会占据工作之外的时间：成长。一般来说，学生刚刚加入公司时，无论是按照工作要求，还是与周边其他人之间，都有着巨大的差距。努力地弥补巨大的差距往往是这些职场新人面临的第一个主题。</p>\n<p>新人们往往会选择利用八小时之外的时间更多地学习，所以，即便不加班，很多人下了班的时间也并不轻松。正是因为这样，ThoughtWorks的新人们一般都成长得非常快。</p>\n<p>如果你期望不加班，ThoughtWorks是个选择，如果你期待轻松，也许ThoughtWorks并不一定是个好选择。</p>\n<p><strong>你们有培训吗？</strong></p>\n<p>关心这个问题的同学多半是上了十几二十年学，被老师喂习惯了。事实上，大多数学生加入公司都需要经历的一个思维转变过程。</p>\n<p>作为学生，从小时候开始，一路都有人告诉该做什么，小学中学大学，写作业，听老师讲课等等。所以，也就形成了一种惯性思维，所有的事都希望有人给安排好。即便是毕业之后，内心也是有一种“被安排”的追求。</p>\n<p>很多人关心这个问题，实际上，内心想听到的答案是，经过培训之后，我就具备工作所需的全部技能，然后，我就等着“考试”就好了。有的工作是这样，所以，你会听到很多人抱怨几十年如一日，那就是所谓的“稳定”。如果你追求的是人生的成长，就不那么“稳定”了。你需要不停地学习，准备在工作中随时应对新的挑战。</p>\n<p>在ThoughtWorks，挑战无处不在。</p>\n<p>对于学生，ThoughtWorks有培训，加入公司之前会有郑大晔校，加入公司之后会有TWU。但是，ThoughtWorks真正有价值的培训是与人一起工作，而这个培训并不是让你坐在课堂里听别人讲东西，而是手把手在一起工作。不过，这样工作远要比培训压力大，几乎是随时随地地反映出你技能上的差异，所以，对于学生来说，压力非常大，但只要顶得住压力，成长也会非常快。</p>\n<p>在西安和成都两个办公室——也是我们招聘毕业生的主力，培养人已经成为了一个重要的主题，周边的人会非常关注你的成长。</p>\n<p>不过，我这里想说的是，真正对你负责的不是别人，而是你自己。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201306280701",
    "date": "2013-06-28",
    "time": "07:01",
    "tags": [
      "ThoughtWorks",
      "学生"
    ],
    "title": "学生的提问（一）",
    "body": "<p>ThoughtWorks做过很多次校园活动，我也参加过很多次，有一些问题经常被问起。不妨在此整理一下。</p>\n<p><strong>如果不是学习计算机专业，应聘你们公司会不会很吃亏？</strong></p>\n<p>能问出这样问题的人，通常有两个特点：第一，所学专业不是计算机，第二，对自己写程序的能力不够自信。</p>\n<p>把大学当技校，是学生普遍存在的一个误解。学了这个专业，在这个专业领域领域内就强，没学就弱，是一种常识，也是一种误解。</p>\n<p>我的同事里有有很多优秀的程序员，学的专业根本和计算机不搭边。他们只是发现了写程序是他们的最爱，于是，义无反顾地投身其中，而且，这样的人往往会觉得自己不是专业出身，所以，往往会更加勤奋地弥补“天生”的欠缺，取得的结果往往比“专业”人士好得多。</p>\n<p>另一方面，许多人是学了这个专业之后发现，自己根本不适合做这个，于是，转投了其它专业。无论是同事还是同学，我身边这样的例子比比皆是。</p>\n<p>如果一个公司招聘以“计算机及相关专业”作为硬性标准，而不看实际的动手能力，这样的公司不去也罢。</p>\n<p><strong>本科和研究生应聘你们公司会不会有差别？</strong></p>\n<p>很显然，这个问题一般是本科生问的。同专业的问题一样，学历对于软件开发来说，如果不是一文不值的话，也不值几文。</p>\n<p>这里的假设是这样的，研究生比本科生多学习了几年，所以，水平比本科生高。如果从整体上说，是这样的。但是，所谓整体上说，意味着跟你作为一个个体并无直接关联。</p>\n<p>编程的水平与学历无关，与投入的时间有关。从我了解的情况看，很多研究生选择读研原因并不是我们假想的为科学奋斗那样崇高的目标：本科毕业没找到合适工作，或是，本科没有好好练习写程序，用研究生的时间来练，以此找个好工作。所以，如果本科多花点时间写程序，就可以省下了两三年的时间，多赚两三年钱了。</p>\n<p>这是一个很现实的答案，一般来看，研究生的水平通常不如同年龄工作两三年的人。所以，经常看到这样一种现象，一个项目组里，两个同龄人，有工作经验的带着研究生。即便放到长线来看，研究生所谓的潜力也并不比其他人突出。</p>\n<p>从我们自己的招聘上来看，应聘ThoughtWorks成功的本科生和研究生，从能力上讲，相差无几。从长期发展来看，某些本科生甚至做得比研究生还要好。</p>\n<p>还是那句话，编程的水平与学历无关，与投入的时间有关。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201305251656",
    "date": "2013-05-25",
    "time": "16:56",
    "tags": [
      "你应该更新的Java知识",
      "Java",
      "Guava",
      "集合"
    ],
    "title": "你应该更新的Java知识之集合操作",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/226738702.html\">你应该更新的Java知识之常用程序库（一）<br></a><a href=\"http://dreamhead.blogbus.com/logs/226738756.html\">你应该更新的Java知识之常用程序库（二）<br></a><a href=\"http://dreamhead.blogbus.com/logs/227427912.html\">你应该更新的Java知识之构建工具<br></a><a href=\"http://dreamhead.blogbus.com/logs/231594181.html\">你应该更新的Java知识之Observer<br></a><a href=\"http://dreamhead.blogbus.com/logs/232899025.html\">你应该更新的Java知识之集合初始化</a></p>\n<p>我们打算做要做这样一件事，给出所有有资格过五四青年节的人的名字。如果你不知道的话，有资格过五四青年节的人要年龄在14周岁到28周岁之间。</p>\n<p>按照传统的思路，这段代码应该是这样写：</p>\n<p>List names = new ArrayList();<br>for (Person person : people) {<br>&nbsp; int age = person.getAge();<br>&nbsp; if (age &gt;= 14 &amp;&amp; age &lt;= 28) {<br>&nbsp; &nbsp; names.add(person.getName());<br>&nbsp; }<br>}</p>\n<p>是不是很熟悉？这样的代码在我们的代码库中几乎随处可见。单就这段代码而言，本身没什么问题。这里只是举了一个简单的例子，但现实情况往往比这复杂得多，于是，我们经常看到一个for循环里嵌套了大量的代码。</p>\n<p>好，新风格代码时间。这次我们还是会用到Guava，先上代码后解释：</p>\n<p>Iterable names = transform(filter(people, isAgeQualified()), toName());</p>\n<p>这里先介绍两个重要的函数transform和filter，这两个函数都是对一个集合中的各个元素进行操作。</p>\n<p>transform如名所示，它把集合中的一个值转换为另一个值的函数，至于具体怎么转换，则由后面的函数定义。我们来看看toName的定义：</p>\n<p>Function&lt;Person, String&gt; toNames() {<br>&nbsp; return new Function&lt;String, Integer&gt;() {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public boolean apply(Person person) {<br>&nbsp; &nbsp; &nbsp; return person.getName();<br>&nbsp; &nbsp; }<br>&nbsp; };<br>}</p>\n<p>这个函数的返回值是一个Function，是的，它是一个“函数”。在Java里，函数不是一等公民，所谓一等公民指的是：</p>\n<ul>\n<li>它可以按需创建</li>\n<li>它可以在数据结构中存储</li>\n<li>它可以作为实参传给一个函数</li>\n<li>它可以当做一个函数的返回值</li>\n</ul>\n<p>Java世界的一等公民是对象，但我们可以用对象包装函数，就像前面这样，这就是函数对象。如果你了解函数式编程，你会发现，transform接收一个函数作为它的参数，那它实际上就是一个高阶函数：</p>\n<ul>\n<li>接收一个或多个函数做实参</li>\n<li>以一个函数做返回值</li>\n</ul>\n<p>在函数式编程里，最为强大的一点就是通过函数的组合，我们可以做到很多未曾想过的做法，程序的可扩展性也会出乎意料地好。</p>\n<p>让我们继续把未介绍完的说完，接下来是filter，它表示用一个条件对集合的元素进行过滤，条件在哪？我们来看isAgeQualified的定义：</p>\n<p>Predicate isAgeQualified() {<br>&nbsp; return new Predicate() {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public boolean apply(Person person) {<br>&nbsp; &nbsp; &nbsp; int age = person.getAge();<br>&nbsp; &nbsp; &nbsp; return age &gt;= 14 &amp;&amp; age &lt;= 28;<br>&nbsp; &nbsp; }<br>&nbsp; };<br>}</p>\n<p>Predicate实际上也是一种形式的函数，只不过，它的返回值是boolean，有了上面的基础，它也就不那么难以理解了。</p>\n<p>好，为了体现这段程序的扩展性，我们继续扩展一下我们的需求：我们要找出所有符合条件的男同胞。如果采用的是原来的循环，那么我们通常的做法是在if里面在添加一个条件，事实上，大量复杂的for循环就是这么一点一点扩充出来的。好，我们看看按照新的做法，我们会怎么做：</p>\n<p>Iterable names = transform(filter(people, and(isAgeQualified(), isMale()), toName());</p>\n<p>这里新增了isMale()函数，它的实现你也可以想到：</p>\n<p>Predicate isMale() {<br>&nbsp; return new Predicate() {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public boolean apply(Person person) {<br>&nbsp; &nbsp; &nbsp; return person.isMale();<br>&nbsp; &nbsp; }<br>&nbsp; };<br>}</p>\n<p>这里还增加了一个and函数，它可以把多个Predicate组合起来。Guava本身给我们还提供许多这样的逻辑运算符，比如or、not等等。</p>\n<p>一旦形成了一个函数，它最大的价值在于重用，比如，我们现在要超出一些男同胞，干些体力活，那这个函数就又可以发挥价值了。</p>\n<p>如果你接触 Lisp 族的程序设计语言,这样的括号套括号的做法你会觉得眼熟。当我们有很多的操作要组合在一起的时候，这种写法就颇具 Lisp 风味了。之所以我们需要写成这样，很大程度是拜 Java 僵化的语法所赐，我们无法给既有类型添加方法。在一 些可以扩展类的语言里，这段代码会更流畅一些。</p>\n<p>Guava还给我们提供了另外一种做法，既然我们不能扩展已有的类，就不妨提供一个新的类，它的名字叫做FluentIterable：</p>\n<p>FluentIterable names = FluentIterable.from(people).filter(isAgeQualified()).transform(toName());</p>\n<p>如果你说过<a href=\"http://www.antiifcampaign.com/\">反if</a>和<a href=\"http://codebetter.com/matthewpodwysocki/2009/06/26/the-anti-for-campaign/\">反for</a>运动，看了这篇，你就应该知道怎么样消除集合操作中的一些if和for了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201305080622",
    "date": "2013-05-08",
    "time": "06:22",
    "tags": [
      "ThoughtWorks"
    ],
    "title": "六年思想工作者",
    "body": "<p>六年，在ThoughtWorks六年了。</p>\n<p>还记得六年前，我加入公司的时候，整个办公室也不过三十几个人，而今天，ThoughtWorks中国区已经发展成四个办公室，小三百号人了。这六年间人来来往往，按照加入公司时间排序的话，我已经是ThoughtWorks中国区的第18号员工了，当年的新员工，已经成了老鸟。当年屁颠屁颠地跟着别人一起写程序，到现在带着一些人写程序，并影响着更多的一些人写程序。</p>\n<p>作为一个普通的程序员，我也有过很多普通程序员的困惑。我应该在怎样的公司工作，公司能给我带来什么。我也看到过这样的讨论，我应该进ThoughtWorks，还是进百度。</p>\n<p>其实，所谓这些问题都不是真正的问题。真正的问题是我想做什么。</p>\n<p>100%可以肯定的是，无论哪个公司，有在里面做得怡然自得的，也有在里面做的闷闷不乐的。在ThoughtWorks里面，我们可能接触到各种各样好玩的技术，也可能在一个遗留系统焦油坑里被折磨得死去活来；我们可能参加各种各样有趣的活动，也可能因为没有个“标准”告诉我该做什么而茫然失措；我们可能享受与牛人交流的快乐，也可能被不断袭来的某些反馈弄得心烦意乱。</p>\n<p>所谓机会，哪个公司都有各种各样的机会，只是这样的机会多大程度上能砸到你的头上。不是进了百度，就都能去做搜索引擎，不是进了淘宝，就都能去支持光棍节。你的机会在哪里？在自己。</p>\n<p>很多人通常都习惯于别人把工作安排到自己头上，自己按部就班做就好了，却很少有人想我要做什么，一下子就把自己未来的发展放到别人的手里。遗憾的是，别人没那么关心你，于是，你会很好奇地发现，为什么机会都到别人那里了，自己只有怨天尤人的份。答案除了上司眷顾之外，个人的积极主动占了很大一部分。</p>\n<p>面试的时候，我经常会问候选人一个问题，你未来想做什么？答案当然是各种各样。接下来，我会问，你之前为此做了些什么，这个时候你就会发现，很多人什么都没做。所谓想做什么，真的只是想想而已。</p>\n<p>说起来，公司是我们个人发展的平台。但是，只有在我们为自己的发展做了打算，并付诸努力时，公司才会成为我们的推动力，机会才会不经意间降临在我们的头上。</p>\n<p>遗憾的是，很多人考虑公司考虑的只是报道中的公司，考虑的是自己按部就班能够得到什么。</p>\n<p>回想自己六年ThoughtWorker生涯，公司给我最大的回报是机会。当我想做一些事情时，我只要争取通常都有不错的结果。当我想尝试Rails项目时，我可以；当我想尝试培养新人时，我可以；当我想回归Java项目时，我可以……当然，有时我不得不做一些不那么心甘情愿的事，比如，敏捷咨询，那段时间恰恰是我自己最没想法的阶段。</p>\n<p>相比于很多公司，ThoughtWorks的扁平结构让我们经常有机会把自己的想法和“领导”交流。不知道你上一次和自己公司的大领导是什么时候，我前不久刚和我们的新CEO吃饭聊天来着。交流了，想法得到表达，机会自然也就有了。在ThoughtWorks里，交流是很重要的。</p>\n<p>如果说ThoughtWorks有什么特别之处，在我看来，它让普通员工有了更多实现自己想法的机会。</p>\n<p>最后，讲一个我们“领导”的故事。最近有一条新闻，<a href=\"http://www.thoughtworks.com/news/thoughtworks-announces-new-ceo-and-collective-leadership-structure\">ThoughtWorks宣布了新的CEO</a>，他就是我们原来中国区的总经理郭晓。。事实上，直到今年年初，郭晓都没想过做ThoughtWorks的CEO。他只是在每次ThoughtWorks全球管理团队一起讨论各种各样的事情时，非常积极，主动承担了很多工作。当大家认为需要一个成为CEO的时候，几乎所有人脑子里面都想到了一个名字：郭晓。于是，他成了ThoughtWorks的CEO，如果我没记错的话，郭晓也是第一个成为跨国外企CEO的中国人。顺便说一下，十几年前郭晓加入ThoughtWorks时，他是一个程序员。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201305011756",
    "date": "2013-05-01",
    "time": "17:56",
    "tags": [
      "moco"
    ],
    "title": "Moco 0.7发布",
    "body": "<p>我很高兴地宣布，<a href=\"https://github.com/dreamhead/moco\">Moco</a>第一个正式版本<a href=\"https://github.com/dreamhead/moco/tree/v0.7\">0.7</a>发布了。</p>\n<p><strong>Moco是什么？</strong></p>\n<p><a href=\"https://github.com/dreamhead/moco\">Moco</a>是一个可以轻松搭建测试服务器的框架/工具/程序库。</p>\n<p><strong>Moco的使用场景</strong></p>\n<ul>\n<li>我是一个企业级软件开发人员，每次面对集成就是我头疼开始的时候，漫长集成拉锯战拖延了我们的进度。幸好有了Moco，几行配置就可以模拟一个服务，我再也不需要看集成服务团队的脸色了。</li>\n<li>我是一个移动开发人员，老板催得紧，可服务器端开发进度慢，我空有一个漂亮的iphone应用，发挥不出作用。幸好有了Moco，很快就可以搭建出一个模拟服务，我再也不用把生命浪费在无效的等待上了。</li>\n<li>我是一个前端开发人员，做Inception的时候，客户总想看到一个完整的应用演示，可哪有时间开发后端服务啊！幸好有了Moco，几下就可以弄出一个模拟服务，我做的页面一下就有了生命力。</li>\n</ul>\n<p><strong>使用Moco</strong></p>\n<p>Moco目前支持多种使用方式，最基本的方式是两种：<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/usage.md#api\">API</a>和<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/usage.md#standalone\">独立运行</a>。</p>\n<p>如果你编写的是个Java应用（或是以其它JVM上的语言编写的应用），你可以采用直接调用API；我们也可以独立运行的方式，在配置文件中，配置一个属于自己的服务器。</p>\n<p>如果你是Mac或是Linux用户，你还可以选择<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/usage.md#shell\">Shell</a>的方式运行。事实上，它是最简单的方式，它会自动帮助你找到最新版本的Moco。</p>\n<p>如果你在用Maven，那么Moco的<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/usage.md#maven-plugin\">Maven插件</a>你一定会喜欢。作为一个新时代的自动化用户，<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/usage.md#gradle-plugin\">Gradle插件</a>也是不可或缺的。</p>\n<p><strong>特性</strong></p>\n<p>此次发布的特性包括</p>\n<ul>\n<li>对HTTP的支持</li>\n<ul>\n<li>内容（文本，文件）</li>\n<li>URI</li>\n<li>查询参数</li>\n<li>HTTP方法</li>\n<li>HTTP版本</li>\n<li>HTTP头</li>\n<li>状态码</li>\n<li>重定向</li>\n</ul>\n<li>对Web的支持</li>\n<ul>\n<li>cookie</li>\n<li>form</li>\n</ul>\n<li>对集成的支持</li>\n<ul>\n<li>XML</li>\n<li>XPath</li>\n<li>JSON</li>\n<li>访问其它URL</li>\n</ul>\n<li>杂项</li>\n<ul>\n<li>延迟</li>\n<li>缓存</li>\n<li>目录挂载</li>\n</ul>\n</ul>\n<p>具体的使用方式，可以看<a href=\"https://github.com/dreamhead/moco/blob/master/moco-doc/configurations.md\">这里</a>。</p>\n<p><strong>感谢</strong></p>\n<p>感谢<a href=\"https://github.com/elvis-liu\">刘宇峰</a>、<a href=\"https://github.com/gigix\">熊节</a>、<a href=\"https://github.com/wahyd4\">赵俊伟</a>、<a href=\"https://github.com/GarrettHeel\">Garrett Heel</a>，为Moco贡献代码。</p>\n<p>感谢郭晨，为Moco实现了一个favicon。</p>\n<p>感谢<a href=\"https://github.com/reverocean\">何海洋</a>，贡献了Shell的支持。</p>\n<p>感谢<a href=\"https://github.com/GarrettHeel\">Garrett Heel</a>，实现了Maven插件。</p>\n<p>感谢<a href=\"https://github.com/silverjava\">银大伟</a>，实现了Gradle插件。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201304301234",
    "date": "2013-04-30",
    "time": "12:34",
    "tags": [
      "Moco",
      "程序库设计",
      "DSL",
      "Publish接口"
    ],
    "title": "从Moco谈程序库设计",
    "body": "<p>Moco在程序库设计包括两个方面，如何设置服务器和如何让服务器运行起来。</p>\n<p>先说简单的，如何让服务器运行。最简单的选择是让用户自己启动服务器，然后，在测试结束之后关闭服务器。这么一来，每个测试都大概会是这样：</p>\n<p>public void shouldWork() {<br> &nbsp;... setup server ...<br> &nbsp;try {<br> &nbsp; &nbsp;server.start();<br> &nbsp; &nbsp;... your test here ... <br>&nbsp; } finally {<br> &nbsp; &nbsp;server.stop();<br> &nbsp;}<br>}</p>\n<p>作为一个框架，留给客户使用的接口一定简单，把实现细节封装在框架以内。如果每个测试都这么写，用户很快就会骂娘了。现在的Moco的做法是使用了running方法，把Server启停的细节封装了起来。</p>\n<p>running(server, new Runnable() {<br> &nbsp;@Override<br> &nbsp;public void run() throws Exception {<br> &nbsp; &nbsp;assertThat(helper.get(root()), is(\"foo\"));<br> &nbsp;}<br>});</p>\n<p>我知道你不喜欢匿名内部类，我也不喜欢，但是，这是Java的局限。等到Java 8驾临，相信一切会有所改观。</p>\n<p>设置服务器，也就是在什么样的请求，给什么样的应答。Moco有一个很关键的起点，那便是DSL，要知道，之前的一段时间我刚刚完成了《<a href=\"http://book.douban.com/subject/21964984/\">领域特定语言</a>》的翻译。于是，API的可读性成了一件非常重要的事。</p>\n<p>说起来很简单，但是，要知道匹配请求的条件有很多，而且还可能任意组合。如果这些条件是彼此独立的（“或”），我可以用变参来解决，但有时，这些条件是相关的（“与”），那该怎么办呢？拜函数式编程思路所赐，我想到了函数组合的方式。</p>\n<p>我知道，Java没有一等公民的函数，但是，Java里有一等公民的对象，我们可以用对象模拟函数，事实上，这也是很多面向对象程序设计语言解决函数组合的一种方式，而这种对象称为函数对象，也叫functor。</p>\n<p>把需要的条件封装成一个个函数对象，然后通过几个简单的运算符就可以将它们组合起来。目前Moco里提供了and和or两个运算符用于组合。</p>\n<p>server.request(and(by(uri(\"/foo\")), by(method(\"put\")))).response(\"bar\");<br>server.request(or(by(\"foo\"), by(uri(\"/foo\")))).response(\"bar\");</p>\n<p>随着面向对象思路的普及，函数组合的写法会越来越普遍的，它会成为程序员工具箱中的必备品。</p>\n<p>DSL是一个重要的考量，所以，这里没有直接new对象，而是用函数（比如uri、method）做了一层封装。或许你会说，那为了可读性，我可以把类名设计成一个可读的样子，但new一个对象的问题在哪呢？就在new上。一方面，new是为了创建一个对象，这是实现细节，与我们要表达的内容不在一个层次，另一方面，你会发现多个new会让这句话显得不连贯。这句话？是的，我们的写法就像是用一句话声明一个东西一样，而我们期望自己讲的内容有一定的连贯性，而这才是DSL。</p>\n<p>一旦设计成DSL，单个函数的文档也就失去了意义，更重要的是一个用法的文档。所以，在Moco里，我写了文档，却没有写JavaDoc。</p>\n<p>在Moco里，请求和应答里可能有同样的东西，比如file，而request和response的参数类型是不一样的。如果file能够返回不同类型是最好的，可惜在Java里面，我们不可能根据返回类型做重载。一种解决方案是为request和response分别设计一个函数，比如requestFile和responseFile，但显然，这种做法会把同样的逻辑分散到两个类实现里，而且这样需要共享的东西不只是file，还有其它一些东西。</p>\n<p>在计算机问题里，加上一个中间层永远是一个重要的解决方案。这也是by的目的所在。这样一来，这些共享的东西就可以做成一个抽象（Resource），对请求来说，只要有一个by，就可以适配成Matcher。</p>\n<p>在Moco设计中，还涉及到了一个框架设计中很重要的点：类型。Java是静态类型程序设计语言，利用好类型，就可以在编译期把错误报出来，而不会留到运行时，fail fast是很重要的一个程序设计实践。</p>\n<p>Moco目前支持一些Content Type检测。如果把这个Content Type放到Resource里面，你会发现不是所有Resource都需要这个，比如method，我们当然可以在Resource接口里支持Content Type，在不需要的地方抛出异常。</p>\n<p>在Moco里，我的做法是引入了一个ContentResource，支持Content Type，它继承于Resource，这样依赖，需要Content Type的接口（比如content），直接支持ContentResource，而其它部分继续支持Resource，这样，如果一不小心用错的话，编译就会报错。</p>\n<p>再有一点是关于Publish接口，在Moco的实现里有一个Setting，还有一个BaseSetting，如果观察实现，在设置Request会创建出一个BaseSetting，但其返回的接口是Setting。这么做的一个原因是，因为Setting出现在用户可以使用的接口上，而BaseSetting是留给内部实现的，它提供了一些用于内部实现的方法，而用户是不应该使用这些方法的，所以，将二者做了一个分离，这样一来，保证了用户不会误操作。同样处理的还有HttpServer和ActualHttpServer。</p>\n<p>小结一番，简化用户接口，设计DSL，利用好类型，区分Publish接口。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201304180711",
    "date": "2013-04-18",
    "time": "07:11",
    "tags": [
      "Java",
      "Guava",
      "EventBus",
      "Observer",
      "你应该更新的Java知识"
    ],
    "title": "你应该更新的Java知识之Observer",
    "body": "<p>作为一个Java程序员，不熟悉设计模式简直不好意思和人打招呼，而Observer模式可以说是位列最常用的设计模式之列，虽然有时候在具体代码里，它不一定叫这个名字，比如改头换面叫个Listener，但模式就是这个模式。</p>\n<p>手工实现一个Observer也不是多复杂的一件事，只是因为这个设计模式实在太常用了，Java就把它放到了JDK里面：<a href=\"http://docs.oracle.com/javase/6/docs/api/java/util/Observable.html\">Observable</a>和<a href=\"http://docs.oracle.com/javase/6/docs/api/java/util/Observer.html\">Observer</a>，从JDK 1.0里，它们就一直在那里。从某种程度上说，它简化了Observer模式的开发，至少我们不用再手工维护自己的Observer列表了。</p>\n<p>不过，如前所述，JDK里的Observer从1.0就在那里了，直到Java 7，它都没有什么改变，就连通知的参数还是Object类型。要知道，Java 5就已经泛型了。Java 5是一次大规模的语法调整，许多程序库从那开始重新设计了API，使其更简洁易用。当然，那些不做应对的程序库，多半也就过时了。这也就是这里要讨论知识更新的原因所在。</p>\n<p>今天，对于普通的应用，如果要使用Observer模式该如何做呢？答案是<a href=\"https://code.google.com/p/guava-libraries/\">Guava</a>的<a href=\"http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/eventbus/EventBus.html\">EventBus</a>。如你所见，它的名字并没有直接告诉你它是一个Observer，但这有什么关系呢，Listener不也是这样。</p>\n<p>首先，我们声明一个Observer：</p>\n<p>public class EventObserver {<br> &nbsp;@Subscribe public void onMessage(Message message) {<br> &nbsp; &nbsp;...<br> &nbsp;}<br>}</p>\n<p>你会发现，这个类并没有继承任何接口，只是在用来响应通知的方法上声明了一个@Subscribe。</p>\n<p>使用EventBus很简单，先声明一个</p>\n<p>&nbsp; EventBus eventBus = new EventBus();</p>\n<p>然后，把我们写好的Observer注册进去：</p>\n<p>&nbsp; eventBus.register(new EventObserver());</p>\n<p>当要通知Observer时，我们只要这样即可：</p>\n<p>&nbsp; eventBus.post(message);</p>\n<p>这里，我们并没有告诉EventBus，我们要处理的是一个Message类型，只是在EventObserver的onMessage方法的接口声明上使用了这个类型而已。但是，当我们把消息发送出去的时候，它会根据类型进行匹配，保证我们的消息正确地发送到对应的地方。</p>\n<p>相比于JDK原有的实现，这个实现会更简单。EventObserver不再需要存在一个继承体系中，而继承总是一种枷锁，把我们套牢在一个体系之中：</p>\n<ul>\n<li>我们不必遵循一个特定的名字，比如Observer的<a href=\"http://docs.oracle.com/javase/6/docs/api/java/util/Observer.html#update(java.util.Observable,%20java.lang.Object)\">update</a>，而这里的名字onMessage是我们自己起的。</li>\n<li>我们不必遵循特定的类型，比如update方法中作为被观察对象Observable和作为参数的Object，而是根据我们自己的需求选择的类型。</li>\n</ul>\n<p>这种变换让静态类型的Java语言，有了一些动态类型的特质，也让程序更加灵活。这种灵活性多半要归功于Annotation，它在很大程度上影响了Java的程序设计风格。</p>\n<p>除了标准的EventBus，Guava还提供了另外一个<a href=\"http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/eventbus/AsyncEventBus.html\">AsyncEventBus</a>，从名字就可以看出，这是一个异步的EventBus，也就是说，消息扔给它之后，会立即返回，至于Observer什么时候处理，那就是它的事情了。</p>\n<p>如果你想更多地了解EventBus，那Guava的<a href=\"https://code.google.com/p/guava-libraries/wiki/EventBusExplained\">官方文档</a>是个不错的去处。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201304150725",
    "date": "2013-04-15",
    "time": "07:25",
    "tags": [
      "时间管理",
      "早睡早起",
      "小步前进"
    ],
    "title": "杂谈时间管理",
    "body": "<p>最近经常被不同的人问到同一个主题，时间管理。他们很好奇，除了每天工作，还在翻译书，还写开源项目，我哪来的那么多时间。在自己眼中，我一直是时间管理做得很糟糕的。如果说我是时间管理做得很好，我应该已经做出了更多的东西，而不是最近才产出。</p>\n<p>之所以最近才开始有产出，一个最大的转变是生活方式的转变：早睡早起。其实，<a href=\"http://dreamhead.blogbus.com/logs/225006531.html\" target=\"_blank\">这个话题</a>我很早就说过。只是那时，我还没有意识到这种方式对于自己时间管理的转变。</p>\n<p>在《<a href=\"http://dreamhead.blogbus.com/logs/225006531.html\" target=\"_blank\">聊聊早起</a>》里，我提到过，现在我的工作大多是在早上完成。晚上回家大多数时间，我甚至连电脑都不开，而是陪着家人一起聊聊天，或是看看书。把更多的时间给了家人，有助于促进工作生活平衡。有不少工作优秀的人把大量的时间给了工作，结果影响了自己的生活。这样的失衡无论如何是不值得羡慕的。</p>\n<p>早起之后，我通常会有两个小时左右的时间，而且一般因为刚刚睡醒，注意力会非常集中，周边非常安静，无论是写代码还是写文章，都是很有好处的，我的大多数个人产出都是在这个阶段完成的。现在，只要有人问我时间管理，我第一个推荐的便是早睡早起，至少我知道的，有几个人已经开始这么做了，并且全部都反馈良好。</p>\n<p>除了早睡早起，还有一点，算是教训。有一个同事问我最近要做的事太多，怎么办。我的回复只有一个字“砍”。</p>\n<p>初入ThoughtWorks，大多数人会像刘姥姥进了大观园，但很多人也会迷失：太多各种各样的技术牛人，太多各种各样的技术，太多各种各样的活动，无论想学东西，还是想贡献，这里最不缺的就是机会。所以，如果你什么样的活动都想冒个头，结果就是被太多活动拖累了。</p>\n<p>我也对iOS开发感兴趣，我也想花时间写几个漂亮的界面，但你知道，我还想花时间写一个游戏，还想花时间实现自己的语言，但是，但是，我的时间只有这些，我能做的事情是有限的，唯一能做的就是把一些感兴趣的事情暂且放到一边，集中精力做好优先级最高的几件事，这个“几”越少越好。</p>\n<p>不用担心别人在那个方向已经跑了很远，这个世界总有人跑在你前面，而且事实上，没有在乎一只菜鸟的小跑。十万八千个“Hello,world”也换不回做成一件事得到的欣赏。</p>\n<p>写程序的时候，我们都知道要分离关注点，只是到做事的时候，就糊涂了。</p>\n<p>关于时间管理，还有一条经验：小步前进。在《<a href=\"http://dreamhead.blogbus.com/logs/122869402.html\" target=\"_blank\">新ThoughtWorker开发的头两件事</a>》里，我提到了一个非常重要的工作习惯：任务分解。</p>\n<p>我知道很多人，包括我自己以前也是，通常都是事一来，猛烈地冲刺，不把问题解决完誓不罢休，但这种做法通常会让整个人很疲惫。我现在的做法是把要做的事情先分解，如果不是特别着急，就慢慢来做。比如翻译书，我只要要求每天能够翻译两页，写开源只要求每天能有提交。冲刺的做法虽然单位时间产出大，但却很难坚持，小步前进虽然一天的量不大，但时间累积却也威力无穷。</p>\n<p>每天早起，过一下自己的任务列表，选取一项，动手做就好了。有时任务真的很简单，就是简单升级一下依赖。很多事情便这样坚持下来的，有人<a href=\"http://weibo.com/2192241300/zqrMUzgNC\" target=\"_blank\">在微博</a>上对<a href=\"https://github.com/dreamhead\" target=\"_blank\">我的github连续提交</a>产生了兴趣，这就是我个人在尝试的坚持。</p>\n<p>程序员不应该是青春饭，而可以成为一个终身职业，那么，我们要做的是可持续发展，我们在比拼不是一个时间点的产出，而是持续的产出。“一鼓作气，再而衰，三而竭”，那不是我追求的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201304010634",
    "date": "2013-04-01",
    "time": "06:34",
    "tags": [
      "推荐算法",
      "dropwizard",
      "脚下的路"
    ],
    "title": "Fedex Day",
    "body": "<p>不知道你是不是有这样的感觉，长时间工作在一个项目上，难免产生倦怠。还好，我们合作的不少客户会定期地挑出一个日子，给团队留下一个属于自己的空间，在那天我们可以抛开自己日常工作的代码，投入到自己的创新之中。也许你听说过Facebook有Hackathon，我以前参加过Innovation Day，而这次，我们叫Fedex Day。无论叫什么，它就是我们程序员的节日。</p>\n<p>既然是创新，我们当然会选择一个之前没有尝试过的方向。于是，这次我们项目组Fedex Day把目标定为推荐系统。这是我们一直想做，但没有机会动手的项目。因为我们是一个后台的项目组，保存用户数据，根据用户的一些购买信息，做出进一步推荐在这个大数据时代是一件顺理成章的事情。</p>\n<p>当然，因为只有一天的时间，做一个复杂的推荐系统是一件不可能的事情，所以，我们就选择了一个非常简单的应用，根据客户已经购买的品牌，为他推荐他可能感兴趣的品牌。</p>\n<p>如果你对推荐算法不熟悉，这可能会让你觉得是件有难度的问题，但实际上，具体做法极其简单。我们只要计算两个品牌的相似度即可，那相似度又从何而来呢？最简单的相似度算法是这样的：</p>\n<p>&nbsp; 同时购买两个品牌的顾客数量（交集）/分别购买了两个品牌顾客的数量（并集）</p>\n<p>这样会得到一个0-1之间的小数，这个数越接近1，就说明两个品牌的相似度越高，反之则低。虽然它很简单，但它也有个自己的名字叫<a href=\"http://en.wikipedia.org/wiki/Jaccard_index\" target=\"_blank\">Jaccard index</a>，或者Jaccard similarity coefficient。</p>\n<p>剩下的事情就很简单，把用户没有购买的品牌和用户已经购买的品牌一一计算相似度，然后，把相似度累加起来起来，然后，排个序把得分最高的几个推荐出来就好了。</p>\n<p>这次Fedex Day，除了应用本身，我们还想展示一下技术发展方向。所以，我们采用ThoughtWorks技术雷达上提到的内置容器、微服务架构等。其实，这么做也很简单，因为现在已经有很好的框架支持这些，它就是<a href=\"http://dropwizard.codahale.com/\" target=\"_blank\">DropWizard</a>，这是源自<a href=\"https://www.yammer.com/\" target=\"_blank\">Yammer</a>的一个项目，让你用更现代的风格编写Java应用。</p>\n<p>剩下的事情就是疯狂的编码了。好久没有这么爽快地编码了，六个人组成的项目组，开工之前，大家在白板前面，把任务做了一次划分，各自领了自己想做的一块功能，噼里啪啦地动手写起来。当夜幕降临，我们在音乐的伴奏之下写着代码，那种感觉，痛快。当我们历经千辛万苦，终于让整个系统运行起来时，那种成就的快感充斥在每个人的身上。</p>\n<p>我爱Fedex Day，虽然之后很疲惫，但这种能够激发团队创造力的活动，足以唤醒每个程序员初涉编程的那种热情。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201303181804",
    "date": "2013-03-18",
    "time": "18:04",
    "tags": [
      "jackson"
    ],
    "title": "Jackson雕虫技（二）",
    "body": "<p><strong>定制解析</strong></p>\n<p>前面我们看到了，在Moco配置文件里，我们可以支持text匹配，但是，目前Moco还支持下面这种结构：</p>\n<p>{<br>&nbsp; \"request\": {<br>&nbsp; &nbsp; \"text\": {<br>&nbsp; &nbsp; &nbsp; \"match\": \"foo\\\\w*bar\"<br>&nbsp; &nbsp; }<br>&nbsp; },<br>&nbsp; \"response\": {<br>&nbsp; &nbsp; \"text\": \"match\"<br>&nbsp; }<br>}</p>\n<p>这里的做法是支持正则表达式的匹配，因为text后面跟的是一个对象，不再是一个字符串，所以，原来声明为String的做法就不起作用了。Moco目前的解决方式是采用了自定义解析的方式，在Jackson里，称之为JsonDeserializer。</p>\n<p>首先，我们定义对象，包含对直接字符串和带操作符对象的支持：</p>\n<p>public class TextContainer {<br>&nbsp; &nbsp; private String text;<br>&nbsp; &nbsp; private String operation;<br>&nbsp; &nbsp; ...<br>}</p>\n<p>然后，为其定义一个JsonDeserializer，专用于解析TextContainer，代码如下：</p>\n<p>public class TextContainerDeserializer extends JsonDeserializer {<br>&nbsp; &nbsp; @Override</p>\n<p>&nbsp; &nbsp; public TextContainer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {<br>&nbsp; &nbsp; &nbsp; &nbsp; JsonToken currentToken = jp.getCurrentToken();<br>&nbsp; &nbsp; &nbsp; &nbsp; if (currentToken == JsonToken.VALUE_STRING) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new TextContainer(jp.getText().trim(), null);<br>&nbsp; &nbsp; &nbsp; &nbsp; } else if (currentToken == JsonToken.START_OBJECT) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JsonToken jsonToken = jp.nextToken();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (jsonToken == JsonToken.FIELD_NAME) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String operation = jp.getText().trim();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jp.nextToken();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String text = jp.getText().trim();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jp.nextToken();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new TextContainer(text, operation);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; throw ctxt.mappingException(TextContainer.class, currentToken);<br>&nbsp; &nbsp; }<br>}</p>\n<p>如果你熟悉解析器的一点技巧，便不难理解，我们得到了一个个Token，然后，根据自己需要进行解析。实际上，我们就是参与到解析的过程中去了。从这段代码，可以看到，如果是一个字符串（JsonToken.VALUE_STRING），则TextContainer里的operation字段为null，如果是一个对象（JsonToken.START_OBJECT），则要把字段（JsonToken.FIELD_NAME）内文本和操作都解析出来。这里唯一需要提醒的点是最后一个jp.nextToken()，从这段代码本身它并没有任何意义，实际上，它处理的是END_OBJECT（“}”）。在Jackson的处理中，每一个JsonDeserializer都要把自己涉及到的Token用光，否则会影响进一步处理的。</p>\n<p>有了JsonDeserializer，接下来就是使用它了。我们可以在字段上使用Annotation进行标记。</p>\n<p>public class RequestSetting {<br>&nbsp; &nbsp; @JsonDeserialize(using = TextContainerDeserializer.class)<br>&nbsp; &nbsp; private TextContainer text;<br>&nbsp; &nbsp; ...<br>}</p>\n<p>如果我们只有一个字段用到这个类型，这种做法或许是可以接受的。但如果有大量字段用这个类型，我们就要用一种全局的方式来处理了。在Jackson里，这种方式成为Module：</p>\n<p>&nbsp; Module textContainerModule = new SimpleModule(\"TextContainerModule\",<br>&nbsp; &nbsp; new Version(1, 0, 0, null, null, null))<br>&nbsp; &nbsp; .addDeserializer(TextContainer.class, new TextContainerDeserializer());<br>&nbsp; mapper.registerModule(textContainerModule);</p>\n<p>如此一来，只要是TextContainer类型，就会使用我们的TextContainerDeserializer进行处理了，省去了一处一处配置的繁琐。</p>\n<p><strong>比较JSON</strong></p>\n<p>Moco里有一个操作符，用以比较请求是否是预期的JSON请求。由于空格、Tab、回车换行等字符的存在，两个JSON对象是否相等，不能仅靠字符串的比较。一种比较方案是，将两个流都读成内存对象进行比较，类似于XML中的DOM。在Jackson里，读出的是一棵树：</p>\n<p>&nbsp; JsonNode requestNode = mapper.readTree(requestStream);<br>&nbsp; JsonNode resourceNode = mapper.readTree(targetStream);<br>&nbsp; return requestNode.equals(resourceNode);</p>\n<p>在这段代码里，只要两个JsonNode相等，它们就是相等的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201303171759",
    "date": "2013-03-17",
    "time": "17:59",
    "tags": [
      "jackson"
    ],
    "title": "Jackson雕虫技（一）",
    "body": "<p><a href=\"http://jackson.codehaus.org/\" target=\"_blank\">Jackson</a>是一个高性能JSON处理器，堪称目前Java世界处理JSON的首选。在<a href=\"https://github.com/dreamhead/moco\" target=\"_blank\">Moco</a>里，JSON文件的处理就是用它来做的。下面就以Moco处理中用到几点技巧介绍一下Jackson。</p>\n<p><strong>读取对象</strong></p>\n<p>采用Jackson的databind包，可以很容易地将一个JSON流映射为一个Java对象。下面是一个JSON流：</p>\n<p>{<br>&nbsp; \"request\": {<br>&nbsp; &nbsp; \"text\": \"foo\"<br>&nbsp; },<br>&nbsp; \"response\": {<br>&nbsp; &nbsp; \"text\": \"bar\"<br>&nbsp; }<br>}</p>\n<p>我们要把它映射为下面的对象：</p>\n<p>@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)<br>public class SessionSetting {<br>&nbsp; private RequestSetting request;<br>&nbsp; private ResponseSetting response;<br>&nbsp; ...<br>}</p>\n<p>@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)<br>public class RequestSetting {<br>&nbsp; private String text;<br>&nbsp; ...<br>}</p>\n<p>@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)<br>public class ResponseSetting {<br>&nbsp;private String text;<br>&nbsp; ...<br>}</p>\n<p>通过下面这段代码就可以完成映射：</p>\n<p>&nbsp; ObjectMapper mapper = new ObjectMapper();<br>&nbsp; SessionSetting setting = mapper.readValue(inputStream, SessionSetting.class);</p>\n<p>上面代码中的映射几乎一对一的，很好理解，唯一需要解释是每个类上的声明</p>\n<p>&nbsp; @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)</p>\n<p>这声明了字段可见性，如果不做任何声明，缺省情况下需要给每个字段增加一个getter，才能完成映射。</p>\n<p><strong>读取集合</strong></p>\n<p>目前Moco配置文件里实际上是一组Session配置，也就是一个JSON数组对象：</p>\n<p>[<br>{<br>&nbsp; \"request\": {<br>&nbsp; &nbsp; \"text\": \"foo\"<br>&nbsp; },<br>&nbsp; \"response\": {<br>&nbsp; &nbsp; \"text\": \"bar\"<br>&nbsp; }<br>}<br>]</p>\n<p>众所周知，JVM的范型是假范型，所以，下面的代码不起作用</p>\n<p>&nbsp; mapper.readValue(inputStream, List.class);</p>\n<p>当然，Jackson给我们提供了其它的方式读取集合，下面就是：</p>\n<p>&nbsp; TypeFactory factory = TypeFactory.defaultInstance();<br>&nbsp; mapper.readValue(is, factory.constructCollectionType(List.class, SessionSetting.class));</p>\n<p><strong>忽略字段</strong></p>\n<p>在Moco的配置文件里，我们可以用description描述一个配置的作用，其实，它就是一个注释，在实际的代码里没有任何作用。我们当然像下面这么做，把它读到内存里：</p>\n<p>public class SessionSetting {<br>&nbsp; private String description;<br>&nbsp; ...<br>}</p>\n<p>但Jackson给我们提供了更好的做法：</p>\n<p>@JsonIgnoreProperties({ \"description\" })<br>public class SessionSetting {<br>&nbsp; ...<br>}</p>\n<p>这样一来，连运行时的内存占用都省了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201303060719",
    "date": "2013-03-06",
    "time": "07:19",
    "tags": [
      "重构"
    ],
    "title": "实践中的重构",
    "body": "<p>重构，早就不再是“奢侈品”，而是“日用品”。纵然如此，在自己的工作过程中，还是听到很多关于重构的误解。</p>\n<p>首先，<strong>重构是日常工作</strong>。</p>\n<p>许多人问过我这样的问题，要不要拿出专门的时间做重构。作为一个程序员，重构就应该和写代码、写测试一样，是我们日常工作的一部分，只要你写代码，就应该重构。特别是当你在做TDD的时候，如果你只写测试，编代码通过，对不起，那根本不叫TDD，那叫测试先行。目前为止，我还没有见过一个程序员，包括我自己在内，写代码是一遍就写得非常整洁，无需重构的。通常都是第一遍写出的代码只能实现功能，然后，把它重构得符合整洁的要求。这里要说的重点是，别讨论专门拿时间做重构，那就是你日常工作的一部分。</p>\n<p>我知道为什么会有人问出这样的问题，这就是接下来要说的：<strong>重构不是重写</strong>。</p>\n<p>对于很多人来说，他嘴上说的是重构，心里想的是重写，所以，这事很大，不是一蹴而就的，所以，要专门划拨时间来做。重写，事确实不小。但也是有技巧可言的。我们这里所说的重写，不是整个系统的重写，那专门立项就好了，这里所说的是要调整项目的某个模块，或是某个设计。</p>\n<p>一旦设计到调整，实际上是对整个项目组编码风格的一种影响，因为影响比较大，所以，可以考虑以技术债的形式在项目组内部提出来。如果项目组内达成共识，并且业务人员也同意给这件事留出时间，那就可以着手来做了。想要说服业务人员，最好是告诉他们，花多长时间做这件事，能给未来省下多少时间。即便所有人都同意这个调整的方案，真正在实施的时候，我们也需要按照重构的思路来做，这也是需要一些功夫的。</p>\n<p><strong>没有测试的重构就是耍流氓</strong>。</p>\n<p>对于ThoughtWorks内部的项目，测试多还是有保障的，但我周游天下时亲眼见过一些没有测试的巨大代码库，我能说的，赶紧花时间为你要写的代码补一些测试，然后再说重构的事。</p>\n<p>具体到动手重构了，标准只有一个：<strong>重构可以</strong><strong>随时随地</strong><strong>停下来，不破坏任何测试</strong>。</p>\n<p>这话说得很容易，但真要做到可绝非轻而易举。我看到很多大动干戈的修改，中间无法停下，一旦发觉不对，只好推翻重来。我只能说，对于重构，这种做法只是理解了形，并不理解神。站着说话不要疼，事实上，我个人对重构的理解也是看到了有人用小步重构把一段代码逐步改好之后，震惊之余，才理解原来重构应该这样做。要知道，我也曾经是大刀阔斧之辈，那一刻，我皈依于小步重构。</p>\n<p><strong>小步重构，是需要刻意练习的</strong>。我是花了不少时间去练习，才能做出一些当初见到的重构效果。时至今日，我依然不敢说自己有十足的把握能够小步重构每一段丑陋的代码，内心中总有一种躁动，想一路劈杀过去，只能不断与自己说，慢点，别急。</p>\n<p>对于ThoughtWorker而言，内部总是有这样机会见到小步重构，对于外部的人来说，经常参加ThoughtWorks的活动，应该也可以见到这种做法。</p>\n<p>重构易，程序员人人知重构，重构难，做好重构者寥寥无几。无它，刻意练习。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201302250734",
    "date": "2013-02-25",
    "time": "07:34",
    "tags": [
      "Moco",
      "OpenParty"
    ],
    "title": "在成都Open Party讲Moco",
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/192363088.html\" target=\"_blank\">时隔一年</a>，我又参加了成都的Open Party。这次参加Open Party，我带的主题是Moco。</p>\n<p>Moco最近发展得不错。多谢<a href=\"http://gigix.thoughtworkers.org/\" target=\"_blank\">gigix</a>，已经有第一个实际的商业项目开始使用Moco，他不断给我提出新的需求，最近一段时间，我每天忙不停地给Moco写新代码。我也越来越觉得，Moco开始告别我一个人的自娱自乐阶段，应该与更多人分享。于是，我决定在社区活动里做一次Moco的分享。</p>\n<p>分享总是有益的，当你把自己的东西抛出去，就会有人把他的想法抛给你。这不，有人给Moco提出了新特性。</p>\n<p>一个特性是延迟，也就是让服务器等待一段时间返回，用以模拟服务器的慢速操作。这是第二次有人给我提出这个想法，我认为这个需求真的是有必要了。鉴于这个特性实现了起来很简单，我已经完成了编程工作，提交到代码库里了。</p>\n<p>另一个特性是支持Socket。现在Moco只支持HTTP，因为在我目前的工作里，这是优先级最高的。在这次活动之后，分别有两个人与我交流时都提到了Socket模拟的想法。在一些游戏项目里，对于性能的要求很高，Socket是一个比HTTP更好的选择。我已经把Socket列到了我的TODO列表里，只是目前而言，我还需要更多的需求以确定Socket模拟该如何表现。</p>\n<p>在分享之后，有人问了一些有趣的问题。</p>\n<p>有人关心Moco启动飞快的原因，底层用了哪个库。目前Moco底层用的<a href=\"http://netty.io/\" target=\"_blank\">Netty</a>，JBoss的一个异步IO库，类似的库还有<a href=\"http://grizzly.java.net/\" target=\"_blank\">grizzly</a>和<a href=\"http://mina.apache.org/\" target=\"_blank\">Mina</a>。虽然Moco支持的HTTP，但我并没有选择Tomcat或Jetty，从Moco提供的接口可以看到，我实在是不需要Sevlet那层抽象。也是因为省去了一层抽象的原因，启动速度自然就是飞快了。Netty本身是一个更底层的库，未来支持Socket的话，也可以拿来就用。</p>\n<p>有人问是不是ThoughtWorks是不是给我专门的时间写开源项目。上班时间肯定主要是给客户写代码，那我的时间从何而来。关于这个问题，最好的回答是之前的一篇blog《<a href=\"http://dreamhead.blogbus.com/logs/225006531.html\" target=\"_blank\">聊聊早起</a>》。现在每天在5点半左右起床，上班之前大约会有一个半到两个小时做一些自己要做的事情。每天坚持下来，就会是一笔很好的时间财富。我现在基本上也是把这个做法作为一种最佳实践推荐给身边的许多人，我知道，已经有人开始从中受益了。</p>\n<p>把自己的东西拿出来，别人会回馈给我们更多，这就是社区分享的好处。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201302231240",
    "date": "2013-02-23",
    "time": "12:40",
    "tags": [
      "Moco"
    ],
    "title": "Hello，Moco（番外篇之前端开发）",
    "body": "<p>你可以创造一个东西，至于它怎样发展，那就不是你所能预期的了。</p>\n<p>Moco里面有这样一个特性，把一个目录下的所有文件挂到一个特定的URI下。其用法如下：</p>\n<p>server.mount(\"dir”, to(”/site”);<br>（API）</p>\n<p>{<br>&nbsp; \"mount\" :&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"dir\" : \"dir\",<br>&nbsp; &nbsp; &nbsp; \"uri\" : \"/site\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>这么做的初衷是简化一组文件的挂接过程。不过，出人意料的是，有人把这个功能用在了web前端的开发上。</p>\n<p>下面是一个简化过的moco配置文件：<br>[<br>{<br>&nbsp; &nbsp; \"mount\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"dir\" : \"site\",<br>&nbsp; &nbsp; &nbsp; &nbsp; \"uri\" : \"/\"<br>&nbsp; &nbsp; }<br>},<br>{<br>&nbsp; &nbsp; \"request\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"uri\" : \"/api\"<br>&nbsp; &nbsp; },<br>&nbsp; &nbsp; \"response\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; }<br>}<br>]<br>(site.json)</p>\n<p>可以看到，我们把site目录挂到了web站点的根目录下，此外，还模拟了一个/api的服务，返回foo。然后，把jquery文件放到site目录下，并在里面写一个index.html：</p>\n<p>&lt;html&gt;<br>&lt;head&gt;<br>&nbsp; &lt;script src=\"jquery-1.9.1.min.js\"&gt;&lt;/script&gt;<br>&nbsp; &lt;script&gt;<br>&nbsp; $(function() {<br>&nbsp; &nbsp; $(\"button\").click(function() {<br>&nbsp; &nbsp; &nbsp; $.get(\"/api\", function(data, textStatus) {<br>&nbsp; &nbsp; &nbsp; &nbsp; $(\"p\").text(data);<br>&nbsp; &nbsp; &nbsp; })<br>&nbsp; &nbsp; });<br>&nbsp; });<span style=\"white-space: pre;\">\t</span><br>&nbsp; &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><span style=\"white-space: pre;\">&nbsp; </span>&lt;p&gt;Hello,World&lt;/p&gt;<br><span style=\"white-space: pre;\">&nbsp; </span>&lt;button type=\"button\"&gt;Click&lt;/button&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>（index.html）</p>\n<p>从这段html代码我们可以看出，当点击按钮时，它会请求到/api这个uri，然后将请求回来的内容更新上去。正如我们所见到的，实际上，没有一个真正/api服务，只是由moco模拟了一个服务而已。把它运行起来：</p>\n<p>&nbsp; java -jar moco-runner--standalone.jar -p 12306 site.json</p>\n<p>当我们用浏览器打开这个页面时，点击按钮，我们会看到文字改变了。</p>\n<p>通过这个简单的例子，我们便不难理解Moco对于前端开发上的作用了，它启动一个真正的web服务器，使我们正在编写的页面起作用，然后，使用真正的ajax调用去访问后台服务，而Moco会可以将不存在的服务模拟出来。</p>\n<p>这么做的好处在于，所有的动态交互部分都是真的。如果在项目前期，开发一个原型验证有效性，做出的包括CSS和JavaScript都是具有真正功能的，在正式开发开始时，可以直接移植到项目里面。这样，也就给了那些不熟悉后端的前端开发人员一个机会，做出具有真正效果的原型。</p>\n<p>Moco还能怎么用呢？我们拭目以待。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201302120720",
    "date": "2013-02-12",
    "time": "07:20",
    "tags": [
      "Java",
      "函数式编程",
      "Guava"
    ],
    "title": "一篇Java函数式编程文章的讨论",
    "body": "<p>网上有一篇文章讨论Java函数式编程：</p>\n<p><a href=\"http://cafe.elharo.com/programming/java-programming/why-functional-programming-in-java-is-dangerous/\" target=\"_blank\">英文版</a><br><a href=\"http://www.csdn.net/article/2013-01-22/2813848-functional-programming-java\" target=\"_blank\">中文版</a></p>\n<p>里面有一道很简单的题，计算前25个自然数的平方。用最简单的Java实现大概是这个样子：</p>\n<p>for (int i=1; i&lt;=25; i++)<br>&nbsp; &nbsp; System.out.println(i*i);<br>}</p>\n<p>不过，这篇文章要用函数式风格实现，其总结的大意是说，Java不适合函数式编程。暂且不论Java究竟适不适合函数式编程，但以这篇文章里的例子来说，作者给出的实现却算不上一个好的实现，虽然，这可能是以传统Java编程思路写程序经常的做法。</p>\n<p>说白了，原文实现真正的问题在于没有实现“惰性”，就这个程序而言，这是一种极其糟糕的做法，把所有内容——尤其是根本用不到的部分全部实现出来，内存似乎是在正常不过的了。这一点在原文的评论里也有体现，有人就给出了基于Iterator的实现，很巧妙地用它引入了“惰性”。</p>\n<p>不过，那个实现是基于JDK来做的，略显笨拙。正如之前《<a href=\"http://dreamhead.blogbus.com/logs/226738702.html\" target=\"_blank\">你应该更新的Java知识之常用程序库（一）</a>》中提到的，只要你做Java项目，就应该用Guava。有了Guava的基础设施，这个小程序也可以变得更简洁一些：</p>\n<p>import com.google.common.base.Function;<br>import com.google.common.collect.AbstractIterator;</p>\n<p>import java.util.Iterator;</p>\n<p>import static com.google.common.collect.Iterables.limit;<br>import static com.google.common.collect.Iterables.transform;</p>\n<p>public class Square {<br>&nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; for (Integer integer : limit(squreOf(integers()), 25)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(integer);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; private static Iterable integers() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return new Iterable() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Override<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public Iterator iterator() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new AbstractIterator() {</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private int i = 1;</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Override<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; protected Integer computeNext() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i == Integer.MAX_VALUE) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endOfData();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i++;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; };<br>&nbsp; &nbsp; }</p>\n<p>&nbsp; &nbsp; private static Iterable squreOf(Iterable numbers) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return transform(numbers, new Function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Override<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public Integer apply(Integer input) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return input * input;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; });<br>&nbsp; &nbsp; }<br>}</p>\n<p>如果你对Guava不熟悉，这里有两个点需要稍微解释一下。</p>\n<p>首先是integers函数中用到的AbstractIterator，它让我们实现Iterator更简洁了，我们只要关注于下一个元素生成的逻辑即可，余下的交给它处理了。在这里，我们调用了endOfData表示迭代器结束，实际上，就这个应用而言，它没有起到实际的作用，因为没有取到那么多的元素，但这里提示我们一个做法，只要不调用endOfData，这个Iterator就不算结束，换句话说，用我们可以一直生成下一个元素，这也就成了传说中的无限序列，这可是很多函数式编程语言经常拿出来炫耀的点。</p>\n<p>另外一点要说的是，transform（在squareOf里）和limit（在main函数里），如果你稍微了解一点函数式编程，它俩分别对应map和take，只不过在Guava中给了它们不同的名字而已，它们给了我们一个机会操作序列。实际上，在Guava里，这样的函数还有很多，比如filter，find等等。事实上，它们大多是“高阶函数”，也就是可以接收函数或是返回函数。通过这些基本操作加上传入函数的组合，我们可以创造出更华丽的组合。</p>\n<p>Java函数式编程并非不可为，但这会是一个极大的思路转变。至于Guava，还是那句话，只要你做Java项目，就应该用Guava。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201301161321",
    "date": "2013-01-16",
    "time": "13:21",
    "tags": [
      "构建工具",
      "gradle",
      "buildr",
      "maven",
      "ant",
      "你应该更新的Java知识"
    ],
    "title": "你应该更新的Java知识之构建工具",
    "body": "<p>时至今日，如果你的Java项目依然需要启动一个特定的工具，比如IDE，才能编译部署，那你的项目不在本文的讨论之中，因为实在落后得太让人无语了。</p>\n<p>好，回归正题。旧时代的Java世界，构建工具等同于两个词<a href=\"http://ant.apache.org/\" target=\"_blank\">Ant</a>和<a href=\"http://maven.apache.org/\" target=\"_blank\">Maven</a>。</p>\n<p>Ant源自Make，同JUnit一样，它也是一个航班产物（参见《<a href=\"http://book.douban.com/subject/1243881/\" target=\"_blank\">Ant权威指南</a>》序）。不过，Make的基础注定了它的起点不高，所有一切都要手工打造。我还依稀记得曾几何时，每每开始一个项目都要重新复制一份Ant脚本，修修改改。Maven给了人们新的希望，目录结构的约定、依赖管理、IDE集成，那时看来，几近完美。是的，几近，还差了那么一点点。就是那么一点点，却是致命伤。</p>\n<p>只要一个项目进行一段时间，一个必然遇到的问题就是，编写新的自动化脚本。因为每个项目都有自己的特定需求，标准做法必然是无法满足的。扩展Maven对任何新手都是一件头疼的事，我们要学会编写插件，要搞清楚生命周期，这时，突然会唤起一丝丝对于ANT的怀念，虽然它做简单事不容易，但做复杂事却也没这么困难。</p>\n<p>如果那些日子，我们不得不忍受Ant和Maven的不完美，那现在，是时候抛弃它们了。新时代Java构建有两个很好的候选：<a href=\"http://www.gradle.org/\" target=\"_blank\">Gradle</a>和<a href=\"http://buildr.apache.org/\" target=\"_blank\">Buildr</a>。在我看来，它们真正比Maven更强大的地方，编写自己的任务更加容易。更值得兴奋的一点是，我们终于可以抛弃冗长的XML，选择一种更优雅的程序设计语言来写代码了，这几乎意味着你可以做到想做的一切。</p>\n<p>Buildr是Apache出品的构建工具，它以Ruby作为构建脚本。我曾在InfoQ发表过一篇很长的文章《<a href=\"http://www.infoq.com/cn/articles/zy-software-development-foundation\" target=\"_blank\">软件开发地基</a>》，讨论软件项目应该具备一些基础构建项，就是以Buildr为基础的。有兴趣的话，可以参考一下。这里就不再赘述。顺便说一下，那篇文章里的内容，除了某些写法现在需要做一些微调，大部分内容依然是适用于大多数Java项目。</p>\n<p>Gradle现在是整个Java社区的构建新宠，它采用Groovy作为自己的构建语言。如果你知道，<a href=\"http://groovy.codehaus.org/\" target=\"_blank\">Groovy</a>是一门诞生自JVM平台的语言，这就决定了它要比其它移植到JVM上的语言能更好的适应JVM平台，它可以采用更符合Java世界的方式无缝地整合Java既有的程序库，而不必像移植语言那样削足适履。</p>\n<p>初涉Gradle，最让人吃惊的一点莫过于它<a href=\"http://www.gradle.org/documentation\" target=\"_blank\">详尽的文档</a>，涵盖了Gradle使用的方方面面，这是许多开源软件项目无法媲美，即便早在它的1.0版本尚未发布之时。当然，能做到这一点是因为它背后有一个公司在支撑：<a href=\"http://www.gradleware.com/\" target=\"_blank\">GradleWare</a>，这意味着如果你需要商业支持，也是可以的。</p>\n<p>Gradle 1.0尚未发布之，它就捧回<a href=\"http://www.springsource.org/node/2871\" target=\"_blank\">2010年的Spring大奖</a>和<a href=\"http://jax-awards.com/finalists.html\" target=\"_blank\">入围了2011年</a>的<a href=\"http://jax-awards.com/\" target=\"_blank\">JAX大奖</a>。如果你还需要更多的信心，作为Java开发人员，你不可能不知道Spring，那<a href=\"http://www.infoq.com/cn/news/2012/11/spring-osgi-gradle\" target=\"_blank\">Spring转投Gradle怀抱</a>，应该是对Gradle最有利的支持了。</p>\n<p>说了这么多，程序员最喜欢看到的东西还是代码。首先，请自行下载安装Gradle，然后，按照常见的Java项目布局把代码准备好（感谢Maven为我们给予我们约定），比如：</p>\n<ul>\n<li>src/main/java，源代码文件目录</li>\n<li>src/main/resources，资源文件目录</li>\n<li>src/test/java，测试代码目录</li>\n</ul>\n<p>下面是一个简单的Gradle构建脚本，将其存放于build.gradle</p>\n<p>apply plugin: 'java'</p>\n<p>repositories {<br>&nbsp; &nbsp; mavenCentral()<br>}</p>\n<p>dependencies {<br>&nbsp; compile(<br>&nbsp; &nbsp; 'com.google.guava:guava:13.0.1',<br>&nbsp; &nbsp; 'joda-time:joda-time:2.1'<br>&nbsp; )</p>\n<p>&nbsp; testCompile(<br>&nbsp; &nbsp; 'junit:junit:4.10',<br>&nbsp; &nbsp; 'org.mockito:mockito-all:1.9.0'<br>&nbsp; )<br>}<br>（build.gradle）</p>\n<p>接下来的事情就很简单了，在命令行里键入</p>\n<p>&nbsp; gradle build</p>\n<p>如果一切正常，我们应该会看到构建成功的字样，然后，到build/lib，你就看到自己构建出来的JAR文件了。当然，这只是一个简单得不能再简单的例子，如果需要了解更多，<a href=\"http://www.gradle.org/documentation\" target=\"_blank\">Gradle那详尽的文档</a>便是最好的去处。</p>\n<p>关于构建工具的选择考量，我曾经写过一篇blog专门讨论，《<a href=\"http://dreamhead.blogbus.com/logs/117917683.html\" target=\"_blank\">选择，构建工具</a>》。如果你在做构建工具的技术选型，可以参考。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201301130836",
    "date": "2013-01-13",
    "time": "08:36",
    "tags": [
      "travis-ci",
      "github",
      "gradle"
    ],
    "title": "Hello，Travis CI",
    "body": "<p>Travis CI，是一个专门为开源项目打造的持续集成环境。</p>\n<p>如果你有一个放在github上的开源项目，Travis CI简直就是一个完美的CI选择。下面以<a href=\"https://github.com/dreamhead/moco\" target=\"_blank\">Moco</a>为例，说明如何在自己的项目里添加Travis CI支持。</p>\n<p>实际上，只要采用的是“标准工具”，支持Travis CI就简单得一塌糊涂。第一步，我们要在自己项目的根目录下添加一个文件.travis.yml。</p>\n<p>language: java<br>jdk:<br>&nbsp; - oraclejdk7<br>&nbsp; - openjdk7<br>&nbsp; - openjdk6<br>（.travis.yml）</p>\n<p>很容易理解，首先，我们告诉Travis CI，我们的语言是什么。这样，它会根据你的语言为你选择构建工具。对于Moco而言，构建工具是<a href=\"http://www.gradle.org/\" target=\"_blank\">gradle</a>，这是Java世界的新标准了，Travis CI会自动识别出来，我不需要额外告诉它什么。当然，它为Java项目支持的另外两个选择是<a href=\"http://maven.apache.org/\" target=\"_blank\">Maven</a>和<a href=\"http://ant.apache.org/\" target=\"_blank\">Ant</a>。如果你的项目是不同的语言，可以参考<a href=\"http://about.travis-ci.org/docs/user/getting-started/\" target=\"_blank\">Travis CI的文档</a>，找到适合自己的配置。</p>\n<p>接下里的JDK是要告诉Travis CI，我要在哪些环境下测试。比如这里用了三个JDK，分别是Oracle JDK 7、OpenJDK 7和OpenJDK 6。这样一来，当我们提交代码时，Travis CI会在三个不同环境运行我们的测试，以此保证项目的版本兼容。</p>\n<p>此外，还要额外说一下，它是如何选择运行目标的。对于Moco这样提供了Gradle支持的项目，Travis CI缺省情况下会执行gradle check，这是Gradle进行检查的缺省做法，它会编译源文件、处理资源文件、运行测试等等。在运行这个任务之前，Travis CI还会运行gradle assemble用以安装项目中用到的依赖。所有这些都是可以修改的，可以参考了Travis CI的<a href=\"http://about.travis-ci.org/docs/user/build-configuration/\" target=\"_blank\">构建配置文档</a>。</p>\n<p>有了这个脚本还不够，我们还要让Travis CI知道我们的项目，用自己的github账号登录Travis CI。经过认证之后，选择自己的账号配置，你会看到自己的所有的开源项目都列在那里。如果没有看到项目，请自行同步（Sync Now）。剩下的就很简单了，把要支持的Travis CI项目从OFF状态拨成ON。实际上，Travis CI是给github设置一个钩子。当有代码提交上来的时候，它会告诉Travis CI，Travis CI就可以开始构建了。</p>\n<p>好，设置完毕，尝试提交代码吧！当代码提交到github上之后，你应该可以看到你的项目开始构建了。哦，对了，项目的Travis CI地址应该等同于github上项目的地址，比如，Moco的github地址是</p>\n<p>&nbsp; <a href=\"https://github.com/dreamhead/moco\" target=\"_blank\">https://github.com/dreamhead/moco</a></p>\n<p>它的Travis CI地址就是</p>\n<p>&nbsp; <a href=\"https://travis-ci.org/dreamhead/moco\" target=\"_blank\">https://travis-ci.org/dreamhead/moco</a></p>\n<p>最后，再来一个小技巧，为了让别人知道我们项目和Travis CI有关系，我们可以在自己项目的README上给出Travis CI的构建标识。在你的Travis CI项目页面上，你应该可以找到一个配置选项。写下本文时，它就是右上角那个小齿轮，里面有个Status Images。根据自己README格式选择一个，粘贴到README文件里。</p>\n<p>好，大功告成，我们的开源项目也有了自己的CI。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201301031516",
    "date": "2013-01-03",
    "time": "15:16",
    "tags": [
      "Java",
      "程序库",
      "hamcrest",
      "mockito",
      "slf4j",
      "logback",
      "你应该更新的Java知识"
    ],
    "title": "你应该更新的Java知识之常用程序库（二）",
    "body": "<p><strong>Hamcrest</strong></p>\n<p>一句话，如果你写单元测试，就应该用<a href=\"http://hamcrest.org/\" target=\"_blank\">Hamcrest</a>。</p>\n<p>如今不写单元测试，你都不好意思说自己在做工程项目了。但你一般这么写断言呢？如果你还写成下面这样，我只能说你落伍了：</p>\n<p>&nbsp; assertEquals(a, b);</p>\n<p>请告诉我，哪个是执行结果，哪个是预期结果，不管你是怎样，反正大多数情况下，我是记不住的。所以，这个在只重功能不重可读性年代产生的API该更新了。于是，Hamcrest就是为了解决这样的问题而生的。</p>\n<p>&nbsp; assertThat(a, is(b));</p>\n<p>很明显，前面一个是执行结果，后面一个是预期结果，当然这只是一个简单的例子。由于Hamcrest引入了matcher的概念（就是你看到的is部分），我们可以进行更多的组合：</p>\n<p>&nbsp; assertThat(number, greaterThan(5));<br>&nbsp; assertThat(text, startsWith(\"Hello\"));<br>&nbsp; assertThat(array, hasItem(\"World\"));</p>\n<p>Hamcrest如此好用，以至于JUnit已经将其吸纳进去。如果你现在用的JUnit是4.4之后的版本，那你已经有了Hamcrest。无需额外的配置，就可以拿过来用。</p>\n<p><strong>Mockito</strong></p>\n<p>写单元测试不用Mock框架几乎是一件不可能的事，我是说Mock框架，不是Mock模式哦！对于老Java程序员来说，提起Mock框架，率先在脑海中撞线的多半是<a href=\"http://jmock.org/\" target=\"_blank\">JMock</a>或<a href=\"http://www.easymock.org/\" target=\"_blank\">EasyMock</a>。</p>\n<p>使用<a href=\"http://code.google.com/p/mockito/\" target=\"_blank\">Mockito</a>，只要有一个理由就够了，简单。相比于JMock，它不用写checking，相比于EasyMock，它省去了replay。下面是个例子：</p>\n<p>&nbsp; List mockedList = mock(List.class);<br>&nbsp; when(mockedList.get(0)).thenReturn(\"first\");<br>&nbsp; System.out.println(mockedList.get(0));</p>\n<p>当然，<a href=\"http://docs.mockito.googlecode.com/hg/latest/org/mockito/Mockito.html\" target=\"_blank\">Mockito还是非常强大的</a>。</p>\n<p>最后再强调一遍，无论使用哪个框架，请尽量不要使用verify，也就是传说中的Mock模式，那是把代码拉入泥潭的开始。</p>\n<p><strong>SLF4J和Logback</strong></p>\n<p>日志几乎是稍微有点规模的项目躲不开的一个东西，如果你是个老Java程序员，你必然知道<a href=\"http://logging.apache.org/log4j/\" target=\"_blank\">Log4J</a>，多半也知道<a href=\"http://commons.apache.org/logging/\" target=\"_blank\">Commons Logging</a>。是时候把它们扔掉了，因为有<a href=\"http://www.slf4j.org/\" target=\"_blank\">SLF4J</a>和<a href=\"http://logback.qos.ch/\" target=\"_blank\">Logback</a>了。SLF4J要替代Commons Logging，而Logback的目标是Log4J。</p>\n<p>程序员里愤青多，SLF4J和Logback的作者就是一个，他叫<a href=\"http://ceki.blogspot.com/\" target=\"_blank\">Ceki Gülcü</a>，事实上，他也是Log4J的作者。Log4J的开发状态实在让他太不爽了，于是，他另起炉灶，打造出新的替代品。</p>\n<p>只凭一点就足以让我们对SLF4J义无反顾了，你还记得用Commons Logging写出这样的代码吗？</p>\n<p>&nbsp; if (logger.debugEnable()) {<br>&nbsp; &nbsp; logger.debug(\"Hello, \", name);<br>&nbsp; }</p>\n<p>而SLF4J的写法只有一句话：</p>\n<p>&nbsp; logger.debug(\"Hello, {}\", name);</p>\n<p>从根源来说，这是时代造成的，Commons Logging是Java 5之前产生的，那时候还没有变参，所以，我们不得不说，它老了。</p>\n<p>至于Logback，性能是最重要的噱头，当然，还有<a href=\"http://logback.qos.ch/reasonsToSwitch.html\" target=\"_blank\">一些其它的理由</a>。理由里有一点并未提及，但对于开发人员很贴心的改进，就是日志模式的改进，还记得Log4J那密码一样的日志模式吗？</p>\n<p>&nbsp; %d{dd MMM yyyy HH:mm:ss} [%t] %-5p %m%n</p>\n<p>下面是Logback的版本，不用查文档，我也看出每段表示的都是什么：</p>\n<p>&nbsp;&nbsp;%d{dd MMM yyyy HH:mm:ss} [%thread] %-5level %msg%n</p>\n<p>这里介绍的几个程序库都是很通用的，无论是你做怎样的开发，应该都或多或少给你一些帮助。时间未曾停步，Java开发也未曾停留，如果你是个老Java程序员，是时候更新一下自己的知识了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201301022010",
    "date": "2013-01-02",
    "time": "20:10",
    "tags": [
      "Java",
      "程序库",
      "Guava",
      "JodaTime",
      "你应该更新的Java知识"
    ],
    "title": "你应该更新的Java知识之常用程序库（一）",
    "body": "<p>在很多人眼中，Java已经是一门垂垂老矣的语言，但并不妨碍Java世界依然在前进。如果你曾离开Java，云游于其它世界，或是每日只在遗留代码中挣扎，或许是时候抬起头，看看老Java中的新东西。</p>\n<p><strong>Guava</strong></p>\n<p>一句话，只要你做Java项目，就应该用<a href=\"https://code.google.com/p/guava-libraries/\" target=\"_blank\">Guava</a>。</p>\n<p>guava是Google出品的一套Java核心库，在我看来，它甚至应该是JDK的一部分。作为一个Java程序员，如果你没抱怨过JDK的设计，只能说明一点，你写得程序还是太少。正是JDK设计不彰，才有了一些项目来补充JDK的不足。如果说老Java程序员应该听说过<a href=\"http://commons.apache.org/lang/\" target=\"_blank\">Apache Commons Lang</a>，那新Java程序员该知道的就是Guava了。</p>\n<p>老Java程序员更多的是知道Google Collections，不妨到<a href=\"http://code.google.com/p/google-collections/\" target=\"_blank\">它的主页</a>上走一遭，你会看到这个库已经改名为Guava。事实上，Guava并不直接等于Google Collections，Guava是一个超集。Guava实在太强大了，要想展现它的强大，需要专门的介绍，这里就不展开了。</p>\n<p>下面以一个统计单词出现个数的小程序作为这个段落的结尾，虽然无法与许多其它语言的实现相提并论，但作为一个Java程序员，你不妨想一下按照传统方式，这段代码应该是什么样子。</p>\n<p>&nbsp; String content = Files.toString(new File(args[0]), Charset.defaultCharset());<br>&nbsp; Iterable texts = Splitter.on(CharMatcher.WHITESPACE)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.omitEmptyStrings()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.trimResults()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.split(content);<br>&nbsp; Multiset collection = HashMultiset.create(texts);</p>\n<p><strong>Joda Time</strong></p>\n<p>你觉得一个API设计得差到什么份上，才会把自己差不多的API全部Deprecated掉。java.util.Date便是这样的奇葩。因为它的API几乎都是反直觉的，几乎所有敢于用它的Java程序员都吃过它的亏。想初始化个2013年的第一天，还真不那么容易：</p>\n<p>&nbsp; Date firstDayOf2013 = new Date(113, 0, 1);</p>\n<p>如果你是个Java新手，你能猜出113是从哪来的吗？（好吧，它是2013-1900，至于为什么是1900，这真得问API的设计者了）。</p>\n<p><a href=\"http://joda-time.sourceforge.net/\" target=\"_blank\">Joda Time</a>就是人们实在无法忍受这样东西的产物。同样的代码用Joda Time实现：</p>\n<p>&nbsp; DateTime firstDayOf2013 = new DateTime().withDate(2013, 1, 1);</p>\n<p>无论如何，你知道这能看出这些参数的含义了。不只如此，你还可以计算两天后是什么日子：</p>\n<p>&nbsp; firstDate.plusDays(2);</p>\n<p>日期格式化，也是JDK Date系列API里一大特色，你必须把代码写成下面这样：</p>\n<p>&nbsp; new SimpleDateFormat(\"yyyy.MM.dd\").format(firstDayOf2013)</p>\n<p>作为一个初始化很慢的构造函数，你还必须每次调用，因为它不是线程安全的。同样的代码，在Joda Time里，我们可以用DateTimeFormatter：</p>\n<p>&nbsp; DateTimeFormatter formatter = DateTimeFormat.forPattern(\"yyyy.MM.dd\");</p>\n<p>&nbsp; ...</p>\n<p>&nbsp; formatter.print(dateTime);</p>\n<p>请尽管放心大胆把formatter声明成一个字段，因为它是线程安全的。</p>\n<p>当然，Joda Time的强大远不止于此。当然，JDK也并不是那么完全的自暴自弃，于是，有了一个JSR 310专门设计新的Date API。JSR 310的spec lead是<a href=\"http://www.blogger.com/profile/01454237967846880639\" target=\"_blank\">Steven Colebourne</a>，此人正是Joda Time的作者。不过，虽然JSR 310为我们描绘了Date的全新景象，但Java 8出来之前就先别打它的主意了，乖乖地用Joda Time吧。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201212311815",
    "date": "2012-12-31",
    "time": "18:15",
    "tags": [
      "2012",
      "脚下的路"
    ],
    "title": "写在2012的最后一天",
    "body": "<p>又到了一年的年底，我饶有兴致地翻看了一下之前几年的最后一篇blog。最初的几年里，我很喜欢在年底写写东西，无论是总结也好，回顾也罢。到后来，最后一篇blog则陷入了常规状态，按部就班，根本让人无法识别出这是一篇年末的blog。或许是因为年龄渐增的缘故，今天和明日的区别也不甚明显了。</p>\n<p>2012，如同以往一般，有喜有悲，没什么特别，即便我们经历了末日。</p>\n<p>也是因为年底的缘故，我最近和几个不同人聊起了计划。实际上，我个人是个计划性极差的人。但凡信誓旦旦地做计划，结果往往是到年底的时候，我都忘了原有的计划是怎样的了。</p>\n<p>如果说今年按计划做了些事，那就ThoughtWorks校园行了。以前我们也偶尔有到校园去做一些活动，今年最大的不同便是让校园活动常规化了。如今，一年下来了，西安、成都和北京三地的办公室都走进了校园，西安已经常规化了，成都的2013校园活动计划也已经出来了。</p>\n<p>我发起校园活动的初衷只是希望给想学习的同学一个机会，但现在看来，实际达到的效果远远超出了预期。不仅学生们有机会了解到更多现代软件开发的东西，我们也通过这样的活动给了自己的年轻同事一个锻炼自己公开演讲的机会。或许是校园活动的努力，今年校招的效果大大出乎了我们的意料，我们收到简历的数量直奔去年的3倍。现在想想年初在西安一次次地跑学校，也是个很有趣的经历。五六月份还在西安交大开了一门实习课程，让我体会到在大学教书的感觉。</p>\n<p>今年是ThoughtWorks第一次在武汉大规模校招，郑大晔校就这样开到了武汉。西安、成都、武汉，当年的冲动之举，如今已经变成了全国连锁。看来，我还真有搞教育事业的潜力。</p>\n<p>没有计划，但事还做了一些，值得一提的是，翻译了两本书，<a href=\"http://martinfowler.com/books/dsl.html\" target=\"_blank\">老马的DSL</a>和《<a href=\"http://joyofclojure.com/\" target=\"_blank\">The Joy of Clojure</a>》。DSL的翻译有些混乱，拖了很长时间，所以，我选择了独立完成《The Joy of Clojure》。按照预期的进度，这本书会在1月底交稿，以目前的进展来看，问题不大。选择翻译Clojure书，是因为我想了解为什么Lisp系语言那么神奇，现在看来，书是选对了，我开始慢慢理解一些东西了。</p>\n<p>还有一个拿得出手的东西是<a href=\"https://github.com/dreamhead/moco\" target=\"_blank\">Moco</a>。前前后后写了两个月，已经像一个正式的东西了，用户也有了几个。它也是我反思Java开发的一个作品。鉴于之前关注点太杂，我今年把思考放回了Java，于是，我看到了更多值得改进的地方。思考是一件很有乐趣的事情，希望明年可以更多地分享我对于Java开发的理解。</p>\n<p>又是一年了，还好不算虚度，继续前进。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201212301720",
    "date": "2012-12-30",
    "time": "17:20",
    "tags": [
      "Moco",
      "移动开发"
    ],
    "title": "Hello，Moco（番外篇）",
    "body": "<p>你可以创造一个东西，至于它怎样发展，那就不是你所能预期的了。</p>\n<p>我写<a href=\"https://github.com/dreamhead/moco\" target=\"_blank\">Moco</a>的初衷是为了简化集成，设计API是我最主要的关注点。Moco Runner是一个顺手完成的部分，让Moco可以独立运行起来。但每个人的关注点是不同的，有人把Moco用了起来，但是用法同我最初的设想完全不一样。</p>\n<p>我知道的第一个Moco用户是我的一个同事，我在澳洲出差的那段时间给他介绍了Moco，他当时正要写一个iOS上的一个客户端。因为服务器端API尚未开发，更准确的说，连API应该是什么样子还没有人清楚。为了能够让他的iOS客户端能够顺利编写下去，他用Moco模拟了一个服务器，来什么请求，返回什么样的应答。于是，他高高兴兴地写起了他的客户端。在开发的过程中，他不断地调整着API的设计，因为只有通过实际的开发，他才知道自己真正想要的API是什么样子的。就这样，在服务器端代码还没有真正动手之前，他已经提供出一份真正满足他需要的API文档，剩下的就是服务器端照着这份API去实现了。</p>\n<p>公司内部正与<a href=\"http://www.xctsg.org/\" target=\"_blank\">立人图书馆</a>展开合作，帮助他们开发一个图书管理的手机端应用。你猜对了，这个项目里Moco也起到了作用。手机端应用在服务器端尚未就绪的情况下便启动了，他们用Moco模拟了一个服务器，这样，手机端应用就可以顺利地开始开发了。Moco新增了一个功能，当配置文件修改时，自动重新加载，这个功能就是由这个项目的人提出的。</p>\n<p>从这两个例子里可以看到，在移动开发中，Moco起到了很大的作用：在服务器端开发完成之前，客户端通过Moco构建的模拟服务器就可以进行开发。</p>\n<p>把Moco和移动开发结合起来，这是我设计Moco时从未有过的想法，这也是创造一个东西的魅力所在，你无法预期它会朝着哪个方向发展。近来不断地将Moco介绍给更多的人，越来越多的新想法也涌现了出来。有人想把它与前端开发结合起来，有人想让它反过来支持客户端的模拟。</p>\n<p>我原以为Moco已经没什么好做的了，因为我想实现的东西都有了，现在看来，还停不下来。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201212190751",
    "date": "2012-12-19",
    "time": "07:51",
    "tags": [
      "软件开发",
      "平台"
    ],
    "title": "平台的绑架",
    "body": "<p>每每接触一个新项目，无论是咨询还是交付，我总是希望带来一些不一样的东西，其中就包括一些软件或平台的更新。比如：</p>\n<ul>\n<li>作为一个忠实的IntelliJ IDEA的粉丝，我总有一种把项目从Eclipse拯救出来的心。</li>\n<li>作为一个新时代自动化构建的粉丝，ANT和Maven让我回归旧石器时代。</li>\n<li>作为一个简化开发的粉丝，一见到EJB，我就想退避三舍。</li>\n<li>作为一个轻量级部署的粉丝，每每听到WebLogic或Websphere的名字，我就头皮发麻。</li>\n</ul>\n<p>我的心是好的，但现实总是那么残酷，有各种各样的理由把平台的威力发挥至极致，以致于我们只能一动不动：</p>\n<ul>\n<li>我们用到XX公司的框架，在Eclipse很容易配置，而且配置完了，可以部署到XX平台上，很方便。</li>\n<li>Gradle，没听说过，我们现在的东西已经能够编译打包，这不就是自动化工具该做的吗？</li>\n<li>我也知道EJB代码不太好，但这是遗留代码，不好改。</li>\n<li>我们用到WebLogic/Websphere的XX强大特性。</li>\n</ul>\n<p>出现这样的结果，我们已经被平台绑架了。所谓被平台绑架，指的是，你只能使用某个特定平台的东西。这样的结果就是，在技术更新时，我们就只能停滞不前。</p>\n<p>在这个技术发展飞快的年代，新技术层出不穷，用不了多长时间，我们现在所谓的一些时髦技术已经成了地摊货，再过一段时间，就会过时了。或许你会说，我们没有必要跟得那么紧吧。我认同你的观点，但是，如果你成为一个有多年经验的老程序员，你会发现，时间是把杀猪刀。</p>\n<p>我脑海中依然记得初学EJB时的情景，现在EJB已经完全成了过街老鼠，时间仅仅过去了十年。如果我的故事还不算老，最近还听了一个我的客户给我讲的一个故事。多年之前，他们从某大公司那买了大型机，在上面开发用COBOL开发他们的MessageBroker，为此，他们投入很大，招了不少懂上面开发的“专家”，后来，大公司不再支持这个机器了，这个世界上，也只有他们有这些“专家”，当然，也只有他们需要这些“专家”。现在，在不断纠结很多年之后，他们终于下定决心，剔除这个大型机，彻底地。</p>\n<p>好吧，我是一个老程序员了，可以讲一些老程序员的故事了。有了教训，当然，还应该有一些可以分享的经验。</p>\n<p><strong>最重要的是，尽量不要依赖于任何特定的平台。</strong></p>\n<ul>\n<li>使用IDE，即便用到它的一些特定功能，也要知道其背后的原理，像部署之类的事情一定要有自动化脚本，养成没有IDE这事也能做的习惯。请记住，IDE是我们的工具。工具，我们当然要挑最好用的。</li>\n<li>多了解开发新闻，抱着开发心态了解最新的发展，用一些小例子尝试新工具。这样，才不会受限于某个特定工具。对于构建工具这一点而言，请理解《<a href=\"http://www.infoq.com/cn/articles/zy-software-development-foundation\" target=\"_blank\">软件开发地基</a>》，剩下的，无非是用哪个工具实现而言。</li>\n<li>尽可能让自己的代码与特定的框架隔离开，即便是要依赖也应该只有<a href=\"http://dreamhead.blogbus.com/logs/100357058.html\" target=\"_blank\">那一点的调用</a>。这样，如果要替换，我们的核心业务逻辑都是独立的。</li>\n<li>部署方面，尽量使用标准的东西，减少对特定平台的依赖，保证我们的部署包是可移植的。如果万不得已一定要依赖，一定要把这部分代码/配置从物理上与我们领域代码/配置隔离开来。更换部署的时候，我们只要把特定的部分删掉就好了。</li>\n</ul>\n<p>是的，我们可以有一万个理由说，现在这样也挺好。但我们是程序员，我们不该让自己的生活再美好一些吗？在开发方面，我这些年不断追求的，无它，只是想让开发效率再高一些。别让平台绑架了我们。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201212161341",
    "date": "2012-12-16",
    "time": "13:41",
    "tags": [
      "Moco",
      "测试",
      "HTTP"
    ],
    "title": "Hello，Moco（二）",
    "body": "<p>如你所见，Moco主要是通过配置模拟服务器端的行为。目前主要支持两种配置：请求（Request）和应答（Response）。简而言之，当请求是什么样时，返回怎样的应答。前面你已经见过最简单的例子了，不管请求什么都返回“foo”作为应答。</p>\n<p><strong>请求（Request）</strong></p>\n<ul>\n<li>内容</li>\n</ul>\n<p>有时，我们希望根据请求的内容返回相应的应答，我们可以这样配置：</p>\n<p>server.request(by(\"foo\")).response(\"bar\");<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>如果请求内容过大，我们还可以把它放到文件里：</p>\n<p>server.request(by(file(\"foo.request\"))).response(\"bar\");<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"file\" : \"foo.request\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<ul>\n<li>URI</li>\n</ul>\n<p>有时，我们主要关注URI，那我们可以这样配置：</p>\n<p>server.request(by(uri(\"/foo\"))).response(\"bar\");<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"uri\" : \"/foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>URI常常与某些参数相伴，可以针对不同参数配置不同的返回：</p>\n<p>server.request(and(by(uri(\"/foo\")), eq(query(\"param\"), \"blah\"))).response(\"bar\")<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"uri\" : \"/foo\"<br>&nbsp; &nbsp; &nbsp; \"queries\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"param\" : \"blah\"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<ul>\n<li>HTTP</li>\n</ul>\n<p>REST让人们重新认识了HTTP动词的价值，Moco当然也不会错过：</p>\n<p>server.get(by(uri(\"/foo\"))).response(\"bar\");<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"method\" : \"get\",<br>&nbsp; &nbsp; &nbsp; \"uri\" : \"/foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>这里是get，当然post也是很常见的：</p>\n<p>server.post(by(\"foo\")).response(\"bar\");<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"method\" : \"post\",<br>&nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>除了HTTP动词，另一个越来越受关注的是HTTP头：</p>\n<p>server.request(eq(header(\"foo\"), \"bar\")).response(\"blah\")<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"method\" : \"post\",<br>&nbsp; &nbsp; &nbsp; \"headers\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"content-type\" : \"application/json\"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<ul>\n<li>XPath</li>\n</ul>\n<p>Web Service的火爆让XML大行其道，根据XML内容进行判断的一种方式就是XPath：</p>\n<p>server.request(eq(xpath(\"/request/parameters/id/text()\"), \"1\")).response(\"bar\");<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"method\" : \"post\",<br>&nbsp; &nbsp; &nbsp; \"xpaths\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"/request/parameters/id/text()\" : \"1\"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p><strong>应答（Response）</strong></p>\n<ul>\n<li>内容</li>\n</ul>\n<p>最先想到的一定是返回特定的内容，其实之前已经看到了：</p>\n<p>server.request(by(\"foo\")).response(\"bar\");<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"bar\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>同请求一样，如果内容很多，就放到文件里：</p>\n<p>server.request(by(\"foo\")).response(file(\"bar.response\"));<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"file\" : \"bar.response\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<ul>\n<li>HTTP</li>\n</ul>\n<p>&nbsp;</p>\n<p>Moco支持应答中的HTTP状态码：</p>\n<p>server.request(by(\"foo\")).response(status(200));<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"status\" : 200<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>我们还可以指定HTTP应答Header里的内容：</p>\n<p>server.request(by(\"foo\")).response(header(\"content-type\", \"application/json\"));<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"headers\" : {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"content-type\" : \"application/json\"<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<p>&nbsp;</p>\n<ul>\n<li>URL</li>\n</ul>\n<p>有时，我们也可以请求转发到另外一个网站上，换句话说，Moco这时扮演了一个代理的角色：</p>\n<p>server.request(by(\"foo\")).response(url(\"http://www.github.com\"));<br>（API）</p>\n<p>{<br>&nbsp; \"request\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; },<br>&nbsp; \"response\" :<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; \"url\" : \"http://www.github.com\"<br>&nbsp; &nbsp; }<br>}<br>（JSON）</p>\n<ul>\n<li>顺序应答</li>\n</ul>\n<p>有时，我们希望模拟一个改变服务器端资源的真实操作，比如：</p>\n<ol>\n<li>当我们发起第一个get请求时，服务器返回“foo”。</li>\n<li>然后，我们发起了一个post请求，改变了服务器端资源。</li>\n<li>当我们再发起请求时，我们希望服务器返回“bar”。</li>\n</ol>\n<p>Moco支持我们对同一个请求返回不同的值：</p>\n<p>server.request(by(uri(\"/foo\"))).response(seq(\"foo\", \"bar\", \"blah\"));<br>（API）</p>\n<p>如你所见，第一次请求会返回foo，第二次会返回“bar”，第三次则是“blah”。</p>\n<p>以上就对Moco的基本功能做了一个快速浏览。嗯，就是这么简单！</p>\n<p>如果你在项目里经常遇到各种各样的集成需求，尤其是HTTP方式的集成，不妨试试Moco，希望它可以让你的开发更简单一些。当然，作为一个年轻的项目，Moco欢迎各种各样的想法。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201212151331",
    "date": "2012-12-15",
    "time": "13:31",
    "tags": [
      "Moco",
      "测试",
      "HTTP"
    ],
    "title": "Hello，Moco（一）",
    "body": "<p><a href=\"https://github.com/dreamhead/moco\" target=\"_blank\">Moco</a>是一个用以简化测试服务器搭建的框架，主要做测试和集成之用。</p>\n<p><strong>起因</strong></p>\n<p>所谓企业级开发，多半都意味着有一大堆系统要集成，时至今日，最为流行的集成方式莫过于通过Http协议，无论是Web Service，抑或是REST架构。在我的开发记忆里，有人会安装一个web server，然后放进去一些静态文件，稍微复杂的点，自己写一个Java应用，部署起来，做所谓的动态响应，更有甚者，我要搭建一个Web容器，比如Tomcat。总而言之，麻烦。</p>\n<p>简单是一个好的开发人员永远应该追求的，再经历了无数次集成的痛苦之后，Moco向简化这种繁琐集成迈出了一步。闲话少叙，上例子。</p>\n<p><strong>用法</strong></p>\n<p>Moco目前有两种使用方式，一种是API，一种是独立运行。</p>\n<p>下面是一个API的例子，其实这就是一个普通的JUnit测试：</p>\n<p>@Test<br>public void should_response_as_expected() {<br>&nbsp; MocoHttpServer server = httpserver(8080);<br>&nbsp; server.reponse(\"foo\");</p>\n<p>&nbsp; running(server, new Runnable() {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void run() {<br>&nbsp; &nbsp; &nbsp; try {<br>&nbsp; &nbsp; &nbsp; &nbsp; Content content = Request.Get(\"http://localhost:8080\").execute().returnContent();<br>&nbsp; &nbsp; &nbsp; &nbsp; assertThat(content.asString(), is(\"foo\"));<br>&nbsp; &nbsp; &nbsp; } catch (IOException e) {<br>&nbsp; &nbsp; &nbsp; &nbsp; throw new RuntimeException(e);<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; }<br>}</p>\n<p>这里我们搭建了一个http服务器，端口是8080。我们期望访问的时候，它能够返回foo。然后，调用running方法，我们就有了一个环境，启动了一个真正的服务器。这个例子里，我们用了<a href=\"http://hc.apache.org/httpcomponents-client-ga/tutorial/html/fluent.html\" target=\"_blank\">Apache的Http Client Fluent API</a>去访问这个本地启动的服务器。如你所见，当我们访问时，它会给我们返回字符串“foo”。也许你已经想到了，如果我们设置的这个字符串如果是一个SOAP形式，它就模拟了一个Web Service。</p>\n<p>嗯，就是这么简单！</p>\n<p>有时候，我们不仅仅是想在测试里用它，而是希望搭建一个独立的测试服务器。这就是Moco另一种形式发挥作用的时候，只要我们给它提供一个配置文件，声明我们所需服务的样子。目前Moco支持配置文件的格式是JSON。下面是一个例子：</p>\n<p>{<br>&nbsp; \"port\" : 8080,<br>&nbsp; \"sessions\" :<br>&nbsp; &nbsp; [<br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; \"response\" :<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"text\" : \"foo\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; ]<br>}<br>（foo.json）</p>\n<p>这个例子同之前一样，当我们访问服务器时，我们期待返回的是一个字符串“foo”。这个配置同之前的API如出一辙，就不多做解释了。我们把它运行起来：</p>\n<p>&nbsp; java -jar moco-runner--standalone.jar foo.json</p>\n<p>打开你的浏览器，输入http://localhost:8080/，“foo”就呈现在你面前了。</p>\n<p>嗯，就是这么简单！</p>\n<p>当然，Moco能做的远不止这些，接下来，我们会飞快地浏览Moco的功能，请系好安全带，我们开始了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201211302000",
    "date": "2012-11-30",
    "time": "20:00",
    "tags": [
      "我眼看世界",
      "澳大利亚"
    ],
    "title": "感受澳洲",
    "body": "<p>第三次踏上澳大利亚的土地，前前后后在墨尔本和布里斯班两个城市的时间超过了两个月。</p>\n<p>或许是因为设置了正确的时区，澳洲一般都亮天很早，所以，这里适合早睡早起。一般说来，这里的人上班也很早，朝八晚五。</p>\n<p>不过，对于很多人来说，如果不是有什么特别情况，每天上班的第一件事并不是急冲冲地开始工作，而是买上一杯可口的咖啡，三五成群在一起聊聊。就我合作过的一些客户来看，他们对咖啡的喜爱甚至到了让我不能理解的地步，即便办公室的厨房里就有现成的咖啡机，很多人也会选择到楼下的咖啡店里去买一杯新制的咖啡，因为在他们看来，咖啡机里出来的咖啡口感上差太多。当然，一路上聊聊天也是咖啡文化重要的一部分。作为一个中国人，我难免会被问到茶的问题：不，我们中国人喜欢喝茶，但绝对没到你们这个份上。</p>\n<p>澳洲人的工作节奏，在我看来，绝对算不上快，与不少人一起结对写过程序，却极少见出现匆匆赶工的现象，更多的是按部就班地一点点来做。但不得不承认的一点是，虽然节奏不快，但做事的质量却是相当高的，各方各面的细节几乎无一照应不到，而且即便脑子里很快就有一些直接的解决方案，他们也常常会停下来，找找更能体现所用框架、工具、语言味道的实现。所以，几乎在代码里出现的，差不多都算得上这个东西的最佳实践了。</p>\n<p>还有一点，他们对于命令行的熟悉是很令人惊讶的。几乎每一个人，都对命令行操作很熟悉，即便是在Windows开发，也必然会按照一个像Cygwin这样的东西。每每结对，我几乎总能看到一些我之前没有尝试过的一些细节。与他们一起结对，我通常都会全神贯注，充分调动自己的经验，这样会很累，但以这种方式写程序却是一件非常快乐的事情，结对的双方都能在这个过程中从对方身上学到很多东西。</p>\n<p>澳洲有很多人喜欢运动。无论是墨尔本，还是布里斯班，都有一条河穿城而过。清晨，河边就是人们的运动场，跑步或是骑车的人很多。骑车或跑步的人也不在少数，大街上常常见到许多背着背包的人飞驰而过。有上下班运动的，也有选择中午运动的，有人专门中午要出去跑上五公里，再回来继续工作，还有人会组织中午到邻近的草坪踢球，无它，只为锻炼。所以，这里的一些公司专门备有洗浴的地方，提供给那些喜欢运动的人。</p>\n<p>对于很多像我这样的中国人，出到国外，最大的难题恐怕都在英语上。其实，在澳洲，汉字和亚洲面孔还是可以经常看到的。记得有一次和一个来澳洲看孩子的阿姨聊天，虽然不会说英语，但她在这里的一段时间，基本上还是可以很好的生活。单就学习英语而言，我曾经和一个印度同事聊过，他说，其实他们的母语也不是英语，也是要学英语的，只不过在国内的时候，经常有用到，因为不同地区的方言不一样，只能用英语交流。想把英语学好，只能是多说多练。从这一点上来说，还真要感谢ThoughtWorks。加入公司之前，我的英语水平就只能说一些简单的句子，现在可以与人闲聊，如果再写简历的话，我完全可以厚着脸皮写上“口语流利”了。想来，每次出国英语都是一次提高，就是这么一点一点积累的。</p>\n<p>或许，这就是ThoughtWorks给大家提供的平台，让我们不再把自己局限在一亩三分地，而是向世界学习，所以，作为一个ThoughtWorker，我们停不下来。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201211191923",
    "date": "2012-11-19",
    "time": "19:23",
    "tags": [
      "精益创业"
    ],
    "title": "读《精益创业》",
    "body": "<p><a style=\"margin:5px;float:left;\" href=\"http://book.douban.com/subject/10945606/\" target=\"_blank\"><img style=\"border:none;\" src=\"http://img3.douban.com/mpic/s11137256.jpg\" alt=\"\"></a>\n</p><p>&nbsp;</p>\n<p></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>新近读了《精益创业》，加之品味<a href=\"http://www.forbes.com/sites/stevedenning/2011/05/04/innovation-applying-inspect-adapt-to-the-agile-manifesto/\" target=\"_blank\">Kent Beck关于创业公司的增强版敏捷宣言</a>。在我看来，这是持续交付之后，软件开发又要迈出的下一步。</p>\n<p>精益创业的核心观点其实很简单，如下图所示：</p>\n<p><img src=\"http://theleanstartup.com/images/methodology_diagram.jpg\" border=\"0\" alt=\"\"></p>\n<p>它就是要缩短从想法到验证的时间，成败与否早知道。既然创业是件极度不确定的事，那就通过小步快跑，早点验证这些想法，知道自己的斤两，把艺术变科学。</p>\n<p>不过，这是创业的做法，那与软件开发有何相关的呢？首先，Eric Ries就是从做软件起家的。实际上，更重要的是，做软件本身就是为了实现某种价值。</p>\n<p>以我了解到的软件开发来看，人们对于软件开发的理解也是逐步增进的。最原始的状态是混沌软件开发，后来有了瀑布式，解决了原本眉毛胡子一把抓的状态，再往后的迭代开发，则让反馈周期越来越短。也是在这个阶段，人们开始意识到持续集成的重要性，不过，这里的所谓持续集成只是关注在开发本身是否能构建出一个可运行的版本来，再往后，就是持续交付了，不仅仅能够运行，更要能够上线。而如今，结合精益创业，软件开发应该再迈一步，我们不仅仅要把软件构建出来，更要关注这个软件是否实现了某种价值，这里我们希望可以做的是：持续验证。</p>\n<p>从过往的经验来看，</p>\n<ul>\n<li>站在持续集成的角度看问题，自动化测试变得很重要</li>\n<li>站在持续交付的角度看问题，自动化部署变得很重要</li>\n<li>如果站在持续验证的角度看问题，什么会变得重要呢？</li>\n</ul>\n<p>从新一期的ThoughtWorks技术雷达上，我们不难发现一些有趣的东西。在<a href=\"http://www.ituring.com.cn/article/16364\" target=\"_blank\">技术部分</a>，有一个logs as data。从前，我们都是把日志当做一种诊断手段，而在如今这个技术发展趋势下，存储越来越低廉，再加上一些辅助性的工具，比如<a href=\"http://www.splunk.com/\" target=\"_blank\">Splunk</a>，我们完全可以让运维更加智能化。</p>\n<p>如今大数据这个词也越来越火爆，不过，现在谈起大数据，我们指的都是对用户数据的挖掘。既然我们要把运维日志也看成是一种数据，我们也可以把大数据的一些技术运用在运维环节，对系统的状况进行挖掘。可是我们要挖掘什么呢？这个问题完全可以由精益创业的观点来回答，简而言之，关注于真正有用的东西，而不是虚荣指标。</p>\n<p>当然，这只是一个简单的技术分析，随之而来的改变还有许多，Kent Beck的增强版敏捷宣言就给软件开发描绘出一副新的蓝图。</p>\n<p>不管你愿不愿意，软件开发又不停歇地向前发展了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201211151918",
    "date": "2012-11-15",
    "time": "19:18",
    "tags": [
      "程序员",
      "养生"
    ],
    "title": "聊聊早起",
    "body": "<p>我是一个程序员，在人们通常的理解里，这个词往往和夜猫子联系在一起。事实上，我确实曾经是夜猫子，每天越到晚上越精神。这一切直到我们家领导下定决心对我进行整改开始了改变。</p>\n<p>要知道，让一个喜欢夜猫子在10点多，甚至9点多上床睡觉是一件很难的事，但监管的作用就体现出来了，为了和谐，我不得不在那个时间就躺在床上。其实，我自己的都没有意识到，我实际上身体已经疲惫了，所以，躺在床上很快就能进入甜美的梦乡。</p>\n<p>我知道，其实很多人熬夜的缘由之一是希望多有些时间看书或者做事情，因为我也是这么想的。感谢我的生物钟，虽然我把上床睡觉的时间提前了，只要睡觉的时间够了，我的生物钟会按时将我从睡梦中唤醒。这样，我就可以早早起床，这样一来，睡觉的时间和读书做事的总时间是一样的。把貌似晚上要做的事情挪到早上来做。不知道你是否注意过，如果正常睡醒，早上的注意力是很集中的，而且，早上的时间，窗外异常地安静，只偶尔会有几声鸟鸣，因此，无论是读书还是做事，效果往往会出乎意料地好。所以，在翻译《The Joy of Clojure》的过程中，我把翻译时间设在每天早上，每天早起翻译两页，一旦出现偏差，晚上还可以适当弥补。这样，在每天上班之前，我已经做完了不少事情。</p>\n<p>早睡早起之后，身体有一个非常明显的感觉，中午不像从前那么困了。虽然每天晚上睡觉的时间都是一样的，但以前一到中午，吃过午饭便觉得累得不行，睁不开眼睛。所以，经常的做法就是找个无人的角落，小憩片刻。一旦中午有些什么事情，让休息成为不可能，那整个下午人都没有精神，整个人就在极其疲惫的状态下工作，效率是很低的。而现在，即便中午不睡觉，下午即便偶尔会打哈欠，也只是一时的，不会整个人陷入游离状态。</p>\n<p>对我而言，早睡早起还有一点好处，关于睡懒觉的。是的，睡懒觉。偶尔，到了该起床的时间，但真的是不想起床，我就会放纵一下自己，比如多睡半个小时，虽然多睡了半个小时，但也绝不会耽误早起上班的，毕竟，早上的时间我还很多。当然，经常性的放纵是不鼓励的。</p>\n<p>如果读一些养生方面的书，你便不难发现，我们这些坐办公室的几乎就是一个典型的反面教材。当然，调理的办法有很多，早睡早起就是其中之一，熬夜对身体的伤害是隐形的，所以，年轻的时候感觉不到，到年纪大了，会后悔的。读了《<a href=\"http://book.douban.com/subject/11614538/\" target=\"_blank\">程序员的职业修养</a>》，我深深地意识到一点，绝不能让身体在疲惫状态下工作，这样才能得到更高的效率。我的职业生涯应该还有很长，保证可持续发展是必要的。</p>\n<p>早睡早起身体好，多谢领导！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201210311553",
    "date": "2012-10-31",
    "time": "15:53",
    "tags": [
      "ThoughtWorks",
      "我眼看世界"
    ],
    "title": "当我加入项目时，我要了解什么",
    "body": "<p>在ThoughtWorks里面，我经常有机会在不同的项目组间轮换，所以，经常会面对陌生的一切，出去做咨询项目时也是如此。但人们常常会对有经验的人加入项目有所预期，也就需要我能够尽快进入到工作状态中。所以，我也就慢慢摸索出一套适合自己的了解项目的方式。</p>\n<p><strong>业务</strong></p>\n<p>首先，肯定要从业务入手，了解这个系统是做什么的。既然是初始的接触，我并不预期弄清楚所有的细节，只要知道这个系统是做什么的基本上就够了。</p>\n<p>按理说，这通常不应该是什么问题，但这也是常常容易出问题的地方，比如说，有为数不少的人在讲业务的时候，会把技术的内容混在一起讲，这一点对于技术人员尤为明显。个人就曾经经历过让我开始怀疑自己智商的几次介绍。如果5分钟说不清楚，你就别指望半个小时能说清楚。</p>\n<p><strong>技术</strong></p>\n<p>了解了系统的业务，接着就是对技术方面的了解。还是先从宏观方面入手，我期望了解到这个系统是由哪个技术栈实现的，Java、C/C++还是.NET系等等。这样，我就可以系统采用相应的工具与框架有个大概的预期。</p>\n<p>接下来，我期望从架构层面上了解系统。有没有一张或几张图能够把整个系统描绘出来，比如，这个系统需要与几个外部系统集成，自身包括哪些部分等等。一般我不指望有现成的图，多半的情况是，其他人一边说，一边在白板上画出一副这样的图。我接下来会根据自己的理解，把需要的这种图画出来。</p>\n<p>对大面的东西有了了解，我就希望稍微了解一下细节。从集成开始，因为输入输出对一个系统来说是非常重要的，而集成点往往都是系统信息来源。如果有集成，集成方式是什么，比如，Web Service、RMI、MQ，有为数不少的系统用的是FTP，这些集成方式相当于信息的承载，那之上的信息是什么样子，我们还需要搞清楚，比如有的系统用的是MQ，在MQ上传的是XML等等。接下来，就是更具体的协议层面的东西了，我想知道是否有对应的文档，这样，我在需要的时候，就可以查看每个字段具体的含义，不过，这往往不是初期要了解的东西。</p>\n<p>了解了集成，接下来就是系统内部了。这个系统有哪些子系统或模块组成。好的系统往往是由多个进程构成的，这样才不会彼此影响。对于这样的系统，我只要了解每个子系统的作用就可以了。而对于那些只有一个进程的系统，我就需要了解一下这个系统包含哪些模块，各个模块承担着怎样的职责。通常，这会一个很重要的出问题的点，因为很多系统虽然号称有模块的概念，但模块之间的职责往往是不清楚的，经常会出现很严重的依赖问题。对于现代软件系统而言，分层结构往往是不可或缺的，我还希望了解一下这个系统有多少个层，每个层做的事情是什么。这里提及了模块和层次，模块通常是从业务上来分，而层次往往是从技术上看，一个水平一个垂直。</p>\n<p>从设计层面了解完，就是动手的层面了，不过，还不是写代码的事。我会先了解构建脚本。了解一下项目中常用的命令，比如，是否可以一键式跑脚本提交之类的。我期望看到的是一个从版本管理工具里拿出来直接可以构建成功的脚本。但通常情况都不是这样的，要改很多东西、配不少的东西。这也许就是未来要改进的东西。</p>\n<p>熟悉了周边的东西，我们就可以深入到源码层面了。这就是我们程序员最熟悉的东西，比如，源码目录结构、配置文件的位置、模块在源码上的体现之类的等等。但作为最初的接触，我们只要了解基本的东西就够了，因为这是我们后来投入精力最多的地方，以后深入理解的机会多得是。</p>\n<p><strong>团队运作</strong></p>\n<p>除了了解技术层面的东西，我还希望了解团队运作方面的东西，一个方面就是常见活动的时间安排，比如，站会、迭代计划会议、回顾会议等的时间。再有一个方面就是，团队内部是否一些活动安排，比如是否有每天的Code Diff，是否有常规的Session墙。如果团队有外部客户，我们有客户日常的沟通是怎样进行的。</p>\n<p>通过这些问题，我们便不难发现项目运作上的一些问题，比如，很多团队与客户之间根本没有常规的沟通，只是会临时起意去做沟通。有的团队没有Session墙，团队内部分享也就没有常规化。</p>\n<p>通常以上这些东西都不需要很长的时间来了解，快的话，一天就可够了。而通过这些了解，我就可以对团队的基本情况有了一个相对完整的大体认识，接下来的事，就是卷起袖子开始干活了！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201210270921",
    "date": "2012-10-27",
    "time": "09:21",
    "tags": [
      "ThoughtWorks",
      "团队",
      "成长"
    ],
    "title": "新团队负责人成长问答",
    "body": "<p>在ThoughtWorks内部，我们定期会把各个项目的负责人召集在一起，介绍项目进展，汇报风险，交流经验。下面的问题就是出现在我们的讨论中。</p>\n<p><strong>问题</strong>：新加入项目的人一直不能独立做事怎么办？</p>\n<p><strong>简短回答</strong>：让新人多干活，老人向后站。</p>\n<p><strong>完整回答</strong>：在ThoughtWorks，我们通常会采用结对开发的方式。大多数程序员直觉上总是会把完成任务排到更高的优先级，所以，即便在结对开发的情况下，有经验的老人为了快速完成任务，总是倾向于霸占键盘。作为刚刚加入项目的新人，通常又不好意思打断，而且，老人眼花缭乱的屏幕切换更让新人不知所措，为了不露怯，就更不好意思问了。</p>\n<p>但软件开发这个行业，第一手经验往往就是动手得到的。不动手，怎么看别人解决问题，也不会得到真正的成长。</p>\n<p>一般来说，在日常工作中，工作并没有那么紧，大多数时候，我们不必冲得那么猛。完全可以把键盘教给新人，让他们来主导。作为有经验的老人，在这个过程中，主要保证思路不出现偏差即可。可能在一开始，新人的各方面确实不令人满意，但就是在这种磕磕绊绊的过程中，新人慢慢就会成长，一点点抗起压在其肩头的重量。</p>\n<p>这是有经验的人经常犯的错误，我们经常会见到一个无所不能的负责人，向我们抱怨其团队的不作为。我想说的是，真正该骂的是这样的负责人，是你挡住了别人成长的路。</p>\n<p><strong>问题</strong>：项目中有人要离开怎么办？</p>\n<p><strong>简短回答</strong>：让要离开的人变成酱油。</p>\n<p><strong>完整回答</strong>：稍微长一点的项目，人来人往几乎是必然的，所以，离开一个人是很正常的。其实，出现这种担心，主要是有经验的人离开项目，尤其是在项目中扮演重要角色的人离开。</p>\n<p>为什么他们的离开会那么惊心动魄？因为他们太重要了。一个不起眼的角色离开必然不会有很大影响。所以，解决这个问题的方案，必然是让这些曾经重要的角色不重要。</p>\n<p>怎么才能做到这一点呢？那就是把重要的事交给其他人来做。比如：</p>\n<ul>\n<li>以前在客户面前发表高论的都是这些人，那就换成下一个要负责的人。</li>\n<li>曾经的设计决策都是这些人，那就换成下一个要负责的人。</li>\n<li>曾经给新人讲东西都是这些人，那就换成下一个要负责的人。</li>\n<li>曾经与上层领导交流的都是这些人，那就换要负责的人。</li>\n<li>……</li>\n</ul>\n<p>总而言之，趁着这些人还在团队，逐步弱化这些人的作用。这样，一方面，可以降低这些人离开的风险，另一方面，又可以利用他们的经验，对新的负责人提供帮助。我们去年的那个团队，至今一年半的时间，来来往往的人无数，其中曾经的项目负责人就下了四个，项目未受太大影响，反而有新人不断带来惊喜。</p>\n<p>以上两个问题，其实在回答一个问题，如何培养团队。不把团队培养摆在优先级很高的位置上，很多问题是难以解决的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201210172208",
    "date": "2012-10-17",
    "time": "22:08",
    "tags": [
      "读书"
    ],
    "title": "关于读书的笔记",
    "body": "<p>在成都办公室第一次参加Reading Club的活动，这次做分享的是不远万里来到中国，支援成都办公室建设的Pat同志。</p>\n<p>正式分享之前，作为一个母语为英语的人，给我们分享了一些读英文书的经验，我们也围绕着这个话题展开了讨论。这是有趣的话题，这篇blog算是一篇笔记吧！</p>\n<p><strong>选择书</strong></p>\n<p>这是一个通用的话题，无论是读中文书，还是英文书。</p>\n<p>选择一本书，我们多半是参考别人的评价，尤其是面对一个不甚熟悉的领域。读中文书，<a href=\"http://book.douban.com/\" target=\"_blank\">豆瓣</a>无疑是我们的首选。而读英文书，很多人会去amazon，那里有很多人的书评。除此之外，Pat还给我们推荐了<a href=\"http://www.goodreads.com/\" target=\"_blank\">GoodReads</a>，在他心目中，等价于中文的豆瓣，许多ThoughtWorker都是有它的账号，在上面做着分享。</p>\n<p>除了书评，摘要也是个不错的选择，读摘要是快速了解一本书内容的方式，Pat给我们推荐了一个网站，<a href=\"http://www.getabstract.com/\" target=\"_blank\">GetAbstract</a>，这里有许多书的摘要，他开玩笑说，我们的创始人号称读的几百本书，实际上读的都是摘要。</p>\n<p>谈到这个话题，<a href=\"http://liulongjun.com/\" target=\"_blank\">刘龙军</a>给出了个人一个很好的实践，想了解一本书，还可以通过google来做，只要搜索“书名 mindmap”，通常都会有不错的结果。</p>\n<p><strong>读书</strong></p>\n<p>谈到读书，Pat给我们分享了自己的读书经验，从目录着手。读了目录，可以快速了解全书的概貌。在章节阅读时，他给出了一个貌似废话的做法，读标题，读第一段，然后读全章。稍后，Pat给我们解释了原因，大多数写书的人都非常强调在第一段提纲挈领地把整个章节的内容统揽起来，有了这个核心的东西，后面所有的东西都是围绕它在展开，所以，应该在前面多放注意力。</p>\n<p>好记性不如烂笔头，接下来的话题是做笔记。做笔记的手段有很多，比如，用彩笔高亮某些文字，在书的边缘上记笔记。还可以按照自己的理解列提纲，还有一种比较好用的方式，就是刚才提到的mindmap。</p>\n<p>这里还涉及到一个不同类型的学习者，也就是<a href=\"http://www.nwlink.com/~donclark/hrd/styles/vakt.html\" target=\"_blank\">VAK学习风格</a>，V是Visual，指的是对图形图像比较敏感的人，A是Auditory，指的是对听觉敏感的人，这种人适合听讲座，K是Kinesthetic，指是通过动手实践进行学习的人。不同风格的学习者可以根据自己的情况选择做笔记的方式。</p>\n<p><strong>英文</strong></p>\n<p>其实，这才是我们这群中国人真正要感兴趣的地方。</p>\n<p>阅读第一个要过的关是单词。Pat和我们说，其实，在阅读的过程中，他也有不少不认识的单词，这点和我们阅读中文书时有不认识的字是完全一样的。但是，每次遇到这个单词，他都会把这些单词记下来，同时，在字典上找出它们的定义，记下来。</p>\n<p>这里我提了一个问题，我们找所谓的书评，都是关于书的内容，而对英文非母语的人来说，怎么样才知道哪些书是适合自己的阅读，没有那么多复杂不实用单词的书呢？Pat说，我还真不知道，因为我从来没有过这种问题。不过，他也承认，确实有很多作者喜欢用大词，用很多他也不知道的词。反过来想，也许从比较薄的书入手是个不错的选择。就我个人的经验来说，《<a href=\"http://book.douban.com/subject/3889178/\" target=\"_blank\">Rework</a>》这本书挺不错，又薄，单词不复杂，图还多。</p>\n<p>最后，补充一个我觉得不错的个人博客，其实是两个网站，但属于一个人：<a href=\"http://www.read.org.cn/\" target=\"_blank\">战隼的学习探索</a>和<a href=\"http://www.write.org.cn/\" target=\"_blank\">读书笔记</a>，站长在那里分享了大量的mindmap和读书笔记。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201209261026",
    "date": "2012-09-26",
    "time": "10:26",
    "tags": [
      "hello",
      "vagrant"
    ],
    "title": "Hello，Vagrant（二）",
    "body": "<p>好吧，我承认在<a href=\"http://dreamhead.blogbus.com/logs/222436900.html\" target=\"_blank\">第一部分</a>介绍的那个虚拟机只是看上去很美，因为里面什么都没有，所以，我们必须动手给它装些东西，才能让它有点作用。</p>\n<p>别急别急，我知道，你会和最初的我一样，一听到装东西，立刻就要vagrant ssh上去，然后，apt-get install各种各样的东西。可我们是程序员，我们才不做这种普通用户才做的事情呢！</p>\n<p>在这个年代，只说持续集成，我们都不好意思了，要说持续交付，而要达到持续交付，有一个叫做DevOps的概念是绕不过去，说白了，DevOps就是把配置环境的过程代码化，所谓infrastructure as code。在这个领域，有两个工具很好用，一个叫Chef，另一个叫Puppet。它们都可以极大程度上简化我们配置环境的过程。</p>\n<p>谢天谢地，Vagrant二者都支持。</p>\n<p>下面我们用Chef搭建一个CI，体验所谓的DevOps。</p>\n<p>Chef支持两种运行模式，Chef Solo和Chef Server。所谓Solo就是一个人的工作，而Server自然是服务器的意思。之所以要有这样的区分，主要是考虑用来配置机器的脚本放在哪里，Solo就是放在自己的机器上，而Server则是放在一台特定的服务器上。在我们这个简单的例子里，就不麻烦Server了。</p>\n<p>我们要配置机器，首先要有的就是配置文件，对应的配置文件在Chef中称为cookbook，这个社区里已经很多写好的Cookbook，让我们拿过来用。</p>\n<p>&nbsp; http://community.opscode.com/cookbooks</p>\n<p>就我们这个例子里，我们选用的CI软件是Jenkins，所以，我们需要jenkins的cookbook。在这个例子里，我们就在之前建立目录创建一个cookbooks的目录，用以存放我们的cookbook，进入到这个目录下，执行下面的命令：</p>\n<p>&nbsp; git clone https://github.com/heavywater/chef-jenkins jenkins</p>\n<p>先别急，事实上，仅有一个jenkins是不够的，它还要依赖于其它的程序包，以这个例子而言，我们采用Ubuntu操作系统，所以，我们需要安装apt，再有jenkins是一个Java编写的应用，所以，它还需要一个java：</p>\n<p>&nbsp; git clone https://github.com/opscode-cookbooks/apt.git</p>\n<p>&nbsp; git clone https://github.com/opscode-cookbooks/java.git</p>\n<p>好，我们要用的cookbook都有了，下面该让Vagrant知道它们的存在了。上次说道，我们在init之后，会生成一个Vagrantfile。实际上，它就是Vagrant的配置文件。用你最喜欢的编辑器打开它。</p>\n<p>实际上，关于如何配置Vagrant，主要内容都在里面了，只是大部分都注释掉了而已。既然我们要采用Chef Solo模式，那就找到相关的配置，搜索chef_solo，很容易定位到，将它改成下面的样子：</p>\n<p>&nbsp; config.vm.provision :chef_solo do |chef|<br>&nbsp; &nbsp; chef.cookbooks_path = \"cookbooks\"<br>&nbsp; &nbsp; chef.add_recipe \"jenkins\"<br>&nbsp; end</p>\n<p>这个配置是告诉Vagrant，cookbook的路径在哪，以及我们要用的哪个配置。</p>\n<p>这样，基本的配置就是这样了，但是，我们虽然启动了这个jenkins，却只能在虚拟机内部访问，为了让别人也能访问，我们需要配置转发端口，同样在Vagrantfile里：</p>\n<p>&nbsp; config.vm.forward_port 8080, 7070</p>\n<p>这个配置是说，虚拟机内部的8080端口会转发到宿主端口7070。</p>\n<p>等了半天，启动我们的虚拟机吧，还记得命令吗？</p>\n<p>&nbsp; vagrant up</p>\n<p>如果你之前启动过，为了让新配置生效，我们可以：</p>\n<p>&nbsp; vagrant reload</p>\n<p>虽然是自动安装，但漫长的安装过程是无法避免的，可以先休息一下。</p>\n<p>幸运的话，等待之后，我们就可以打开我们的浏览器，访问新CI了：</p>\n<p>&nbsp; http://localhost:7070</p>\n<p>好了，我们的CI就绪了，按照你的需求配置吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201209181752",
    "date": "2012-09-18",
    "time": "17:52",
    "tags": [
      "hello",
      "vagrant"
    ],
    "title": "Hello，Vagrant",
    "body": "<p>\n</p><p>在这个虚拟化当道的年代，作为一个程序员，你一定对<a href=\"https://www.virtualbox.org/\" target=\"_blank\">VirtualBox</a>不会陌生，是的，它就是个虚拟机。不过，这里要说的却是<a href=\"http://vagrantup.com/\" target=\"_blank\">Vagrant</a>，那Vagrant又是什么呢？</p>\n<p>如果说VirtualBox是个芸芸众生的虚拟机，那Vagrant就是程序员的VirtualBox。你要知道，作为一个程序员，我们认为，什么东西都应该在命令行下控制。当然，对于程序员这个群体，要是面对一个可以在命令行下控制的虚拟机，我们要的可绝不是“打开虚拟机、上个网银”。</p>\n<p>Vagrant是用Ruby写的，所以，安装之前，确保你装好了Ruby和RubyGems。一般来说，我会用<a href=\"https://rvm.io/\" target=\"_blank\">RVM</a>安装Ruby这套东西，仅供参考。再有既然是要控制VirtualBox，安装一个VirtualBox也是必然的。</p>\n<p>准备好基本的东西，安装Vagrant就非常简单了：</p>\n<p>&nbsp; gem install vagrant</p>\n<p>接下来，就该是使用了。不过，在此之前，我们先要找一个虚拟机镜像来，就像使用一般的机器先要装机一样。此外，我们还要让vagrant知道这个镜像文件的存在，下面就是这样一个命令：</p>\n<p>&nbsp; vagrant box add base http://files.vagrantup.com/lucid32.box</p>\n<p>在vagrant里，这个概念叫做box，所以，这个命令的意思，我要添加一个box，我给它命名成base，它的地址是http://files.vagrantup.com/lucid32.box。</p>\n<p>其实，这个如果你熟悉Ubuntu的命名规则，便不难发现，这个box是一个Ubuntu的镜像。事实上，这个box显然不是唯一的选择，如果我们想要其它版本的操作系统，我们的选择还有很多，在这里可以找到：</p>\n<p>&nbsp; <a href=\"http://www.vagrantbox.es/\" target=\"_blank\">http://www.vagrantbox.es/</a></p>\n<p>剩下的就是，选择我们想要的操作系统，给它命个名字，就可以用起来了。</p>\n<p>找一个目录进去，是的，最好这么做，因为接下来，我们会生成文件，放在一个特定的路径里，不容易丢掉：</p>\n<p>&nbsp; vagrant init base</p>\n<p>从命令行的提示里，我们可以看到，vagrant为我们创建了一个Vagrantfile，里面有好多内容，不过，把细致查看留给你，让我们先体会一下成就感吧！启动我们的虚拟机。</p>\n<p>&nbsp; vagrant up</p>\n<p>一切正常的话，在打出一片提示之后，我们的虚拟机就运行起来了。怎么才能用上这个新“机器”呢？其实，这就是一台独立的机器，我们可以ssh上去。</p>\n<p>&nbsp; vagrant ssh</p>\n<p>好了，尽情折腾吧，这是我们程序员的虚拟机。</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201209102004",
    "date": "2012-09-10",
    "time": "20:04",
    "tags": [
      "ThoughtWorks",
      "面试"
    ],
    "title": "聊聊ThoughtWorks面试",
    "body": "<p>英文版</p>\n<p><a href=\"http://www.businessinsider.com/hardest-tech-company-job-interviews-2012-8\" target=\"_blank\">http://www.businessinsider.com/hardest-tech-company-job-interviews-2012-8</a></p>\n<p>中文版<br><a href=\"http://www.cnbeta.com/articles/203954.htm\" target=\"_blank\">http://www.cnbeta.com/articles/203954.htm</a></p>\n<p>最近有几篇关于科技公司面试的新闻，这篇格外受瞩目，因为竟然有公司力压Google，成了面试最难的公司，而这个公司居然是ThoughtWorks。</p>\n<p>这个结果真的让我有些惊讶，作为一个面试过许多人的ThoughtWorker，我之前还真没想过我们的面试到底有多难。既然有人关心ThoughtWorks面试，我就不妨在此分享一下我的“面经”。</p>\n<p>先来说说，我们的招聘流程。ThoughtWorks的招聘流程大抵分成如下几个部分，以社招开发人员为例：</p>\n<ul>\n<li>电话面试，称为Phone Screen，由负责招聘的同事了解候选人基本情况</li>\n<li>技术电话面试，称为Techinial Phone Interview，TPI，这个环节通常是针对远在外地的候选人</li>\n<li>代码作业，称为Homework，动手写代码对程序员的考核而言是不可或缺的。</li>\n</ul>\n<p>通过上面流程，候选人就可以进入到我们的办公室。一般说来，候选人要来办公室两次，第一次会做一些测试题：</p>\n<ul>\n<li>逻辑和英语测试</li>\n</ul>\n<p>通过之后，才是真正的重头戏，也是称为“面试”的部分。一般说来，这些环节会在一个下午的时间完成：</p>\n<ul>\n<li>结对编程面试，称为Pair Programming</li>\n<li>面谈，称为Office Interview，在我们招聘同事的口中，它有一个更复杂的名字：Overall Technical Interview and Culture Interview</li>\n</ul>\n<p>这是主要的流程，有些情况会因人而异稍做调整。一般情况下，整个流程需要3周左右时间。我个人参与较多的主要是后两个环节，我的“面经”也主要在这里。</p>\n<p>结对编程面试，是候选人和面试官一起写代码。所用的代码就是候选人之前在代码作业环节所写的代码。这是个真刀实枪的环节，想作弊是不可能的。之前曾经发生过这样的事情，候选人找人代写代码，结果，一到这个环节就完全暴露。</p>\n<p>在这个近距离一起工作的面试中，候选者对代码的理解、开发习惯和与人交流的方式等等就全部展现在面试官面前。有些人之前习惯于窝在一个角落里写代码，像这样，写程序时身边还有人交流，对他们来说是一个巨大的挑战。我曾经看到很多面试者在这个环节紧张得不能正常思考，导致实力打了折扣。</p>\n<p>之所以采用这样的方式进行面试，因为这就是我们日常的工作方式。我们希望了解候选人的情况，同样，也希望他们能够最真实地体验我们的工作方式、交流方式和思考方式。我们不仅仅要写程序，还要彼此交流，降低项目中出现“关键人物”的风险。以我之前的一个项目为例，这是一个总规模在十人左右的项目，一年半的时间里，这个项目先后下了四个团队lead，离开项目的开发主力也有五六个，但项目一直顺利进行，未受太大影响，就是因为通过交流，知识得到了充分地分享，避免了“关键人物”带来的风险，也让更多的同事得到了充分地锻炼。</p>\n<p>不可否认的是，不是所有人都喜欢这种工作方式。有了这样的环节，候选人在体验之后也会有个新的评估：ThoughtWorks是不是他在找的工作，这样的工作是不是他喜欢的。</p>\n<p>透露一个秘密，如果在结对过程中，候选人能够展现出他对快捷键和命令行的熟练，会在面试官心目中有加分的。</p>\n<p>接下来是面谈环节，面试官和候选人坐下来，聊聊候选人的一些经历。以我个人的面试风格而言，了解了候选人过往的经历之后，我会让他挑一个自己最想讲的项目，做一个介绍。听起来很容易，但接下来，根据他介绍的内容，我会做进一步挖掘。比如，候选人说自己做过某个设计，我会问他为什么这么做，而不是那么做，对比不同方案之间的差异。这是一个说难不难的环节，如果在做设计决策的过程中，候选人经过了深入思考，回答出这些问题简直易如反掌，但对于那种直奔结果而去的候选人而言，这个问题却并不容易，当初决定的草率会在这个环节暴露无疑。这是整个面试的重头戏，候选人完全可以在这个环节将自己对技术的深入理解体现出来。</p>\n<p>所有的问题都是开放的，没有正确答案可言，通过这样的交流过程，我们可以看到候选人更多方面的能力：思考方式、分析能力、表达方式等等。当然，也有一些人让人遗憾，他们应该是做了很多出色的工作，但完全没有办法清晰地表述出来。我喜欢听到的介绍方式是，层次清晰的讲述，当然，如果有激情就更好了。如果你看到过对技术真的有热情的人讲技术，你会知道，与那样的人交流简直是就是一种享受。</p>\n<p>之后，我们还会了解候选人的本职工作之外的努力，因为我们相信，所谓的工作，并不能阻止一个真正热爱写程序的人求知的心：即便他只是Java程序员，并不妨碍他了解Ruby；即便工作再忙，他也会抽空学点东西。如果候选人曾经利用时间做过一些东西，那是我们乐于见到的，如果再能涉猎更多的东西，那简直太好了，当然，我们会问一些问题，了解他是“听说、了解、用过，还是深入研究过”。</p>\n<p>单就面试过程而言，ThoughtWorks的面试并没有特别的。但为什么还有很多人会觉得这个过程很难。或许，这就是他们习惯的工作方式与我们工作方式的差异所在。</p>\n<p>众所周知，ThoughtWorks在“如何做软件”方面是走得很靠前的。当我们的客户还在考虑ClearCase是否要切换成SVN时，我们已经抛弃了SVN，拥抱了git；当很多公司开始做持续集成时，我们已经开始了持续交付；当许多人开始拥抱敏捷时，我们正逐步地“去敏捷”。</p>\n<p>在ThoughtWorks工作，我们要找的是真正热爱技术的人，喜欢刨根问底的人，那种为了完成而完成的人不是我们想要的。在公司里，我们经常会听到这样的话：我们不只要实现功能，更要以正确的方式来做。追求是无止境的，所以，我们要找的就是具备深入思考的能力/潜力的人，这样，我们才能不断向前。</p>\n<p>在很多的人印象中，ThoughtWorks有一群特别能说的人，没错，在我们的工作里，沟通占了很大的比例，无论是我们在交付项目中，还是咨询项目里；无论是与自己人，还是与客户。所以，在面试中，我们也特别重视一个人的表达能力，肚子有货的人是否能够清晰地表达出来，而表达能力往往是一面反映多方面能力的镜子：分析能力、组织话题的能力、对技术的理解等等。</p>\n<p>以个人观察而言，在程序员这个闷骚遍地的行业里，所谓不擅与人沟通的程序员只是没有找到合适的环境。其实，表达能力完全是可以锻炼出来的。还记得我第一次在东软给别人讲东西的时候，紧张得手心里全是汗。在公司内部主动讲讲东西，在社区活动做一些分享，多讲几次，什么问题就都没有了。</p>\n<p>其实，所谓ThoughtWorks面试难，在我看来，只不过与其他公司只重视技术能力而言，我们更注重全方位的工作能力而已。因为在ThoughtWorks，我们是程序员，但我们不只是程序员。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201112282147",
    "date": "2011-12-28",
    "time": "21:47",
    "title": "Hello，Node.js（五）",
    "tags": [
      "node.js"
    ],
    "body": "<p>JavaScript是一门已然成为主流的程序设计语言，但无可否认，作为急就章的产物，它还是有很多不令人满意的地方，需要<a href=\"http://dreamhead.blogbus.com/logs/109407571.html\" target=\"_blank\">专门有人告诉我们怎么用它</a>。</p>\n<p><a href=\"http://coffeescript.org/\" target=\"_blank\">CoffeeScript</a>边产生于这种背景之下，它就是为了回避JavaScript的丑陋。说穿了，CoffeeScript只是JavaScript的语法糖，所有的CoffeeScript代码最终都会转化成JavaScript代码。</p>\n<p>Node.js既然是一个JavaScript的平台，当然也会对CoffeeScript张开怀抱。在Node.js下运行CoffeeScript，首先要安装：<br>&nbsp; npm install coffee-script</p>\n<p>万事俱备，先来问候吧！</p>\n<p>&nbsp; console.log 'hello, coffee'<br>&nbsp; (hello.coffee)</p>\n<p>然后，运行起来：<br>&nbsp; coffee hello.coffee</p>\n<p>终端上就会出现<br>&nbsp; hello, coffee</p>\n<p>之前说过，CoffeeScript代码会转化成JavaScript，我们来看一下由CoffeeScript转化出的JavaScript代码，只要在命令里加入参数即可：<br>&nbsp; coffee -c hello.coffee</p>\n<p>对应的js文件会产生在当前目录下：<br>&nbsp; (function() {<br>&nbsp; &nbsp; console.log('hello, coffee');<br>&nbsp; }).call(this);<br>&nbsp; (hello.js)</p>\n<p>包裹在外面的结构让这段代码成为可执行脚本，真正与我们的问候对应的代码实际上是<br>&nbsp; console.log('hello, coffee');</p>\n<p>当CoffeeScript遇见Node.js，我们就拥有了一个良好的编程平台：不错的运行时环境，加上良好的语言表现力，它们甚至可以让我们忘记了JavaScript的存在。是的，如果初涉Node.js，不妨从CoffeeScript起步。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201112082118",
    "date": "2011-12-08",
    "time": "21:18",
    "title": "Hello，Node.js（四）",
    "tags": [
      "node.js"
    ],
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/105599686.html\" target=\"_blank\">Hello，Node.js</a><br><a href=\"http://dreamhead.blogbus.com/logs/106188588.html\" target=\"_blank\">Hello，Node.js（二）</a><br><a href=\"http://dreamhead.blogbus.com/logs/106592931.html\" target=\"_blank\">Hello，Node.js（三）</a></p>\n<p><strong>版本管理器</strong></p>\n<p>Node.js的发展速度是令人吃惊的，不长时间就会有一个新版本推出。每次追着升级新版本是一件让人不爽的事情，尤其是每次都去手工编译安装。</p>\n<p>Ruby世界的人们不满意Ruby混乱的版本管理，于是有了<a href=\"http://beginrescueend.com/\" target=\"_blank\">RVM</a>，同样，Node.js世界有了<a href=\"https://github.com/creationix/nvm\" target=\"_blank\">NVM</a>。顺便说一下，在程序员的世界里，VM除了代表Virtual Machine，也代表Version Manager。</p>\n<p><strong>安装NVM</strong></p>\n<p>首先，我们需要得到nvm：</p>\n<p>&nbsp; git clone git://github.com/creationix/nvm.git ~/.nvm</p>\n<p>执行成功之后，我们得到了nvm，为了让nvm起作用，我们可以执行：</p>\n<p>&nbsp; . ~/.nvm/nvm.sh</p>\n<p>但是，这种做法只能在当前的shell会话中起作用，为了长治久安，一种更好的办法是把它加入到shell的配置文件中，根据不同的环境，它可能是~/.profile，~/.bashrc等等。我们把下面这句加入其中：</p>\n<p>&nbsp; [[ -s \"$HOME/.nvm/nvm.sh\" ]] &amp;&amp; . \"$HOME/.nvm/nvm.sh\"</p>\n<p>这样，启动一个新shell会话，我们就可以直接使用nvm了。</p>\n<p>好了，环境就绪，我们可以使用它了。</p>\n<p><strong>NVM基本用法</strong></p>\n<p>我们可以了解一下nvm的基本用法：</p>\n<p>&nbsp; nvm help</p>\n<p>安装一个新版本的Node.js：</p>\n<p>&nbsp; nvm install v0.6.4</p>\n<p>注意，这里的版本号里有个v，而在别的命令里，并不需要这个v。</p>\n<p>这个命令简化了Node.js的安装过程，它会在Node.js的发布库中找到对应的版本下载，然后进行安装。安装node.js的同时，nvm也会把npm替我们安装好，这样，我们就具备一个开发最为基本的环境。</p>\n<p>使用一个安装好的版本：</p>\n<p>&nbsp; nvm use 0.6.4</p>\n<p>用一个特定版本运行程序：</p>\n<p>&nbsp; nvm run 0.6.4 echo_server.js</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201110312328",
    "date": "2011-10-31",
    "time": "23:28",
    "title": "IT，悲伤十月",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>10月5日，Steve Jobs<br>10月12日，Dennis Ritchie<br>10月24日，John McCarthy</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Steve_Jobs\" target=\"_blank\">Steve Jobs</a>，苹果公司创始人，一生惊艳世人作品无数。<br><a href=\"http://en.wikipedia.org/wiki/Dennis_Ritchie\" target=\"_blank\">Dennis Ritchie</a>，C语言之父，Unix创造者之一。<br><a href=\"http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)\" target=\"_blank\">John McCarthy</a>，Lisp语言发明者，人工智能之父。</p>\n<p>Steve Jobs重新定义了很多东西，比如计算机，比如音乐播放器，比如电话。他用实际行动告诉人们，完美不只是说说而已。</p>\n<p>Dennis Ritchie对计算机行业本身的贡献远远大于他所受到的关注，时至今日，还有许多人在学习和使用C语言写程序，许多新程序设计语言都只是在C语言的路上不断扩展。至于Unix，那几乎就是整个网络时代的基础。</p>\n<p>John McCarthy给人们展示了程序设计语言的另一极，Lisp这个似乎是半成品的语言，其魅力正日益绽放。人工智能则打开了人们探索计算机极限的道路。</p>\n<p>纪念Steve Jobs，读《<a href=\"http://book.douban.com/subject/6798611/\" target=\"_blank\">乔布斯传</a>》。<br>纪念Dennis Ritchie，回顾<a href=\"http://book.douban.com/subject/1139336/\" target=\"_blank\">C语言</a>。<br>纪念John McCarthy，学习<a href=\"http://book.douban.com/subject/6859720/\" target=\"_blank\">Lisp</a>。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201110272310",
    "date": "2011-10-27",
    "time": "23:10",
    "title": "探路持续交付",
    "tags": [
      "开发笔记"
    ],
    "body": "<p>眼下的这个项目是一个有趣的项目，它让我收获极大的部分并不在于写代码本身，更多的是关于软件开发的“<a href=\"http://en.wikipedia.org/wiki/Last_mile\" target=\"_blank\">Last Mile</a>”。</p>\n<p>自动化，让团队从繁琐重复中解脱出来的一个重要途径，这是所有一切的基础。一句话，能自动化的尽量自动化。</p>\n<p><strong>构建</strong></p>\n<p>在给InfoQ写的一篇文章中，我已经尝试总结了一些通用的内容，这里不再赘述。</p>\n<p><a href=\"http://www.infoq.com/cn/articles/zy-software-development-foundation\" target=\"_blank\">软件开发地基</a></p>\n<p><strong>在云端</strong></p>\n<p>之前参与过的一些项目，很大的一个挑战在于环境。我们没有足够的机器用来做出足够的环境。</p>\n<p>这个项目使用了Amazon EC2。在我们需要一台机器的时候，我们会敲下一个命令，自动在云端创建出一个完整的测试环境。当测试完毕，同样是一条命令，这个机器就烟消云散了。这种做法让团队按需创建自己的环境。</p>\n<p><strong>DevOps</strong></p>\n<p>有了机器，机器的内容是由我们自己决定的。托DevOps运动的福，这一切变得容易起来。所谓infrastructure as code。</p>\n<p>我们采用<a href=\"http://www.opscode.com/chef/\" target=\"_blank\">Chef</a>将所有的配置管理起来。比如，当我们搭建一台机器的时候，需要一个应用服务器，也需要安装我们最新的版本，所有这一切都是由脚本管理的。我们只要一条命令敲下去，那台在云中搭建出的新机器上就自动包含了所有这一切。</p>\n<p>小结一下，云解决了机器问题，DevOps解决了配置问题。</p>\n<p><strong>自动化测试</strong></p>\n<p>自动化测试是所有一切验证的基础。相比于之前的项目，这个项目的一大进步在于验收测试。我们采用<a href=\"http://cukes.info/\" target=\"_blank\">Cucumber</a>做为我们的验收测试描述工具。比之于TDD，在验收测试的层面上，我们做的是BDD。</p>\n<p>这更进一步的是，我们会从0开始搭建整个测试环境，然后，运行测试。基于前面的描述，这种测试会运行在云中。</p>\n<p><strong>部署流水线</strong></p>\n<p>有了上面的基础，我们构建了一条“部署流水线”。下面简单描述一下我们的“流水线”：</p>\n<ul>\n<li>完成一个修改时，开发人员会在本地运行提交脚本。这个脚本会运行诸如编译、测试、质量检查等方面的东西。通过之后，才可以真正的提交。</li>\n<li>CI软件检测到新代码提交之后，就会启动“部署流水线”。首先是在提交阶段验证，内容与开发人员本地验证的内容相仿。</li>\n<li>通过提交验证之后，进入到下一阶段，在云环境中创建出一个部署了最新软件的服务器，基于这个环境进行端到端的测试。</li>\n<li>端到端测试之后，将软件发布到一个中央仓库里，这就是一个发布候选版本了。如果有需要，我们可以取出这个版本进行更多的探索测试和性能测试等。</li>\n<li>负责运营的人，根据需要，发布适当的版本上线。</li>\n</ul>\n<div>基于这样的基础设施，我们有了持续交付的基础。从第一次正式上线之后，我们很快又发布了第二次，修正了前一次发布之后发现的问题，不再有那种为了上线的忙碌。</div>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201109272332",
    "date": "2011-09-27",
    "time": "23:32",
    "title": "演进的标准",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>《<a href=\"http://book.douban.com/subject/4204104/\" target=\"_blank\">哪来的天才</a>》有一段关于标准的论述，简而言之，标准在不断提高。1908年奥运200米奥运冠军的成绩是22.6秒，比现在的高中生记录慢2秒；今天的高中马拉松最好成绩比1908年奥运冠军快了20分钟。</p>\n<p>做软件的标准也是在不断提高的：</p>\n<ul>\n<li>写代码，原来是完成功能，现在是写出Clean Code</li>\n<li>测试，以前是最后人工测试，后来是自动化测试，再是TDD，现在要BDD</li>\n<li>构建过程，最初是在开发最后集成，过渡到每日构建，再到持续集成，现在要求持续交付</li>\n<li>自动化，曾是全手工，到使用构建脚本编译测试，再是日常工作的自动化，现在是基础设施也自动化的DevOps</li>\n<li>做项目，开始是交付，现在我们追求团队成长，包括团队的做事能力和每个人的成长</li>\n<li>……</li>\n</ul>\n<p>做程序员的标准也一样在提高，在我现在的团队里，做程序员不能只是低头写代码：</p>\n<ul>\n<li>我们要与人交流，因为我们要结对，我们要与客户交流</li>\n<li>我们要分享知识，因为我们要有一个学习氛围，每个人都要为此做出贡献</li>\n<li>我们要为团队氛围做贡献，因为我们不仅仅要工作，更要快乐的工作</li>\n<li>我们要帮助其他人，因为别人也在不同的方面帮助我，我才能得到成长</li>\n<li>我们要从团队的角度想问题，因为项目不是人的，项目成功才有个人成功</li>\n<li>我们要不断提高，因为每个人都在进步，不进则退</li>\n<li>……</li>\n</ul>\n<p>在不同的标准下做事，人得到的成长也是不同的。你做事的标准是什么呢？</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201109201929",
    "date": "2011-09-20",
    "time": "19:29",
    "title": "读《哪来的天才》",
    "tags": [
      "书评"
    ],
    "body": "<div style=\"color: #000000; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #ffffff; line-height: 160%; background-position: initial initial; background-repeat: initial initial; margin: 5px;\">\n<p>天才，人人都羡慕，但那是天赋的事，羡慕一下就好了，于己，我行我素。不过，如果有人告诉你，其实，根本就没有天才，所谓的天才，只不过是大量的练习造就的，你会做何感想呢？</p>\n<p>《<a href=\"http://book.douban.com/subject/4204104/\" target=\"_blank\">哪来的天才</a>》就是这样一本打破神话的书。</p>\n<p>这本书的内容说穿了简单得一塌糊涂：刻意练习。没有天才，只有坚持不懈的刻意练习。所谓的天才，只不过是做了大量的刻意练习而已。用一句老话说，要想人前显贵，必须背地里遭罪，如此而已。</p>\n<p>刻意练习，不同于我们通常所说的练习，它具有如下特征：</p>\n<ul>\n<li>为了提高绩效而被设计出来的</li>\n<li>可以重复很多次</li>\n<li>可以持续得到对结果的反馈</li>\n<li>非常费神</li>\n<li>没有多少乐趣</li>\n</ul>\n<p>第一条是非常重要的，为提高绩效而被设计出来的，这使得它不同于普通的练习。这就需要有个评价，怎么算是提高。这也是一个教练很重要的地方，旁观者清，所以，有第四条，可以持续得到对结果的反馈。从刻意练习的描述来看，这着实是一个比较无趣的过程，这也是很多人难以坚持的原因。</p>\n<p>大多数人习惯于在自己的舒适区练习，这是很多人水平停滞不前的重要原因。10年工作经验，到底真的是10年工作经验，还只是一年的工作经验重复了10遍，这是有差别的。刻意练习就是把人踢出舒适区，进入学习区练习。</p>\n<p>《<a href=\"http://book.douban.com/subject/3688489/\" target=\"_blank\">异类</a>》告诉我们，要想有所成就要练一万个小时，《哪来的天才》则告诉我们，怎么练这一万个小时。</p>\n<p>或许，你只打算做个普通人，并不准备在某些领域花一万个小时，但刻意练习依旧可以让人从中受益，在我们的专业领域得到最基本的训练，很快通过最初的菜鸟期。比如，如果你是一个程序员，那我们可以选择一个程序反复实现，这会极大程度上锻炼自己对于编码的熟练程度，练习对于快捷键的使用。如果有个水平比你高的人愿意帮忙，同样，可以反复实现一个程序，让他来帮助检查，给予反馈，提高自己写程序的质量。</p>\n<p>所谓天才说，给了我们足够的懒惰理由：人家是天才，我不是。所以，我有理由做得没有人家好，有理由不如人家出色。《哪来的天才》无情的击碎了这样的借口，让懒惰无处遁形。</p>\n</div>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201109062308",
    "date": "2011-09-06",
    "time": "23:08",
    "title": "成长的“压力”",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>最近，很多人和我聊起了同一个话题：在旁观者看来，西安办公室新人的压力很大。</p>\n<ul>\n<li>一个刚刚参加工作的毕业生说，他家人评价，即便是念书的时候，他也没有像现在这样认真的读书。</li>\n<li>有人感慨，自己的知识近乎清零，要花大量时间学习。</li>\n<li>有人每天早来一个小时，晚走一个小时，为了多点时间看项目里的代码。</li>\n<li>……</li>\n</ul>\n<p>如果你把这些现象视为压力，那这确实是很大的压力，但我更愿意视之为动力，因为没有任何人强迫他们做这些事情，这些新人所做的一切都是他们自发的。</p>\n<p>我们从没有强求任何人有事没事就加班到八九点钟，弄得身心俱疲，对我而言，那才是一种压力，一种可以把人压垮的力量。</p>\n<p>这些新员工如此努力，全拜环境所赐。</p>\n<p>我们努力在西安办公室营造的就是一种学习氛围，我们会组织各种各样的培训，在项目组里面会对大家在做事上提出各种高要求。所有到过西安办公室的人，无论是来自其他办公室的人，还是我们的客户，大家都深深的喜爱这种学习氛围。</p>\n<p>对于新人来说，这样的氛围，再加上在日常工作中看到的与其他人的差距，就促使他们必须额外的下很多功夫，才不致于为其他人抛远。于是，才有了前文见到的那种种现象。回想自己工作之初，每天花了大量时间看书写代码，不过，我从来没觉得那是一种压力，因为那样的努力带给自己的是成长。</p>\n<p>在这种氛围下，那些进入公司才一年的人纷纷在各个项目上挑起大梁，这在很多公司是不可想象的。我依然记得某个刚刚进入公司的新员工知道一些人才刚刚毕业一年时吃惊的神情，在他看来，这些人的能力和做事的程度是很长时间才能锻炼出来的。他得到的结论是，他也要加把劲了。</p>\n<p>确实，有人不适应这种生活。毕业生里有人就觉得这是一种“压力”，他需要的是更舒服的生活，于是，放弃了我们的offer。每个人都有自己的选择，从我个人的角度，我也觉得他做了一个好的选择，因为他确实不适合我们，我着实不喜欢这样的工作伙伴。</p>\n<p>有人看到<a href=\"http://dreamhead.blogbus.com/logs/158716647.html\" target=\"_blank\">我的blog</a>，认为我对项目组成员要求太严格，感觉压力很大，但他却很喜欢这种压力，希望有朝一日能够感受这种压力，这种能带给人成长的“压力”。</p>\n<p>成长是自己的事，强迫不来。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201109032256",
    "date": "2011-09-03",
    "time": "22:56",
    "title": "敏捷中国2011",
    "tags": [
      "脚下的路",
      "敏捷"
    ],
    "body": "<p>果然是按照个人规律来的，我又参加了单数年的Agile China。</p>\n<p>其实，真正仔细听的只有两个人的session，吴军和Fred George。至于其它关于敏捷的讨论，好吧，我承认，我不是很感兴趣。</p>\n<p>刚看完吴军的《<a href=\"http://book.douban.com/subject/6709783/\" target=\"_blank\">浪潮之巅</a>》，于是，很敢兴趣他关于工程师的说法。在《浪潮之巅》里，他提到了五级工程师的说法，但是，书中并没有详述何为五级工程师，在敏捷中国上，他给出了答案：</p>\n<ul>\n<li>五级：能独立完成工程工作</li>\n<li>四级：能带领其他人一同完成更大的工作</li>\n<li>三级：能独立设计和实现产品</li>\n<li>二级：能设计和实现别人不能做出的产品</li>\n<li>一级：开创一个bussiness</li>\n</ul>\n<p>在我看来，这个标准是以做事的能力和取得的成就来衡量的。在书里，吴军给自己的定位是2.5级，而对比他给出的二级人物，Jeff　Dean（云计算始祖）、Donald　Knuth（Latex）等人，这已经是一个相当高的级别。</p>\n<p>吴军鼓励大家都去做一流的工程师，也给出了一些成为一流工程师的建议。会后，我问了他一个问题，在我看来，这个session里面的内容是如何成为一个三级工程师，那如何做到一二级呢？吴军笑了笑，这个还要看机缘，有没有机会和一二级的人物一起合作，在他们的点拨之下再进一步。</p>\n<p>这个答案有些宿命论的成分，但我也承认，如果没有见过高手，何谈成为高手。这也是很多中国程序员的悲哀，压根没有见过什么是高水平的程序员。从之前一些团队的合作过程中，我们让很多人知道了原来写程序也可以这样有趣，有人甚至抛弃了原来的管理身份，重回程序员的行列。</p>\n<p>这个session也让我看到了一些新的努力方向，但对我而言，也应该多想办法接触境界水平更高的人才行。</p>\n<p>Fred像个老顽童，０９年的敏捷大会，我就听过他的session。这次，他又来了。我记不清是上次大会是他的演讲，还是事后的沟通，他这次的话题，我总觉得他曾经说过。只不过，坐在下面仔细听一遍，还是更新了我对很多问题的认识。</p>\n<p>在他看来，团队之间有各种各样的角色也是一种浪费，所以，在他的团队里面，只有一个角色Agile　Developer，他们应该懂得如何客户打交道，懂得交付正确的软件。这确实是个挑战！</p>\n<p>在我的团队里面，我们试图减少开发人员与客户之间的距离，开发人员，即便是一个刚工作几个月的毕业生，一旦有问题，都会直接去找客户。我们也会让人承担不同的角色，程序员也要去做部署，也要做一些测试。但是，我们还是有不同的人挂着不同的名。</p>\n<p>Fred告诉了我们一个新词：anarchy。它告诉我们，我们需要程序员高度的自治，所有人都要有很强的能力，自己能做事。对于很多中国公司来说，太多的程序员习惯于被人管，而不习惯于自治。所以，这是一种挑战。</p>\n<p>无论是吴军还是Fred，他们的session讲的实际上都是一个自主程序员自己做事的故事。真正的改变是自发的，所谓的咨询师或是所谓的交流，能给予的帮助，是有限的。而这恰恰是很多公司实施敏捷欠缺的。</p>\n<p>高端对话里，有人说，如果一个lead不想改变，那就开了他。这种说法非常极端，但某种程度上，我们不得不承认，有时改变真的被某些人阻碍着。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201108292312",
    "date": "2011-08-29",
    "time": "23:12",
    "title": "你在用程序库吗？",
    "tags": [
      "脚下的路",
      "开发笔记",
      "程序库"
    ],
    "body": "<p>早上的Code Diff，项目组的所有人坐在一起过一遍上一个工作日写的代码。</p>\n<p>“这个测试为什么这么写？”我质疑了一段有文件读写的测试。<br>“因为我要测文件读写。”这段代码的作者回答道。<br>“你真的需要吗？文本内容相关的测试可以用字符串。”<br>“真的需要，我真要测文本读写。”<br>“好，下来一起看看。”</p>\n<p>Code Diff结束，我们坐在一起。他给我介绍了一下这段代码的作用：把文件的内容按行读成一组字符串。</p>\n<p>看着那段充满着各种异常处理的文件读写的Java代码。<br>“嗯，确实是需要文件读写，这点我同意。”我说。<br>我看到一丝放松从他脸上闪过。<br>“不过，为什么要自己实现这个功能呢？”<br>“啊？”他惊讶了一下。<br>“为什么不用Guava库？”<br>“Guava还支持这个？”<br>我无奈的笑了一下，“是啊，Guava很强大的。”我给他找了Guava实现这个功能的API，展示了一小段代码。<br>“哦，好吧，我回去改一下。”</p>\n<p>现代软件开发已然不同于那个纯手工打造的年代，写程序时，我们通常会使用一些程序库，但是，很多人对于程序库的使用仅限于别人已经在程序里面用到的用法，并不越雷池半步，所以，常常会有不少人累死累活写出来不稳定的代码去实现程序库里的现成功能。</p>\n<p>这已经不是我第一次在项目里面提到这个问题。前不久，有人辛辛苦苦用正则表达式实现出一段非常华丽的匹配，从URL中提取参数。直觉告诉我这么做是不对的，我们在用Spring MVC，既然Spring可以很好的提取这些参数，为什么我们要自己写。</p>\n<p>在直觉的驱动下，我研究了Spring MVC的部分实现，于是，PathMatcher浮出水面。采用PathMatcher之后，那些复杂到不是一下子能看懂的正则表达式烟消云散了。</p>\n<p>既然我们用到了程序库，那就真的用一下这个程序库吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201108252328",
    "date": "2011-08-25",
    "time": "23:28",
    "title": "乔布斯，休息一下",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>作为一个IT人，对我而言，今天最大的新闻是乔布斯辞去了CEO。</p>\n<p>喜欢研读业界八卦的我，很早就知道了很多关于乔布斯和苹果的故事，包括他和另一个史蒂夫创建了苹果，苹果II开创了真正的个人电脑时代，他被自己创建的公司扫地出门，又几经周折，重回苹果等等。</p>\n<p>在《阿甘正传》里，有人给阿甘买了一个水果公司的股票。</p>\n<p>开始了解苹果故事时，苹果如果不是处于最低谷也差不多，那时，在我心目中，苹果还是太遥远了，虽然它很漂亮。估计如果《阿甘正传》那时候拍摄的话，导演不会给他买苹果的股票，但是，不得不说，导演还是很有眼光，苹果起死回生了。</p>\n<p>我真正开始用苹果产品的时间并不长，从MBP和ipad开始。无论是写程序用的MBP，还是日常使用的ipad，除了苹果产品一直特有的美感，细节之处也是让人感觉很舒服，比如MBP的电源不像其他PC那样紧，不会因为绊到线上，把笔记本踢翻。当然，即便只有美感，也足以让很多人掏出一大笔银子了，君不见很多人抱着MacBook，用着Windows。</p>\n<p>秉承一贯把事情做到极致的风格，乔布斯带领着苹果公司在新千年开始改变世界的进程：ipod、iphone、ipad等等，几乎每个产品都会改变人们的行为模式。其实，所有这些产品，苹果都算不上先行者，但他就是能把一些烂大街的东西做出新特色，这就是所谓的创新。</p>\n<p>新近在读《浪潮之巅》，推动着社会不断前进的动力就是这种创新。没有google之前，我们意味搜索只是按目录查找；没有iphone，手机只能是电话、MP3和闹钟，也许还有记事本；没有ipad之前，我们以为我们只能用电脑。</p>\n<p>一个人能够引领一次变革已然不易，更何况成为多次弄潮儿，而乔布斯就是这样的人，不要忘了那个叫pixar的动画制作室给我们带来的惊喜。在所有这一切的改变里，我们看到的是一个乔布斯，一个追求极致的乔布斯。他用自己的行动告诉我们，把事情做对做好，大有可为。虽然不是每个人都能成为乔布斯，但每个人都可以尽力把事做好，做向极致。</p>\n<p>虽然各大公司都有很厉害的领军人物，但没有谁像乔布斯一样对公司有如此大的影响力，他的身体状况直接决定着苹果的股价。英才或许总招天嫉，正值壮年的乔布斯不得不因为身体放慢前进的脚步了。虽然他的个人魅力让苹果的股票应声下跌，但我依然期待着更多的来自苹果的创新，改变人们的生活，也期待着乔布斯还能回来，带给我们更多惊喜。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201108242311",
    "date": "2011-08-24",
    "time": "23:11",
    "title": "迈向《Continuous Delivery》",
    "tags": [
      "持续交付",
      "开发笔记",
      "ThoughtWorks"
    ],
    "body": "<div style=\"color: #000000; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; margin-top: 5px; margin-right: 5px; margin-bottom: 5px; margin-left: 5px; background-image: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #ffffff; line-height: 160%; background-position: initial initial; background-repeat: initial initial; \">\n<p>前不久，Perryn Fowler在西安办公室帮忙，闲暇时，他捧着本书在读，我问他什么书，《<a href=\"http://www.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912\" target=\"_blank\">Continuous Delivery</a>》。他说，你应该读一下。</p>\n<p>最近，客户负责我们这个项目的人在我们的办公室里，他也经常在翻一本书，我很好奇，结果，《Continuous Delivery》。他说，你应该读一下。</p>\n<p>今年的<a href=\"http://drdobbs.com/joltawards/231500080\" target=\"_blank\">Jolt大奖发布</a>了，获奖者是《Continuous Delivery》。</p>\n<p>作为一个ThoughtWorker，这本书里描述的很多东西对我来说，并不算陌生，很多东西甚至是我做咨询的时候，讲给客户听，帮着客户做的。但还是有很多东西，超出了我对问题的认识，换句话说，比我以为的步子更大。</p>\n<p>持续交付这个概念，即便是在ThoughtWorks内部来说，也是一个很新的领域。以前，我们更多谈到的是持续集成。通过一些项目实践，我们发现很多内容逐渐超出了持续集成的范围。</p>\n<p>当build越来越复杂的时候，我们会考虑将build分解到不同的阶段，每个阶段的build承担不同的职责，提交阶段主要做单元测试和集成测试，在提交阶段成功之后，后面的阶段开始做验收测试。</p>\n<p>原本build分阶段只是为了解决放在一起时间太长的问题，但一旦开始分阶段，我们就会思考，是不是在不同的阶段以不同的目的做一些事情。比如，经过验收阶段，我们就可以给QA提供一些做探索性测试的版本，再比如，我们是不是可以需要有一个专门做性能测试的阶段等等。于是，形成了一个所谓的build pipeline。</p>\n<p>通过了build pipeline的发布包，基本上可以认为它是功能上可用的。我们需要能够把它更方便的方式将其发布到产品环境中。这就是所谓devops做的事情：把基础设施当做代码。仔细想一下就不难发现，只要能够把基础设施代码化，那也就可以反过来，用在build里面的。</p>\n<p>如果有足够的环境，比如使用云，我们就可以一键式的把整个环境，包括各种软件和我们的发布包，一并发布到云上，这样配合我们的验收测试用例，就可以做真正的端到端的测试。</p>\n<p>如果所有一切就绪，我们的工作模式就变成了，开发人员提交一段代码，如果可以顺利通过build pipeline，也就是经过了功能测试和部署测试，形成了一个候选的发布包。只要有人同意，随时随地就可以真正发布了。</p>\n<p>我还没有读过《Continuous Delivery》，而上面提到的一切，正是我们在现在这个项目里努力做的事情。这是在从前想都不敢想的事情，而如今，我们正在实现它。</p>\n<p>我真的需要读一下这本书，让自己对持续交付有一个更完整的认识。诚如Jolt评奖词中所写，这会是一本改变游戏规则的书。</p>\n</div>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201108152326",
    "date": "2011-08-15",
    "time": "23:26",
    "title": "实现继承，语言缺陷",
    "tags": [
      "面向对象",
      "我眼看世界"
    ],
    "body": "<p>\n</p><p>zhaorui在《<a href=\"http://dreamhead.blogbus.com/logs/149046104.html\" target=\"_blank\">When You Click…</a>》回复：<br>“实现继承是某种程度上的语言缺陷” 这个我也不太理解，是否可以解释一下</p>\n<p>好，那就解释一下。</p>\n<p>面向对象的三个特征是什么？一个本科毕业生都可以对答如流：继承、封装和多态。在常规的理解中，继承分为实现继承和接口继承。简单说，实现继承就是为了把代码拿过来复用，而接口继承是给多态做准备。</p>\n<p>面向对象和基于对象的差别就在于多态，程序是不是面向对象，看看有没有多态就知道了。我们还提倡面向接口编程，探究is-a关系，讲求各种各样的设计原则，讨论各种各样的设计模式。但仔细想一下就会发现，所有这些讨论都是围绕着多态，也就是接口继承的，跟实现继承没有任何关系。</p>\n<p>那实现继承为什么还如此阴魂不散的围绕在我们身边呢？</p>\n<p>最早大面积流行的面向对象程序设计语言是C++，所以，C++的选择影响了很多人，包括后来者Java和C#。所以，很多程序员一想到继承，就会想到把一些方法抽到基类里面，也有很多人愿意为了实现一个集合类，让自己的类继承自某个collection。其实，我们真正想要的不是继承，而只是要把一些公共操作放到一个地方，方便复用。</p>\n<p>有了实现继承，随之而来会有很多问题，其中最著名的莫过于钻石问题。它的根源在于多重继承，绝大多数使用多重的场景只是为了从别人那里拿个实现过来。许多新语言都惟恐避之不及的躲开多重继承，事实证明，没多重继承，我们依然活着，还活得挺好。</p>\n<p>如果你的世界里只有C++/Java/C#，那这是个让人头疼的问题，虽然有人会告诉你，少用继承，多用组合。但你也知道，写一大堆delegate，也挺讨厌的。说白了，语言不给力。</p>\n<p>好吧！你知道我要说语言的事了。如果了解过Ruby，你应该知道module，如果你是个Scala程序员，trait是个利器。某种程度上说，C#的extension method也能做这件事。这些语言特性都能很好的解决真正的问题：代码复用。我们只要把需要复用的代码放到module/trait/extension method里，复用的问题就迎刃而解了，而无需小才大用的使用继承。</p>\n<p>其实，如果语言可以解决复用的问题，那么，仔细想一下，我们会发现某些设计不甚合理的地方，比如Rails里面，Model为什么要从ActiveRecord::Base继承而来，我们只是需要某些能力而已，这样的话，也许把ActiveRecord::Base实现成一个module更为合理。</p>\n<p>仔细了解一下语言的实现，我们不难发现，这些机制往往是在底层通过继承实现的。这从另外一个角度说明，或许实现继承本身就应该是一个底层实现，而非语言层面上的东西。</p>\n<p>对于程序员来说，只会一门语言或一系列类似的语言，无疑于手里只有锤子，那时，眼里都是钉子，闭塞得很，可惜，这是大多数程序员的现状。</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201107312314",
    "date": "2011-07-31",
    "time": "23:14",
    "title": "当单复数需要转换",
    "tags": [
      "开发笔记"
    ],
    "body": "<p>项目组里的一个程序员走过来：这个地方要怎么处理？</p>\n<p>问题是这样的，系统里会根据tag搜索图片，于是，在搜索结果页面上，有这样一个提示，显示某个空间的所有图片，比如：Show All Kitchen Images。在我们的系统里，所有空间tag都是复数的，比如kitchens。</p>\n<p>看到了吗？问题就在于此。页面的提示是单数，而在系统里存储的是复数。怎么办？</p>\n<p>程序员的直觉是用程序解决这个问题。</p>\n<p>一开始我们想做一个简单的去“s”处理，但是，需求告诉我们，tag可能会改变，所以，简单的去“s”是不够的，也许，我们需要一个算法将复数变成单数。于是，我们想搜一个单复数转换的算法。</p>\n<p>在搜索之前，我们还是先讨论一下有没有其他的方案。</p>\n<p>因为tag数量有限，我们想做一个简单的映射。把它写死在程序里的方案最简单，但也是最不灵活的方案。所以，想到的一个方案是，用一个文件做映射，在运行时加载进来。身为程序员，我们都觉得这个方案是可行的。</p>\n<p>就这样做吗？大家都满意了，可以开始动手了。但是，请等等。我们还有业务分析人员，我们的BA。</p>\n<p>于是，BA同学跑去和客户商量如何解决问题，客户的答案是，把这段提示稍微改一下：Show All Images for Kitchens。</p>\n<p>这是个令费尽心思想解决方案的程序员吃惊的答案，简单到令人发指，只要改一下页面提示，根本无需考虑什么解决方案。</p>\n<p>其实，这是一个关于沟通的故事，特别献给愿意走进牛角尖，用技术解决业务问题的程序员们。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201107192221",
    "date": "2011-07-19",
    "time": "22:21",
    "title": "When You Click…",
    "tags": [
      "ThoughtWorks",
      "MindMap"
    ],
    "body": "<p>\n</p><p>最近在公司里面带着人做思维训练，每两周一次，话题很简单：When You Click…</p>\n<p>实际上，我们讨论的是一张<a href=\"http://en.wikipedia.org/wiki/Mind_map\" target=\"_blank\">mind map</a>。如我们所知，mind map是由一个个节点组成，这里要Click的就是mind map上的一个个节点。</p>\n<p>这张mind map是什么，就是所谓的知识体系。</p>\n<p>我们的起点是，作为一个专业的ThoughtWorker，我们应该了解哪些知识。大家在一起讨论出哪些内容是我们应该掌握的，那是一张非常大的mind map。我们接下来的思维训练就是围绕着这张mind map进行的。</p>\n<p>每次，我们只选取其中一个节点，所谓“When You Click”，就是当我们讨论到这个词的时候，我们会想到什么东西。大家一起抛出自己根据这个词想到的东西。比如，我们已经进行过的几次讨论包括Web开发、OO等话题。</p>\n<p>在讨论中，我们会发现一些很有趣的事。比如：<br>\n</p><ul>\n<li>谈及Web开发，很多人就只能想到用Web做网页，殊不知，现在越来越多的Web已经用来服务。</li>\n<li>涉及继承时，很多人都会说到实现继承，却不知道实现继承是某种程度上的语言缺陷。</li>\n</ul>\n<p></p>\n<p>所以，通过讨论，通过知识分享，要达到的目的是给参与的各位一个扩展自己知识面的机会。事实上，上面所举的例子，也确实让我们看到了这种知识偏颇的存在。</p>\n<p>之所以要组织这样的活动，是因为有一些新加入公司的人常常不知道自己在知识上有哪些缺陷，需要补充。通过这样的活动，我们可以帮助大家建立一个知识体系。其实，对于任何一个新人来说，知识的欠缺本身不是问题，而让人不爽的是两眼一抹黑的感觉，有了一个相对完整的知识，就可以有针对性的对知识进行补充。</p>\n<p>如果有兴趣，你也可以找几个朋友一起尝试做这样的思维训练。给自己一个词，When You Click时，你们会想到什么呢？</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201107142323",
    "date": "2011-07-14",
    "time": "23:23",
    "title": "人来人往",
    "tags": [
      "ThoughtWorks"
    ],
    "body": "<p>最近，人来人往比较多，公司的一些大牛纷纷在办公室现身。通常，来了都不能白来，多是要给我们分享一些东西的。</p>\n<p><a href=\"http://www.jroller.com/perryn/\" target=\"_blank\">Perryn Fowler</a>是西安办公室的老朋友。ThoughtWorks初入中国时，Perryn就来了西安，在中国待了六个月，为ThoughtWorks培养了一批人。按照我们内部的说法，他是gigix和黄亮的老师。传说中，如果和他结对，没写测试就写代码的话，他会打人的。</p>\n<p>他来是帮我们项目做BDD的，接着机会给全办公室做了一次BDD的介绍。天下大事必作于细，虽说我们项目一直有Cucumber Test，但在实际操作中还是犯了很多错误的，Perryn在项目里一周，帮我们纠正了项目在实施BDD所犯的诸多错误。一周下来，对于BDD，对于如何写好测试，Perryn给了我们一些全新的认识。</p>\n<p><a href=\"http://www.linkedin.com/pub/scott-shaw/4/3a/b40\" target=\"_blank\">Scott Shaw</a>，ThoughtWorks亚太区的CTO。他到西安也没得闲，我们项目贡献出自己的代码，他帮我们做了一次代码度量，因为他这次到西安主要的主题是Quality Metrics。所谓Quality Metrics，浅薄的理解，主要用一些工具来度量代码质量。</p>\n<p>于是，我们项目自然而然的成了他在办公室讲这个主题时的举例对象，坏消息是，确实发现了一些诸如包之间依赖的问题，好消息是，按照Scott的说法，我们项目的代码质量，要好于典型的ThoughtWorks项目。</p>\n<p>其实，关于这个话题，让我最觉得有意思的地方在于，度量的可视化。通过一些可视化的方式，把一些度量结果展示出来。曾经，做咨询的时候，只是“觉得”代码质量不好，现在有证据了。图在那一放，很震撼的。我们终于可以理直气壮的说，看，代码烂吧！</p>\n<p>想来这种方式，会受到不少领导的喜爱，为技术改进提供一个起点。诚如Scott所说，这东西就是个参照物，不应该成为标准。不过，会有许多不动脑的人，将其奉为圭臬。</p>\n<p><a href=\"http://rebeccaparsons.com/\" target=\"_blank\">Rebecca Parsons</a>是ThoughtWorks全球的CTO，女性。在这个男性横行的IT世界里，在ThoughtWorks这个技术牛人层出不穷的地方，一个女性成为CTO，那她一定有过人之处。</p>\n<p>刚在北京参加了<a href=\"http://weibo.com/2184519867\" target=\"_blank\">Tech Lady</a>的活动，介绍了自己的故事，Rebecca就飞到了西安。而她带给我们的故事，最为与众不同。</p>\n<p>她给我们讲了她到乌干达的故事。她和<a href=\"http://www.unicef.org/\" target=\"_blank\">Unicef</a>合作，帮住乌干达建立一些基础设施。在她的故事里，我们看到了非洲，那里的人，那里的动物，那里的风土人情。她给我们讲了她在那里做一些IT基础设施建设遇到的各种各样的困难。</p>\n<p>其实，我从她的故事里，更多的看到的是一种理想主义。有人问她，什么驱使她做出最初的决定，她只是为了帮助别人，为了有不同的体验。作为ThoughtWorks的CTO，她用实际行动为我们诠释了Social Justice。</p>\n<p>这就是人来人往的ThoughtWorks西安办公室。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201107100822",
    "date": "2011-07-10",
    "time": "08:22",
    "title": "欢迎加入Java的狂欢",
    "tags": [
      "OpenParty",
      "Java"
    ],
    "body": "<p>\n</p><p><a href=\"http://www.xian-open-party.org/event/8\" target=\"_blank\">西安Open Party7月活动：发布Java 7</a></p>\n<p>西安的朋友们，来聚会吧！为了Java。</p>\n<p>Java 7行将发布，这算是Java界的大事。还记得上次Java发布的时候，你在干什么吗？</p>\n<p>如果说，含着金钥匙出生的Java出现在世人面前就一直处在舞台的中心，那近些年来，Ruby、Python等以开发效率为买点等势力的逐渐兴起，则带走了太多的眼球，让舞台中心的Java多少显得有些落寞。</p>\n<p>好在，Java不曾停下前进的脚步。Java 7，以及随后的Java 8，让人看到Java不断的努力，努力改变着自身的形象。对于我们这群写代码的人而言，所有这些努力的结果，就是让我们的生活更轻松一些。</p>\n<p>我好久都未曾未一个新版的Java发布兴奋了。如果只是一些库的修改，只是虚拟机性能的提升，对开发人员而言，刺激不大，因为这些东西不见得会直接影响到我们的生活，所以，至少有语法的改变，才算是真正的改变。上一次是Java 5，那时，Java给我们带来了泛型等一干语法上的改变。这一次，Java 7，改变的不只是库，不只是语法，甚至还有虚拟机指令。是的，如果你知道，invokedynamic来了。</p>\n<p>西安的技术社区一直在不断努力着，<a href=\"http://www.xian-open-party.org/\" target=\"_blank\">Open Party</a>已经坚持了一年多，<a href=\"http://weibo.com/scriptfan\" target=\"_blank\">Script Fan</a>给了我们技术人员另外的相聚一刻。通过这些活动，我们才知道，原来西安也有那么多有着技术追求的人，有着那么多做着很cool事情的人，有着那么多对热心的人⋯⋯</p>\n<p>7月23日，如果你在西安，给自己一个机会，了解Java 7，给自己一个机会，了解西安的技术社区，认识更多的朋友。</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201106292319",
    "date": "2011-06-29",
    "time": "23:19",
    "title": "当开发不同于发布",
    "tags": [
      "开发笔记",
      "Buildr"
    ],
    "body": "<p><strong>缘起</strong>\n<br>\n面试，他是一个游戏的开发者，于是，他给我们介绍了他们项目中的一些技术。<br>\n<br>\n“我们项目里面用到一个框架，我们的代码就可以和Flash交互，这样，设计师使用Flash专注于设计，我们来做逻辑。在发布的时候，我们会用工具把Flash导成另外一种格式，从而得到更高的运行时效率。”<br>\n“你们是怎么区分是用Flash，还是另外一种格式呢？”<br>\n“在代码里有一个DEBUG宏，打开的时候就是Flash。”<br>\n<br>\n我下意识的想到了《<a href=\"http://dreamhead.blogbus.com/logs/94446774.html\" target=\"_blank\">代码之丑（十）</a>\n》里那一团浆糊的代码。在那篇blog里，我曾建议把这种情况放到构建脚本里处理。<br>\n<br>\n<strong>一个实例</strong>\n<br>\n项目刚好有类似的情况，根据自己的建议，这是构建脚本处理的东西。<br>\n<br>\n在buildr里，通过ENV['BUILDR_ENV']，我们可以得到当前环境的名字：development还是production，抑或是其它。这便是我们的切入点，比如，测试环境采用一些假的实现，让整个系统运行的更快。<br>\n<br>\n下面是一个例子，有一个搜索组件，在生产环境下，我们要采用真实的搜索引擎实现，而在开发环境时，它只是一个简单内存实现。针对这两种不同的情况，我们会有不同的配置文件：</p>\n<p>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xsi:schemaLocation=\"http://www.springframework.org/schema/beans<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;<br>&nbsp; &lt;bean id=\"searcher\" class=\"com.killer.SuperSearcher\"/&gt;<br>&lt;/beans&gt;<br>(searcher.production.xml)</p>\n<p>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xsi:schemaLocation=\"http://www.springframework.org/schema/beans<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;<br>&nbsp; &lt;bean id=\"searcher\" class=\"com.killer.InMemorySearcher\"/&gt;<br>&lt;/beans&gt;<br>(searcher.development.xml)</p>\n<p>要使用这个组件只要引用search.xml，把searcher拿过来用就好了：</p>\n<p>&lt;import resource=\"search-context.xml\"/&gt;<br>...<br>&lt;property name=\"searcher\" ref=\"searcher\"/&gt;</p>\n<p>接下来，用一个task就可以处理这些差异：</p>\n<p>task :searcher do<br>\n&nbsp; cp \"searcher.#{ENV['BUILDR_ENV']}.xml\", \"searcher.xml\"<br>\nend<br>\n<br>\n其实，实现这一点真正困难的并不在于配置文件，而在于这些组件的设计。只有识别出这些组件，把它们独立出来，才会可能根据不同的环境进行配置。<br>\n<br>\n在为数不少的“直觉式”设计中，环境相关的信息是靠if..else（或是宏）区分的，更致命的是，这些信息散落在各处。没有恰当的抽象，构建脚本也无能为力。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201106232317",
    "date": "2011-06-23",
    "time": "23:17",
    "title": "以终为始",
    "tags": [
      "开发笔记",
      "ThoughtWorks"
    ],
    "body": "<p>\n</p><p>最近项目里关注了两件事：部署和BDD。</p>\n<p>部署的目标是自动化，就是一个命令敲下去，机器创建出来，相应的软件安装好，并且根据配置好。这就是DevOps，所有的配置都像代码一样保存好，这样，测试和重现问题都很容易。想想那些因为机器配置差异，死活重现不了bug的悲惨生活吧！不过，这不是这里要说的。</p>\n<p>讨论数据库配置时，我们忽然发现了一个问题：没有数据库脚本。忘记配置数据库，这种低级错误是不可能出现的，我们项目有dbdeploy实现了数据迁移。但是，我们这些迁移脚本只是在开发环境里使用的。部署数据库的那台机器上，是不会有开发环境的，我们能做的只是提供一个数据库脚本，在上面运行。</p>\n<p>发现问题，解决问题是很容易的，于是，我们很快的就生成了自己的数据库脚本。</p>\n<p>BDD的讨论实际上是关于如何写好一个Feature/Scenario。Given/When/Then和和测试基本结构是完全一样的，Given就是一些预置条件，When是一些操作，Then是验证。</p>\n<p>做BDD，实际上是站在系统层面上思考的，那么Given实际上就是给系统预设一些数据。而真正要去设置这些数据时，一些系统设计上的问题就会浮出水面，比如，系统根本就没有一个修改数据的接口。还是那句话，发现问题，解决问题是很容易的。</p>\n<p>作为开发人员，我们经常会醉心于功能实现上，而忽略掉许多重要的东西。其实，只要向外一站，换个角度，我们便不难发现自己的疏忽。这也就是“测试驱动开发”的原动力，为了不让自己迷失，从最终目标开始。</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201106181904",
    "date": "2011-06-18",
    "time": "19:04",
    "title": "Hello, Modernizr",
    "tags": [
      "modernizr",
      "html5",
      "css3",
      "web"
    ],
    "body": "<p><strong>简介<br></strong>在HTML5和CSS3逐渐成为主流之际，不同浏览器的能力成为构建网站的一个挑战，Modernizr应运而生。Modernizr如是介绍自己：</p>\n<p>Modernizr is an open-source JavaScript library that helps you build the next generation of HTML5 and CSS3-powered websites.</p>\n<p><strong>下载<br></strong>如果要下载production版本的modernizr，我们会发现，它提供的并不是一个one-size-fits-all的解决方案，而是我们可以根据自己的需要进行订制。在其<a href=\"http://www.modernizr.com/download/\" target=\"_blank\">下载页面</a>上，我们选择自己所需的HTML和CSS特性，然后生成一个javascript文件。这么做会极大程度上减少冗余代码，减少不必要的检测，对web前端这个很看重用户体验的地方，性能就是一点一点压出来的。当然，development版本会给我们提供更全面的内容。</p>\n<p><strong>安装<br></strong>下面是一个使用了modernizr的极简页面：<br>&nbsp; &lt;!DOCTYPE html&gt;<br>&nbsp; &lt;html class=\"no-js\"&gt;<br>&nbsp; &lt;head&gt;<br>&nbsp; &nbsp; &lt;script src=\"modernizr.js\"&gt;&lt;/script&gt;<br>&nbsp; &lt;/head&gt;<br>&nbsp; &lt;body&gt;<br>&nbsp; &lt;/body&gt;<br>&nbsp; &lt;/html&gt;</p>\n<p>在这里，有两点需要我们关注。其一自然是我们放置了modernizr.js。按照现在通常的理解，javascript应该放置页面的底部，保证加载javascript时页面已经加载完毕，提升整体的性能。但是，modernizr必须放在&lt;head&gt;里，最好放在css声明之后，因为HTML5 Shiv（用以在IE中启用HTML元素）必须在&lt;body&gt;之前执行，而且要使用modernizr添加的class，需要阻止<a href=\"http://bluerobot.com/web/css/fouc.asp/\" target=\"_blank\">FOUC</a>。</p>\n<p>另外一个关注点在于html声明里的no-js的class。它设置了一个默认状态，如果页面禁用了javascript我们就可以知道了。</p>\n<p>如果一切正常，打开页面调试工具，我们就会看到modernizr的工作成果，下面是用firefox 4的firebug打开看到的内容。</p>\n<p>&lt;html class=\" js flexbox canvas canvastext webgl no-touch geolocation postmessage no-websqldatabase indexeddb hashchange history draganddrop no-websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity no-cssanimations csscolumns cssgradients no-cssreflections csstransforms no-csstransforms3d csstransitions fontface generatedcontent video audio localstorage no-sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths\"&gt;</p>\n<p>通过这段代码，浏览器的能力就一目了然了，所有以“no-”开头的，就是这个浏览器不支持的特性。</p>\n<p><strong>使用</strong><br>有了这些检测，接下来就是这些检测的结果。我们的主要关注点在于两个方面，CSS和JavaScript。</p>\n<p>对CSS，我们可以根据不同的特性对于样式进行不同的配置，比如，下面这段<br>&nbsp; .webgl h1 {<br>&nbsp; &nbsp; color: blue;<br>&nbsp; }</p>\n<p>&nbsp; .no-webgl h1 {<br>&nbsp; &nbsp; color: red;<br>&nbsp; }</p>\n<p>如果我们在页面上使用了h1，在Firefox 4和Safari 5上打开页面，就会看到不同颜色的字体。</p>\n<p>同样，我们也可以在JavaScript利用这些特性检测的结果，下面是一段利用了JQuery写出的代码：<br>&nbsp; $(function() {<br>&nbsp; &nbsp; if (Modernizr.webgl) {<br>&nbsp; &nbsp; &nbsp; $('h1').text('webgl');<br>&nbsp; &nbsp; } else {<br>&nbsp; &nbsp; &nbsp; $('h1').text('no-webgl');<br>&nbsp; &nbsp; }<br>&nbsp; });</p>\n<p>有了这段代码，Firefox 4和Safari 5也会有不同的表现。</p>\n<p>无论从哪个角度看来，到处都是if判断都会把代码弄得乱七八糟。所以，modernizr提供了一种机制，分离不同的代码：<br>&nbsp; Modernizr.load({<br>&nbsp; &nbsp; test: Modernizr.webgl,<br>&nbsp; &nbsp; yep : 'webgl.js',<br>&nbsp; &nbsp; nope: 'no-webgl.js'<br>&nbsp; });</p>\n<p>有的，归有的，没有的，就没有。Modernizr.load本身扮演着一个resource loader的角色，它会根据检测的结果进行资源加载，换句话说，要么是加载了webgl.js，要么是加载no-webgl.js，而不会二者都加载。</p>\n<p>如果直接用的是development版本的modernizr，你会发现，根本就没有Modernizr.load，因为它是作为一个单独文件发布的：yepnope.js。而在production版本，我们选择将其包含在modernizr里。</p>\n<p>这就是对modernizr的一个基本介绍，就让我们在modernizr的协助下，共同走上HTML5的康庄大道吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201106142218",
    "date": "2011-06-14",
    "time": "22:18",
    "title": "没完的AC",
    "tags": [
      "开发笔记",
      "我眼看世界",
      "Story",
      "AC",
      "敏捷"
    ],
    "body": "<p>我们敏捷，我们用Story管理需求，那Story怎么算是做完呢？一个直觉的答案是，按照验收标准（Acceptance Criteria，简称AC）做完。</p>\n<p>这是一个很容易向别人解释的答案。顺水推舟，就可以这样想，作为业务分析人员，只要我能够把AC写得够细，开发人员照着实现就OK了。再推舟，那我只要写好AC，我也就可以不去面对开发人员。是的，照着这种思路推理下去，只要有文档，根本就不需要沟通，那提倡沟通的敏捷就是在扯淡。</p>\n<p>真的是这样吗？实际上，这个推理中有一个假设是错的，业务分析人员能够把AC写得足够细。</p>\n<p>我知道，有的业务分析人员已经准备拍案而起了，我在质疑他们的专业技能。但我们不得不承认一点，没有人是完美的，虽然我们都努力前行在追求完美的路上。业务分析时，我们固然可以尽可能考虑各个方面，但遗漏再所难免。其实，开发人员也是如此，每个人都尽了最大的努力，但是，我们写出的程序里依然有bug。</p>\n<p>既然假设不成立，后面的推理过程就都是胡诌。这也是沟通的源动力：个体做不到完美，只能大家一起努力把事情推向完美。</p>\n<p>回到开发的角色上来。既然我们知道，业务分析人员写的AC可能不完美，拿到一个Story，在了解AC时，我们也应该多想想：<br>\n</p><ul>\n<li>除了AC提及的情形，还会存在哪些可能</li>\n<li>做这个Story会对整个程序产生哪些影响</li>\n<li>是不是要提供一个脚本把一些任务自动化了</li>\n<li>也许可以弄出一个好的视觉效果，比“Test XX”强</li>\n<li>⋯⋯</li>\n</ul>\n<p></p>\n<p>我一直抱有一个观点，谁动的脑子最多，谁就是最有价值的人。只能做需求代码翻译器的程序员是最没有价值的，有工夫抱怨别人不重视自己，还不如反思一下自己的无为。</p>\n<p>AC是一张查缺补漏的防护网，却不是终点。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201106111632",
    "date": "2011-06-11",
    "time": "16:32",
    "title": "ThoughtWorks Open Day",
    "tags": [
      "ThoughtWorks",
      "OpenDay",
      "学生"
    ],
    "body": "<p>所谓Open Day，就是把外面人请进来。</p>\n<p>新的西安办公室就绪，我们终于有了一个拿得出手的地方，可以给外人看了。于是，Open Day的想法浮出水面。试水Open Day，我们第一个选择的目标是学生。</p>\n<p>于是，大家忙碌起来。有人写宣传材料，有人到西安各大院校的论坛灌水，有人构思活动方式，有人策划交流内容，有人负责学生报名⋯⋯</p>\n<p>周五下午三点，学生们来了，活动开始了。</p>\n<p>既然是Open Day，既然把外面的人请了进来，参观办公室是一个不可或缺的环节。对许多认为工作就该蹲在格子间里的人来说，ThoughtWorks的办公环境是让许多人惊喜的。我曾经带着不少朋友参观过我们的办公室，反应类似，没想到你们是这样的。</p>\n<p>为了这个Open Day，我们安排了一个主题演讲，而演讲者是一个去年加入公司的毕业生。许多学生关注点都在找工作上，他给大家分享了自己找工作的经验，还有自己在工作一年的时间里的思考。相比于我们这些已经工作许多年的人，这样的演讲更有现身说法的感觉。</p>\n<p>刚好最近有一些客户在。学生们看到的是，我们国际化的工作环境。客户的人对这个活动也很有兴趣，他们也直接见识到了ThoughtWorks在培育社区上所做的努力。</p>\n<p>最受欢迎的环节还是自由交流，每个人畅所欲言，聊着自己关心的话题。我们也有得以分享自己许多年走来的一些经验。在这里，有活力，也有迷茫。这就是学生，不是吗？</p>\n<p>虽然在一些细节上并不是很到位，比如恰好在西安的老大在发言时，剧透了一些主题演讲里的内容，但总的来说，这次活动还是很成功的。Open Day既然试水成功，那就是继续前行的动力。欢迎来参观！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201106012243",
    "date": "2011-06-01",
    "time": "22:43",
    "title": "六一校园行",
    "tags": [
      "脚下的路",
      "招聘",
      "学生"
    ],
    "body": "<p>\n</p><p>学生们去公司实习，发现有些公司已经开始敏捷了。学校在这方面完全没有任何的教导，你过来给学生们讲讲吧！我的大学老师如是说。老师既然开口了，我责无旁贷。</p>\n<p>儿童节晚上，我和几个同样对校园活动有兴趣的同事来到了学校。</p>\n<p>按照典型的TW活动风格，我们采用头脑风暴的方式收集了一下同学们最关心的问题。结果，原本老师是让我介绍敏捷的，而学生们真正关心的问题实际上是就业:</p>\n<p>\n</p><ul>\n<li>企业需要怎样的人</li>\n<li>招聘的人会问哪些问题</li>\n<li>怎么写简历才能更好的吸引眼球</li>\n<li>ThoughtWorks是一个怎样的公司</li>\n<li>⋯⋯</li>\n</ul>\n<p></p>\n<p>从这些问题中便不难看出，同学们想问题还真的是很“学生”，这些问题无异于问老师，考试要考什么。老师会怎么回答呢？好好学习就是了。正常的公司都喜欢态度好能力强的。</p>\n<p>在毕业担心就业的那些人，应该问问自己，本来可以用来学习提高的时间都干了些什么。临阵磨枪，或许能撑住一时，但得有多好的运气才能长久。所谓提高，不一定是非要在本专业下多大功夫，但是至少得有一些拿得出手的本事吧！</p>\n<p>其实，学生们真正应该关心的问题是如何成为公司喜欢的人，俗称，有竞争力的人。</p>\n<p>以自己走过的路来看，想成为一个合格的程序员，最重要的是多写代码。对于学生而言，写代码之余，还能读些经典的书，向人学习，写写blog/文章，总结一下自己的想法，那就更好了。要是再能参与一些开源项目，关注一下软件行业的发展，那就太完美了。</p>\n<p>一句老话，要想人前显贵，必须背地里遭罪。</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201105232234",
    "date": "2011-05-23",
    "time": "22:34",
    "title": "告别mock",
    "tags": [
      "开发笔记"
    ],
    "body": "<p>在数据上造假。</p>\n<p>如果你只有很短的时间，你已经知道了这篇blog的核心内容了。如果还有时间，请继续阅读。</p>\n<p><strong>别离初因<br>\n</strong>\nmock，是一个经历了大喜大悲的东西。初识mock，以为它就是全部，义无反顾的全身心投入，写出自以为强健无比的软件。但长时间的相处让我们知道，mock只能给予短暂的愉悦。实际经验证明，大量的使用mock，出现变化时，在一片绿色中，整个功能不好用的事屡见不鲜。</p>\n<p><strong>几种选择<br>\n</strong>\n不用mock，并不意味着放弃测试。测试还是要做的，只是我们不希望到处像原来一样到处造“假”。有几种选择方案。</p>\n<p>一切都用真的，这意味着所有一切都跑在真实的环境下。这种做法会导致测试越来越慢。因为在真实的项目里，通常要访问数据库，访问外部系统。我们知道，IO操作会很慢，这种最底层的操作慢下来，会导致整个测试集合都慢下来。</p>\n<p>比如，在一个实际的项目中，我们通过VPN连接外部系统，换句话说，如果这样做，每次运行单元测试之前，我都要连接VPN，很麻烦的。人性告诉我，复杂的事人们会倾向于少做，那TDD本身的快速反馈，就会在这里丧失殆尽。</p>\n<p>还有一种方案，多数内容用真的，少部分内容造假。这就牵扯另一个问题，到底给哪些部分造假。</p>\n<p><strong>数据之源</strong>\n<br>\n绝大多数系统本质上都是对数据进行操作。通常我们编写的逻辑，无非是拿到这些数据之后，进行各种处理。所以，只要我们在数据造“假”，其它部分就可以有效的测试。</p>\n<p>在通常的分层架构中，我们都会有一个专门的数据访问层，没错，它就是我们造“假”的目标。</p>\n<p><strong>假假真真<br>\n</strong>\n虽说要造假，但我们还是希望假得真实一些。</p>\n<p>实际上，在正常的开发过程中，我们都会有一些专门用来测试的数据，比如存放在数据库里。既然这些数据可以放到数据库里，也就可以放到我们造出来的数据访问层里。换句话说，我们造假出的这个数据访问层，可以产生与真实数据库同样的结果。</p>\n<p>要做到这一点，可以把灌到数据库里的数据，也灌到数据访问层里。在实际的项目中，对于数据库部分，我们会维护一个数据库迁移脚本，所有的数据就维护在这个脚本里。本质上说，这些数据是一种元数据，根据元数据可以产生数据库迁移脚本，当然，也就可以根据这些元数据产生假的数据层了。</p>\n<p>在一个项目中，我们把所有的元数据维护在一个简单的csv文件里，然后编写了一个脚本用以产生数据库迁移脚本，还编写一个脚本产生加的数据层。当csv文件被修改时，我们会分别用这两个脚本生成两个文件，一个放到数据库迁移的目录下，一个放到测试部分。</p>\n<p><strong>框架之功<br>\n</strong>\n这里要告别的是mock，而非mock框架。</p>\n<p>前面举的例子都是数据库访问的例子，在某些情况下，我们还可以把外部系统视为一个数据源，那对外部系统的访问也可以归结为数据访问的操作。</p>\n<p>而有些情况下，这些外部访问接口是以API的方式提供的，而且API可能是由很多方法组成的接口，我们真正要用到的方法可能只有几个时，直接实现这个接口会产生出许多无用的空方法。这就是Mock框架粉墨登场的时机了。</p>\n<p>mock框架经过许多年的发展已经相当完善，无论从功能还是表现形式上。而且绝大多数mock框架都可以很好的支持stub。事实上，stub部分才是一个mock框架的核心。</p>\n<p>把mock框架当做stub框架用。这意味着，绝对不要用verify。结合前面的东西，只在不能控制的点使用mock框架。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201105112242",
    "date": "2011-05-11",
    "time": "22:42",
    "title": "测试覆盖率，100%",
    "tags": [
      "开发笔记"
    ],
    "body": "<p>测试覆盖率这东西，高了不代表有多好，但低了肯定是有问题。</p>\n<p>在这个项目里，我们把测试覆盖率限制为100%，其结果是全部内容都会有测试覆盖。坚持这样的标准，在做重构的时候，可以比较放心。</p>\n<p><strong>工具支持</strong><br>我们用的测试覆盖率工具是cobertura，buildr缺省就对它进行有支持。<br>&nbsp; require 'buildr/java/cobertura'</p>\n<p>&nbsp; cobertura.check.branch_rate = 100<br>&nbsp; cobertura.check.line_rate = 100<br>&nbsp; （buildfile）</p>\n<p>在命令行里运行如下命令就可以运行测试，进行检查，生成报告：<br>&nbsp; buildr cobertura:html cobertura:check</p>\n<p>如果覆盖率不达标，构建就会失败。这时，我们可以通过它生成的报告来看，到底是哪里没有覆盖。报告位于<br>&nbsp; &nbsp; reports/cobertura/html/index.html</p>\n<p><strong>提交流程<br></strong>设定了目标，接下来，就是如何将这个目标贯彻下去。</p>\n<p>为了确保大家在提交之前都会保证测试覆盖率，我们制作了一个提交脚本，其基本流程是：</p>\n<ul>\n<li>检查更新</li>\n<li>运行测试</li>\n<li>提交代码</li>\n</ul>\n<p>因为这个项目里用到都是一个分布式源码管理工具：git，所以，第一步我们做的是本地提交。</p>\n<p>项目组代码提交都要通过这个脚本，以此保证我们提交的代码，测试覆盖率没有问题。一旦某人因为一些特殊原因，强行手工提交，我们还有CI进行保证，它同样会运行测试覆盖率检查，一旦失败，CI就会红掉。</p>\n<p><strong>例外情况</strong><br>真的是所有代码都会在这个100%的监控之下吗？不是。有一些代码只是为了调用一个特定的API，这样的代码是否100%意义不大，这样的测试本质上是在API写测试，而非自己的代码逻辑。所以，这种代码会被排除在外。<br>&nbsp; cobertura.exclude /.*.integration.*/</p>\n<p>但是，这样的代码同样会有相应的集成测试，只是不在单元测试的层面。一个基本的原则是，被排除的代码要尽可能少。在我们的项目里，只有这样只调用特定API的集成代码会被排除在外。</p>\n<p>有了目标，有了工具支持，有了大家自我监督，100%其实也是一件很容易达到的事。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201105032202",
    "date": "2011-05-03",
    "time": "22:02",
    "title": "实用buildr",
    "tags": [
      "buildr"
    ],
    "body": "<p><strong>为什么选择Buildr<br></strong><a href=\"http://dreamhead.blogbus.com/logs/117917683.html\" target=\"_blank\">选择，构建工具</a></p>\n<p><strong>Buildr基础</strong><br><a href=\"http://dreamhead.blogbus.com/logs/73555884.html\" target=\"_blank\">搭建Scala工程</a><br><a href=\"http://dreamhead.blogbus.com/logs/73609525.html\" target=\"_blank\">搭建Scala工程——测试</a></p>\n<p><strong>多模块工程<br></strong>虽然是一个项目，但把代码放到不同的模块里做物理隔离，本身是有助于更好的思考解耦。下面就是一个web项目的buildfile，其中包含了两个部分：domain和web。</p>\n<p>define 'killer' do<br>&nbsp; project.version = '0.0.1'<br>&nbsp; define 'domain' do<br>&nbsp; &nbsp; package :jar<br>&nbsp; end&nbsp;&nbsp;</p>\n<p>&nbsp; define 'web' do<br>&nbsp; &nbsp; DOMAIN_PROJECT = project('killer:domain')<br>&nbsp; &nbsp; DOMAIN = DOMAIN_PROJECT.packages<br>&nbsp; &nbsp; compile.with DOMAIN<br>&nbsp; &nbsp; package(:war).with(:libs=&gt;DOMAIN)<br>&nbsp; end<br>end</p>\n<p>这样，web模块里就可以引用到domain模块定义的内容，而且在打包的时候，会给domain模块生成的的jar包，打到自己的war包里。</p>\n<p><strong>stub依赖</strong></p>\n<p>在测试里，我们可能会编写一些stub，减少对外界资源的依赖。在划分成多工程的项目里，web模块可能会引用到domain模块定义的一些stub，我们可以在web模块的定义里这样写：</p>\n<p>&nbsp; test.with DOMAIN_PROJECT.test.compile.target</p>\n<p>这种做法实际上是直接依赖到DOMAIN生成的class文件。</p>\n<p><strong>不同环境的配置</strong></p>\n<p>开发、测试和生产等不同的环境可能会有不同的配置。我们可以在buildfile相同的目录下放置一个profiles.yaml。下面是一个配置示例：</p>\n<p>development:<br>&nbsp; db:<br>&nbsp; &nbsp; adpater: mysql<br>&nbsp; &nbsp; url: jdbc:mysql://localhost/homeideas_development<br>&nbsp; &nbsp; driver: com.mysql.jdbc.Driver<br>&nbsp; &nbsp; username: root<br>&nbsp; &nbsp; password:&nbsp;<br>&nbsp; &nbsp; jar: mysql:mysql-connector-java:jar:5.1.14</p>\n<p>在buildfile里，我们可以这样引用这个配置：<br>&nbsp; db_settings = Buildr.settings.profile['db']<br>&nbsp; db_adapter = db_settings['adapter']</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201104252258",
    "date": "2011-04-25",
    "time": "22:58",
    "title": "新ThoughtWorker开发的头两件事",
    "tags": [
      "ThoughtWorks"
    ],
    "body": "<p>\n</p><p>回到自己的办公室，与新同事结对开发。我对他做了两件事，让他列出要做的任务，抢走了他的鼠标。这也是我要教给新ThoughtWorker头两件事：分解任务和快捷操作。</p>\n<p>分解任务，是一个好的工作习惯。把自己要做的事情一件一件的列出来，然后一件一件的做。Kent Beck在《测试驱动开发》中，为我们展示的就是这种工作方式。他称自己为拥有好习惯的程序员，这便是其中之一。</p>\n<p>我之前很少这么做，总觉得我的脑子可以处理一切，但经常会出现，一件事并没有想清楚就开始动手，做着做着不知道自己该往哪走了，也有经常性的发散，走着走着忘了自己的目标。通过分解任务，我在动手之前，我就知道自己要做的有哪些事，然后一件一件解决，保证了自己的专一。一旦大脑发散，我会提醒自己在任务列表中增加一项，而不会影响继续工作在当前任务上。</p>\n<p>任务要分解到什么程度呢？分解到心里有数。对于老手来说，可能就是要做的东西，对于新手而言，就要更细致一些，包括一些问题的解决方案。这样，新手即便一个人做，也不会走偏。</p>\n<p>学会扔掉鼠标吧！写程序不会快捷键，在ThoughtWorks会被人嘲笑的，因为在你慢腾腾的在菜单里寻找重构选项的时候，我已经完成了这一切，开始解决下一个问题了。</p>\n<p>第一次看一些ThoughtWorker用IntelliJ IDEA写Java程序，我惊呆了，平静的表面下，内心翻腾，惊讶于神乎其技。所以，我只能偷偷下功夫，以免让人嘲笑。后来，有人说，你写得太快了，我假装平静的说，这没什么。其实，我知道，和许多人比起来，我还是慢很多。</p>\n<p>和别人结对的时候，我故意把pair的鼠标扔到一边，如果他需要做什么操作，我会告诉他快捷键是什么，做几次下来，快捷操作也就成了一种下意识的动作。IntelliJ IDEA还有一个专门的插件，叫Key Promoter，用来提示人快捷键是什么。</p>\n<p>做好习惯的程序员，从分解任务和快捷操作开始。</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201104212059",
    "date": "2011-04-21",
    "time": "20:59",
    "title": "ThoughtWorks墨尔本办公室",
    "tags": [
      "ThoughtWorks"
    ],
    "body": "<p>墨尔本办公室的人大多在客户现场工作，诺大的办公室平时显得空空荡荡。相对而言，中国区的办公室人气会旺一些。</p>\n<p>虽然大家都在客户现场工作，但公司并没有忽视团队建设。在一个客户不同项目工作的人每天都会在一起standup，分享一下彼此的工作，抛出遇到的问题，看看别的人能不能帮上忙。</p>\n<p>每周，公司会提供一次团队午餐，大家坐在一起，天南海北的闲聊，你问问我的项目是做什么的，我问问你怎么解决的某个技术难题。我就是在这种午餐中知道了著名Queen Victoria Market。有时，公司里其他角色的人也会特意过来，参加这种午餐，做一些小调研，问问大家对某个问题的看法，或者，纯粹就是过来聊天，增进彼此的交流。</p>\n<p>仅仅一个客户的团队沟通是不够的，每周最后一个工作日，公司还会提供午餐，让工作在各个客户现场的ThoughtWorker回到办公室，没有什么特定的主题，就是大家在一起闲聊。这时候才知道办公室原来挺小的。ThoughtWorks会有Monthly Update，也就是办公室的老大会给大家介绍一下公司的情况，我参加的一次墨尔本办公室的Monthly Update就是在这种午餐中进行的。</p>\n<p>差不多每周公司都会有技术活动，我参加过<a href=\"http://dreamhead.blogbus.com/logs/118830680.html\" target=\"_blank\">JavaScript之夜</a>，还参加了一次Amazon Web Service的介绍。这样的活动都是在下班之后进行的，只要有兴趣都可以参加。我还参加过一次活动，一个开发人员给各位BA介绍软件开发过程，入门级的，挺有趣。</p>\n<p>技术活动之后，就是业余活动了。我参加过一次保龄球，学会一个说法，turkey，就是连续三次全中，呵呵，没错，我瞎猫碰到死耗子了。</p>\n<p>运气很好，在墨尔本这段时间，还赶上了一次Team Hug，和中国的Away Day异曲同工。这种活动会把全澳大利亚所有ThoughtWorker聚在一起，也是一种沟通。</p>\n<p>我现在逐渐可以理解为什么大家都在客户那里工作，公司依然能够保持很高的凝聚力，很简单，公司会创造各种各样的条件，让大家进行沟通。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201104132019",
    "date": "2011-04-13",
    "time": "20:19",
    "title": "墨尔本javascript之夜",
    "tags": [
      "脚下的路",
      "javascript",
      "墨尔本"
    ],
    "body": "<p>\n</p><p>ThoughtWorks对社区活动的支持总是不遗余力，这一点在哪都一样，我参加过北京、西安、班加罗尔的社区活动，见识过芝加哥办公室为活动准备的大场地。</p>\n<p>今天，墨尔本，JavaScript之夜。</p>\n<p>听完了，留在脑子里的东西有两个：<a href=\"http://www.asual.com/jquery/address/\" target=\"_blank\">JQuery Address</a>和<a href=\"http://pivotal.github.com/jasmine/\" target=\"_blank\">Jasmine</a>。</p>\n<p>JQuery Address，根据我对所讲的理解，它可以在保持页面不刷新的情况下，更新URL。这有什么用呢？</p>\n<p>今天早上和人讨论了SEO，其中一点是，URL是页面的一个很重要的标识，所以，不同的内容应该有不同的URL，但另一方面，不刷新页面，比如只用Ajax更新页面内容，对于用户体验来说又是非常重要的。好了，把这两点放在一起，通过JQuery Address，我们就可以在保证SEO的情况下，又给予用户良好的体验。</p>\n<p>本质上来说，这不是JQuery特有的，而是“#”带给我们的便利，之前读到过<a href=\"http://www.ruanyifeng.com/\" target=\"_blank\">阮一峰</a>的一篇文章《<a href=\"http://www.ruanyifeng.com/blog/2011/03/url_hash.html\" target=\"_blank\">URL的井号</a>》，如今我终于这是怎么回事了。</p>\n<p>Jasmine是一个JavaScript BDD框架。在这个Web页面越来越时尚的年代，作为一个开发人员，如果我们还在用最原始的方式写JavaScript的话，真会觉得脸上无光，更重要的是，会把自己累死。现在JavaScript也可以测试了，而且起点不低，直奔BDD而去。</p>\n<p>Jasmine已经有了很好的集成方式，比如<a href=\"https://github.com/pivotal/jasmine/wiki/A-ruby-project\" target=\"_blank\">和Ruby项目集成</a>，<a href=\"https://github.com/pivotal/jasmine/wiki/A-rails-project\" target=\"_blank\">和Rails项目集成</a>，<a href=\"https://github.com/mhevery/jasmine-node\" target=\"_blank\">和Node.js集成</a>，作为Java程序员，如果用Maven的话，也有<a href=\"https://github.com/searls/jasmine-maven-plugin\" target=\"_blank\">集成方式</a>。除此之外，它还有<a href=\"https://github.com/velesin/jasmine-jquery\" target=\"_blank\">与Jquery的集成</a>。还有人用<a href=\"http://www.phantomjs.org/\" target=\"_blank\">phantomjs</a>，这样，在不开启界面的情况下，就可以运行Jasmine。</p>\n<p>不白走一趟，这两个话题刚好是最近脑子里在想的话题，可以在项目里面尝试一下。听说下次有人讲页面上的MVC：<a href=\"http://documentcloud.github.com/backbone/\" target=\"_blank\">backbones</a>。多好的社区活动啊！</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201104112120",
    "date": "2011-04-11",
    "time": "21:20",
    "title": "选择，构建工具",
    "tags": [
      "开发笔记",
      "构建工具",
      "ant",
      "maven",
      "buildr",
      "gradle"
    ],
    "body": "<p>一个新的Java项目行将开始，自动化是要纳入考量的一项重要工作，于是，构建工具的选型提上了日程。<br>\n<br>\n固然，我可以不明就里从Java世界Ant和Maven两大天王中，择一从之，但稍微整理一下内心的需要，也不会糊涂僧断糊涂案。作为构建工具，基本构建功能自然是必备的，此外，我还有一些非分之想。<br>\n<br>\n在这个Convention over Configuration的年代，要是每次都从头开始手工打造一切，出门都不好意思和人打招呼。Maven给Java世界打了一个很好的样，它的目录结构有约定，就是那个src/main/java⋯⋯，它的构建过程有约定，就是编译、测试、打包的那套东西。感谢Maven，Java世界的很多构建工具都遵循了同样的约定，这让我有机会在不改变目录结构的情况下，尝试各种构建工具。你知道我在说什么了，Ant稍微有些原始。<br>\n<br>\n依赖管理不可或缺，看看人家Ruby，gem install以及bundle install。其实，从Ruby世界得到的信息是，这不是构建工具的一亩三分地，但谁让它跟构建紧密相关，每次想到，我要自己这找一个jar包，那找一个jar包，就纠结得我痛苦万分。幸好，Maven拯救了Java程序员，只要在脚本里定义好自己需要的库，于是，一大批jar就从天而降了。有了Maven的基础设施，许多构建工具也借得东风，比如ivy，它就是定义自己的需求，拿Maven的jar包。<br>\n<br>\n划分工程。把所有代码都写在一个工程里，生成一个jar/war/ear包，N年前我是这么做的。当我为一个把所有一切都混杂一起的项目编写web service时，我被恶心得够呛。于是，我决定，我的下一个Java项目一定要把domain和web分开，这样，别人给它写web service时，根本不必理会web层的存在，我相信，至少这一点上，他会感谢我的，也许这个人就是未来的我。<br>\n<br>\n环境区分，去过Rails环境，我才知道，把不同的配置分开是多么幸福的一件事。在开发环境下，我可以用一套配置，在部署环境下，我用另外一套配置，楚河汉界，我就不必费心在代码里想各种各样奇怪的组合。<br>\n<br>\nIDE集成。如果你用过maven idea:idea，你就知道我说什么了。通过构建工具，我可以生成对应的IDE工程，直接在IDE里打开，然后就开始写代码了。曾几何时，开始写代码时，我需要花上小半天时间配我的IDE，尤其是我想有多个工程的时候。<br>\n<br>\n最重要的是，扩展能力，当我希望表现的个性一点时，我可以。从前面的种种，你可以看出我多么喜欢Maven了，但Maven就是死在这里了。我非常同意Maven是能够扩展的，但它着实不是给老百姓扩展的。要扩展它，我必须成为Maven的专家，对于Maven精心设计的插件机制有足够的了解。可惜，这不是我的努力方向，我还是喜欢一些更符合直觉的东西。<br>\n<br>\n总结一下我的需求，说白了，就是能够快速开始，不把自己玩死。<br>\n<br>\n有了需求，就不难发现，天王固然是天王，但毕竟老了。一些新星已然崭露头角，如果你已厌倦Java世界整日与XML为伍的生活，还有个好消息，新星们选择了另外的表达方式。假如你喜欢ruby，buildr是个不错的选择，groovy若是你的最爱，那就去找gradle吧！</p>\n<p>新星毕竟是新星，遇到问题时，比起可以随手找到的Ant Task和Maven Plugin，新星们的解决方案寥寥无几，当然一个还好的消息是，新星们都可以集成天王的资产，比如调用Ant Task，这会让我们不安的内心稍稍平静一些。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201104042042",
    "date": "2011-04-04",
    "time": "20:42",
    "title": "门槛",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>\n</p><p>在我曾经面试过的人中，有这样一类，他们各方面给人的感觉都很一般，从他们身上，我感受不到激情，也体会不到深入思考，但偏偏他们就是知道很多，让人弃之可惜。</p>\n<p>稍微翻看一下他们的简历便不难发现，这些人通常都有着不错的经历，比如海外工作经验，他们的能力就是在日常的按部就班中获得，而就是对于其他许多人而言，却需要费尽九牛二虎之力才能得到。</p>\n<p>做咨询的时候，客户中有许多程序员其实都是对写程序充满热情，只是自己能够提高得非常有限。而对于许多一毕业就加入ThoughtWorks的人来说，不知不觉中软件开发能力就到了一个很不错的程度。</p>\n<p>许多人削尖脑袋往所谓的好地方挤，其实，绝大多数人并不是为了做得多好，更多的是为了让自己享受到那些底限就可以达到的高度。</p>\n<p>回到软件开发的主题上来吧！</p>\n<p>一支好的软件开发团队，大牛很重要，门槛也很重要。咨询过程中接触过许多代码，其实，从根本上来说，大牛们留下的基础架构都是非常好的，但即便如此优秀的基础，也挡不住没有底限的祸害。你塞一段代码，我添一个功能，年久失修，面目全非。</p>\n<p>随着听到见到的增多，我越来越觉得，眼下的这个客户，门槛很高：他们对代码有着甚高的要求，不只是实现；他们对测试有着很高的要求，不只是覆盖；他们对解决方案有着甚高的要求，不只是眼下能够实现⋯⋯&nbsp;</p>\n<p>我们的目标不是一锤子买卖，所以，我们的团队也需要提高自己的门槛。要求固然高，但只要挺过来了，团队能力就会得到提升，做事的品味也会不一样。</p>\n<p>你的团队门槛在哪里？</p>\n<p></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201103291821",
    "date": "2011-03-29",
    "time": "18:21",
    "title": "意外的开始",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>期望是个有趣的东西，期望越大，失望就越大，反之，期望低，则可能会有意外收获。这个项目就是。<br>\n<br>\n开始前，我以为这是个普通的不能再普通的Web项目，期望值压得很低。我踏上了征程。<br>\n<br>\n今天，当我走进客户的公司，我被眼前的一切震住了，这是一个比ThoughtWorks还ThoughtWorks的工作环境：开放的工作环境，各式各样奇怪的Token，满眼的卡片墙，高高挂起的CI监视器，还有那用投影仪打出的系统运行状态监控。做咨询的时候，我试图给客户描绘的工作场景，就在眼前。<br>\n<br>\n与客户的架构师讨论技术方案，我才知道，在我心目中那个普通得甚至让我觉得有些土的项目，原来背后还有这么多东西，这个架构师心目中的蓝图是如此宏伟，实现这个蓝图，想想都是一件令人兴奋的事。<br>\n<br>\n要在EC2上搭一个环境，我得到了一份指南，把指南上仅有的几条命令敲进去，一个环境就搭好了。我对人说，这是我搭环境最省事的一次，此乃惊喜。人家摇摇头，这还不够，我们要做的是一键式，一个命令就搞定。所谓“<a href=\"http://en.wikipedia.org/wiki/DevOps\" target=\"_blank\">DevOps</a>\n”。<br>\n<br>\n与同事们一起交流，我知道了，这个公司并不是那种“我只要功能”的公司，他们对于软件技术本身的关注不在ThoughtWorks之下，所以，才有了我眼见的一切。也正是因为他们做得很好，许多新东西不断的从中产生出来，据说，他们为开源社区贡献了好多。<br>\n<br>\n亲见了，我开始理解gigix说的<a href=\"http://gigix.agilechina.net/2011/3/13/perfectionism\" target=\"_blank\">东西</a>\n。一个值得我们好好学习的客户，可遇不可求。</p>\n<p>这个项目会挺有意思的，希望如此。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201103162140",
    "date": "2011-03-16",
    "time": "21:40",
    "title": "跟《JavaScript语言精粹》学习",
    "tags": [
      "JavaScript",
      "书评"
    ],
    "body": "<p>读过《Effective Java》之后，我一直觉得，学习一门语言至少要读两本书，一本教人基础知识，一本教人如何用好这 门语言。现在，这个观念被打破了，它叫《<a href=\"http://book.douban.com/subject/3590768/\" target=\"_blank\">JavaScript语言精粹</a>\n》（<a href=\"http://book.douban.com/subject/2994925/\" target=\"_blank\">JavaScript: The Good Parts</a>\n）。很简单，它一本书干了两本书的事，而且它还很薄。</p>\n<p>不同于其它语言，谈及JavaScript，我们指的很少是单纯的语言，大多数情况下，还暗含着对网页的操作，对浏览器的控制。了解和接触到的很多项目里，JavaScript也运用得极其平凡，让人觉得JavaScript是一杯简单得不能再简单的白开水，甚至不需要专门学习。</p>\n<p><a href=\"http://nodejs.org/\" target=\"_blank\">Node.js</a>\n给了我一个丢开网页，抛开浏览器的机会，这时，我才发现原来JavaScript也是一门很有趣的语言，比如，它没有通常意义的类，我们却依然可以如面向对象语言一样使用对象，比如，函数在它里面早已扮演了重要的作用。</p>\n<p>我翻出那本买了许久却未拜读的《JavaScript语言精粹》。刚买的时候，我也曾翻过，始终找不到读这本书的感觉，一直觉得哪不对劲。这次翻开，我终于明白了，这本书真的是讲JavaScript语言的，指望用它学会页面上的开发，无疑于痴人说梦。</p>\n<p>Node.js的存在，让我们有机会独立操练JavaScript。二者相互配合，就可以大踏步的在学习JavaScript大路上不断前行了。</p>\n<p>在《<a href=\"http://book.douban.com/subject/5355285/\" target=\"_blank\">编程人生</a>\n》（<a href=\"http://book.douban.com/subject/3673223/\" target=\"_blank\">Coders at Work</a>\n）里，JavaScript最初的作者Brendan Eich讲述了创造JavaScript的过程，于是，我们知道了，JavaScript是个急就章的产物：精华与糟粕齐飞。那些精心设计的语言都要小心翼翼的去使用，何况是这个不那么精心的语言。如何正确的使用JavaScript就成了摆在开发人员面前的问题。</p>\n<p><a href=\"http://www.crockford.com/\" target=\"_blank\">Douglas Crockford</a>\n，这位资深JavaScript大师用《JavaScript语言精粹》很好的回答了这个问题。这本书直接把JavaScript语言特性分成精华、糟粕和鸡肋。精华是我们应该细心研习，至于糟粕和鸡肋，尽量回避。</p>\n<p>有了这本轻薄的书，我们便可以一口气学习如何用好的JavaScript。当然，如果你希望学习的“传统的JavaScript语言”，那这本书只能做一个起点。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201102241547",
    "date": "2011-02-24",
    "time": "15:47",
    "title": "Hello，Node.js（三）",
    "tags": [
      "node.js"
    ],
    "body": "<p>初涉Node.js，require引起了我的注意。<br>\n<br>\n编写JavaScript代码时，我特别想做的事就是把公共代码提取出来放到一个单独文件里。无情的现实告诉我，对于这种大路货般的需求，JavaScript的支持并不好。我们不能在一个文件中声明（无论是import、include还是require），只能在每个需要的页面进行声明。这种做法并不符合我对程序设计语言的审美。<br>\n<br>\n看到require时，我知道一些不同的东西出现了。它给JavaScript提供了一种module机制，通过它，我们可以把代码分散到不同文件里了，告别一棵树上吊死的尴尬。<br>\n<br>\n下面是一个简单的例子。我们有一个module，放在hello.js里。<br>\nexports.hello = function(name) {<br>\n&nbsp;&nbsp;&nbsp; return \"hello \" + name;<br>\n}<br>\n(hello.js)<br>\n<br>\n在同样的目录，我们还有一个main.js，其中调用了hello.js定义的函数。<br>\nvar module = require('./hello');<br>\nconsole.log(module.hello('dreamhead'));<br>\n(main.js)<br>\n<br>\n接下来，就是执行代码，我们会看到给予我们的问候。<br>\n$ node main.js<br>\nhello dreamhead<br>\n<br>\n实际上，module能力并不是Node.js带来的，而是源自<a href=\"http://www.commonjs.org/\" target=\"_blank\">CommonJS</a>\n。Module只是CommonJS的一部分。<br>\n<br>\n就CommonJS而言，它有一个更为宏大的目标。官方的JavaScript标准只为构建基于浏览器的应用提供了一些基础的API。随着JavaScript的发展，浏览器已无法阻挡JavaScript，越来越多的JavaScript应用超出了浏览器的范畴。这时JavaScript自身的一些限制成为了障碍。于是，有人提出为JavaScript定义一些构建通用应用所需的API，这种努力的结果就是CommonJS。</p>\n<p>CommonJS定义了许多<a href=\"http://www.commonjs.org/specs/\" target=\"_blank\">规范</a>\n，module就是其中之一，此外，还有诸如一些标准库，比如，console、文件系统等等，还有包机制等等。CommonJS有很多不同的<a href=\"http://www.commonjs.org/impl/\" target=\"_blank\">实现</a>\n，Node.js就是实现之一。</p>\n<p>正是CommonJS的存在，Node.js得以变身为一个编程平台。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201102211048",
    "date": "2011-02-21",
    "time": "10:48",
    "title": "Hello，Node.js（二）",
    "tags": [
      "node.js"
    ],
    "body": "<p>从<a href=\"http://dreamhead.blogbus.com/logs/105599686.html\" target=\"_blank\">上一篇的介绍</a>\n里面，我们知道了Node.js可以用来编写Server端应用。但实际上，Node.js带来的可不这些，其实，我们可以把它视为一个独立的编程平台，通过它，我们可以像使用Ruby、Python一样使用JavaScript。<br>\n<br>\n所以，学习Node.js和学习其它编程平台可以等同起来，事实上，人们也是这样来对待Node.js的。比如，在Ruby中，我们通过RubyGems管理各种软件包进行管理，而在Node.js中，与之对应的是<a href=\"http://npmjs.org/\" target=\"_blank\">npm</a>\n。<br>\n<br>\n安装npm，非常简单，只要执行下面的命令即可。<br>\n$ curl http://npmjs.org/install.sh | sh<br>\n<br>\n有了npm，我们就可以利用它安装软件包了，欲知有哪些软件包可以安装，npm为我们提供了<a href=\"http://search.npmjs.org/\" target=\"_blank\">一个可以搜寻的地方</a>\n。<br>\n<br>\n如果你熟悉常见的包管理器，用npm安装软件包和它们如出一辙。以Express为例：<br>\n$ npm install express<br>\n<br>\n<a href=\"http://expressjs.com/\" target=\"_blank\">Express</a>\n是一个web开发框架，不过，它并不是<a href=\"http://rubyonrails.org/\" target=\"_blank\">Rails</a>\n那样的全功能框架，而更多的把精力集中在web层，如果你熟悉Ruby世界的开发框架，它更像<a href=\"http://www.sinatrarb.com/\" target=\"_blank\">Sinatra</a>\n。<br>\n<br>\n下面就是Express版的“hello, world”：<br>\nvar app = require('express').createServer();<br>\n<br>\napp.get('/', function(req, res){<br>\n&nbsp;&nbsp;&nbsp; res.send('hello world');<br>\n});<br>\n<br>\napp.listen(3000);<br>\n<br>\n把它保存在hello_express.js中，我们就可以运行它了：<br>\n$ node hello_express.js<br>\n<br>\n好，打开浏览器，访问http://localhost:3000/，我们就可以看到来自express的问候了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201102171055",
    "date": "2011-02-17",
    "time": "10:55",
    "title": "Hello，Node.js",
    "tags": [
      "node.js"
    ],
    "body": "<p><strong>简介</strong>\n<br>\n<a href=\"http://nodejs.org/\" target=\"_blank\">Node.js</a>\n是什么？它的主页上如是说：<br>\nEvented I/O for V8 JavaScript. <br>\n<br>\n或许<a href=\"http://en.wikipedia.org/wiki/Node.js\" target=\"_blank\">wikipedia上的说法</a>\n更容易让人理解：<br>\nNode.js is an event-driven I/O framework for the V8 JavaScript engine on Unix-like platforms. It is intended for writing scalable network programs such as web servers.<br>\n<br>\n简单说来，通过Node.js，我们可以用JavaScript编写Server端应用。显然，这超出我们对JavaScript的常规理解。在传统的印象中，JavaScript是用在浏览器里，用以处理web页面。<br>\n<br>\n<strong>安装</strong>\n<br>\n下载Node.js，解压缩之后，就是从源码构建Unix应用的常见方式：<br>\n$ ./configure --prefix=$HOME/local/node<br>\n$ make<br>\n$ make install<br>\n$ export PATH=$HOME/local/node/bin:$PATH<br>\n<br>\n更详细的安装文档请参考：<br>\n<a href=\"https://github.com/ry/node/wiki/Installation\" target=\"_blank\">https://github.com/ry/node/wiki/Installation</a>\n<br>\n<strong><br>\n一个例子</strong>\n<br>\n下面是一个来自Node.js网站的例子，实现了一个简单的echo server。<br>\nvar net = require('net');<br>\nnet.createServer(function (socket) {<br>\n&nbsp; socket.write(\"Echo server\\r\\n\");<br>\n&nbsp; socket.on(\"data\", function (data) {<br>\n&nbsp;&nbsp;&nbsp; socket.write(data);<br>\n&nbsp; });<br>\n}).listen(8124, \"127.0.0.1\");<br>\n<br>\n这个例子展示了Evented I/O的基本处理方式，其实也就是常见的异步处理基本手法，为特定的事件注册一个处理函数。当对应的事件发生时，就会回调这个函数进行处理。<br>\n<br>\n在这个例子里面，我们为socket的data事件注册一个处理（匿名）函数。其实，调用createServer时传进去的函数，也是一个事件处理函数，它处理的是这个server的connection事件。<br>\n<br>\n接下来，就该运行了，把上面的代码保存echo_server.js里面：<br>\n$ node echo_server.js<br>\n<br>\n好，server启动了，可以体验一下了，我们可以用telnet进行测试<br>\n$ telnet localhost 8124<br>\n<br>\n随便输入一些什么，我们看到它都会把输入的内容返回给我们。这就是我们用Node.js实现的第一个程序了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201102152240",
    "date": "2011-02-15",
    "time": "22:40",
    "title": "告别外星人",
    "tags": [
      "我眼看世界",
      "足球"
    ],
    "body": "<p>2011年2月14日，情人节，罗纳尔多，退役了。</p>\n<p>正式成为球迷不久，《足球俱乐部》杂志上开始了一个新的专题，叫《谁是球王接班人》，介绍一些当时的新星。这个专题里出现的第一个名字是，罗纳尔多。那时的他还在埃因霍温，还没有开始起飞，但94年世界杯冠军队成员的身份让许多人对他寄以很高的期望。</p>\n<p>在巴塞罗那，他开启了自己的巨星征程，虽然巴萨之旅只有短暂的一年，却留下了许多让人铭记的经典入球，也是那时候，他成了外星人。</p>\n<p>后来，他批上蓝黑战袍，也开始了那段辉煌与痛苦交相辉映的多舛经历：</p>\n<ul>\n<li>他成了足球先生</li>\n<li>法国世界杯，状态神勇的他突然在决赛迷失了</li>\n<li>他两次倒在意大利赛场上，尤其是第二次，刚刚重回赛场的他，轰然倒下的画面，让人心痛</li>\n<li>终于，他回来了，意甲冠军近在咫尺却失之交臂，我依然记得被换下场的脸上难以抑制的泪水</li>\n<li>韩日世界杯，少有人看好他和他的巴西，他们却在最终登顶，拥有众多个人荣誉的他，终于有了一个有分量的冠军头衔。</li>\n</ul>\n<p>带着世界冠军的头衔，他离开了意大利，加入银河战舰。在那，他赢得了自己的第一个联赛冠军，也经历德国世界杯的沮丧。<br>\n<br>\n再后来，他披上红黑剑条衫，那是我最高兴的看到的一幕，自己喜欢的球星加入自己喜欢的球队。虽然他没有直接贡献，但他的到来给AC米兰带来一个欧洲冠军杯，也是他职业生涯中唯一欠缺的，洲际比赛的冠军。只可惜，随之而来的不是再次征服欧洲，而是又一次伤病，他又倒下了，面对米兰在伤病期送上的新合同，他选择了拒绝，于是，这也成了他欧洲赛场的绝唱。<br>\n<br>\n像他这样功成名就的球员，回到巴西，给人的感觉更多的是享受足球。虽然不能经常看到他的表演，但我们还是可以时不时欣赏来自他的进球。</p>\n<p>如今，他退役了，让他放弃的依然是不断让他倒下的伤痛。他是那个时代最伟大的球星之一，感谢罗纳尔多给我们带来的精彩表演。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201101252325",
    "date": "2011-01-25",
    "time": "23:25",
    "title": "曾以为懂的基础",
    "tags": [
      "脚下的路",
      "ThoughtWorks"
    ],
    "body": "<p><a href=\"http://blog.vincentx.info/\" target=\"_blank\">徐昊</a>\n被拉了过来，没别的说，压榨，于是，两天都在让他给大家上课。<br>\n<br>\n培训的内容之一是OO训练营，这是ThoughtWorks内部的一个传统培训项目，我也曾做过讲师。之前的训练营，更多的是为了介绍一些基础的概念，比如面向对象，比如设计模式。这个训练营是改造过的，面向的主要是ThoughtWorks内部员工，这些人都有基本的概念，所以，侧重点要调整一下。<br>\n<br>\n确实，当侧重点一调整，问题就暴露出来了。参加这次培训的多是一些毕业生或是加入公司时间不长的同事，之前都看过不少书，这次训练营在一些他们以为懂了的地方给了他们下马威。</p>\n<ul>\n<li>封装</li>\n</ul>\n<p>面向对象最基本的特征是封装，说起来，大家都明白。真的懂了吗？代码写出来就是一大堆getter，内部细节换了个面孔全都暴露出来了。许多设计原则都是与封装紧密相关，比如SRP，比如OCP。封装不好也是一种坏味道，可以指导着我们向着好代码前进。我承认，识别封装的坏味道比识别重复要求高。</p>\n<ul>\n<li>重构</li>\n</ul>\n<p>重构不是老马的书，不是IDE上的菜单。重构需要不破坏测试的小步前进。说到重构，其实，很多人脑子里想的是重写。一对pair中死在了在“重构”的路上：时间到，他们的代码没有到达“重构”的终点，又退不回来。于是，接下来的演示，徐昊重构了他们的代码，每一步都很小，不会进退两难。他的演示让我看到，有时我的步子还不够小。</p>\n<ul>\n<li>划分任务</li>\n</ul>\n<p>TDD简单得令人发指，红——绿——重构。但这真的就是TDD的全部了吗？这只是形。知道了TDD节奏，却依然下不了手的，大有人在。解决问题的方案，说白了，就是拆。把需求拆解成更小的任务，何愁无解。多大的任务算小，可以测试。把问题分解成小任务，才会能做到心里有数，才不会让“剩余的10%”和“前面的90%”用同样甚至更多的时间完成。大事化小是需要能力的，这是很多人过不了TDD这关的真正原因。只是，大多数人连划分任务的习惯都没有。</p>\n<ul>\n<li>模式</li>\n</ul>\n<p>模式俨然已是大路货，不知道模式都不好意思和人打招呼。但什么时候使用模式却不见得人人知晓。现实问题和书上总有差异，当问题摆在面前，狼烟四起的坏味道告诉我们，许多人对此视而不见。有时，嗅觉，比招式更重要。<br>\n<br>\n因为有先发优势，徐昊在训练营里讲的大多数东西，我是心里有数的。在别人忙着用左脑思考的时候，我在用右脑做着综合，思路得到了一次清理，也看到自己在日常工作中还有许多能够提高的细节。<br>\n<br>\n被培训可比培训感觉好多了。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201101182034",
    "date": "2011-01-18",
    "time": "20:34",
    "title": "那一点的调用",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>每每我讲如何写好代码，总会有人跳出来，无比惆怅的跟我说，你说的这些都挺好，我也认同，只是我面对的是一个有着悠久历史的遗留系统。然后，用一种痛说革命家史的架势，给我列举无数的理由。总而言之，一句话，不是我不想学好，形势让我没法学好。<br>\n<br>\n初时，我会耐心的听他叙述完一切，心中充满无比的同情。但是，让我百思不得其解的是，为啥我从来没遇到这种情况。我与人合作的过程中面对的难道不是同一个代码库吗？我怎么能坚持把代码写好，而且，奇怪的是，和我一起合作的人从来没有提出过这种问题。<br>\n<br>\n没有调查研究就没有发言权，我开始观察他们的工作方式，开始通过code diff了解他们修改代码的方式。当我看到在一大片代码被塞到了一个原本已经很大的函数里，我顿悟了，这就是差别。<br>\n<br>\n我知道旧代码非我一己之力一朝一夕可以改变，惹不起，躲得起。面对同样的情况，我会选择在一个新函数开始编写新代码，当然，作为ThoughtWorker，会有测试的。当我放心的完成了这个新函数，接下来，就是在旧代码里找到调用点，在那里放一个简单的函数调用。<br>\n<br>\n由于各种各样的原因，旧代码没有测试，甚至没办法测试，所以，新加的这个函数调用可能也测试不了，但是，只有一句没测试，显然比一大片代码没测试要令人更放心一些。<br>\n<br>\n这个思路简单得一塌糊涂。<br>\n<br>\n我做旧架构调整，用到的也是同样的思路，设计新架构，然后用一个dispatcher在入口处做分发，新旧架构得以并存。Martin Fowler的<a href=\"http://martinfowler.com/dsl.html\" target=\"_blank\">DSL</a>\n里有一个Embedment Helper，也是类似的想法，如果需要在文法文件里嵌入代码，就是一句简单的函数调用，而把更多的代码放到另外的类里。<br>\n<br>\n从此以后，我不再同情那些抱怨沉重代码库让他们没法写好代码的人。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201101101552",
    "date": "2011-01-10",
    "time": "15:52",
    "title": "读《程序员的思维修炼》",
    "tags": [
      "我眼看世界",
      "书评"
    ],
    "body": "<p>这是一本很牛的书。<br>\n这是一本关于如何用脑的书。<br>\n这是一本程序员写的如何用脑的书。<br>\n<br>\n作为程序员的我，读起来格外亲切。<br>\n<br>\n或许对于一个在用脑方面有所研究的人，这不是一本非常专业的书，但对我来说，这本书足以给予我很大的触动了。<br>\n<br>\n做咨询的时候，我曾为客户的程序员制订了一个新的编码规范。比如，一个函数的代码行小于30行，缩进不能超过三层等等。<br>\n<br>\n那时，做这事更多的是一种直觉。如今，我为我的行为找到了一个合理的解释：Dreyfus模型。在编写干净代码方面，这些人都是新手，需要规则指导。<br>\n<br>\n如果我有机会再次面对客户，对那些期待制订简单规则就做好敏捷的人，我会祭出Dreyfus模型，告诫他们这种想法是多么的天方夜谭，因为那是新手的境界。<br>\n<br>\n对于一个团队而言，有规则固然好，但规则也是对优秀人才的羁绊。教条的规则只是用来指挥新手的，那些更有才能的人，强烈的规则约束要么会禁锢他们的大脑，要么逼他们选择远走高飞。放他们去飞，他们会给予团队更大的惊喜。<br>\n<br>\nDreyfus只是这本让我惊喜的书中的一项内容，这本书的内容还有很多，比如认知偏见，比如利用大脑模拟成功，比如避免分心。写下此篇时，我用<a href=\"http://freeverse.com/mac/product/?id=7013\" target=\"_blank\">Think</a>\n屏蔽了其它程序，把注意力集中在一点。<br>\n<br>\n这是一本如何用脑的书，但另一方面，这本书也让我看到了人是如何思考的，它帮我解释了我在职业生涯中遇到的许多现象，下面便是其中一例：<br>\n<br>\n有一次，和一个团队合作，我们惊奇的发现，在4G内存逐渐成为标配的日子里，这个团队的很多人还在用着512M或是1G内存，当我们提出给团队增加内存的时候，有人说，现在这样也能用。对这个组织来说，换内存也是件困难重重的事情。<br>\n<br>\n经过不懈的努力，费尽九牛二虎之力，所有的内存都提升到了2G。没有人再和我们说，1G也挺好。后来，到了新团队，所有的机器都是2G。一打听，一段时间之前统一升级的。我们在前一个团队升级内存的举动让上层领导认识到2G内存是必要的，于是，后来者都轻松的升级了。<br>\n<br>\n这就是一种认知偏见：思维定势。没做的时候，认为不可能，做到了，就习以为常。<br>\n<br>\n这本书让我收益良多，如果你有空的话，不妨也来做一次思维修炼！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201012292311",
    "date": "2010-12-29",
    "time": "23:11",
    "title": "代码之丑（十）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>C语言出现之初，跨平台是个极大的卖点。于是，我们有机会看到这样的代码：<br>\n&nbsp; int sys_old_mmap(struct tcb *tcp)<br>\n&nbsp; {<br>\n&nbsp;&nbsp;&nbsp; long u_arg[6];<br>\n<br>\n&nbsp; #if defined(IA64)<br>\n&nbsp;&nbsp;&nbsp; int i, v;<br>\n&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 6; i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (umove(tcp, tcp-&gt;u_arg[0] + (i * sizeof(int)), &amp;v) == -1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_arg[i] = v;<br>\n&nbsp; #elif defined(SH) || defined(SH64)<br>\n&nbsp;&nbsp;&nbsp; int i;<br>\n&nbsp;&nbsp;&nbsp; for (i=0; i&lt;6; i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_arg[i] = tcp-&gt;u_arg[i];<br>\n&nbsp; #else<br>\n&nbsp;&nbsp;&nbsp; if (umoven(tcp, tcp-&gt;u_arg[0], sizeof(u_arg), (char *) u_arg) == -1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp; #endif&nbsp; // defined(IA64)<br>\n&nbsp;&nbsp;&nbsp; return print_mmap(tcp, u_arg);<br>\n&nbsp; }<br>\n<br>\n你已经知道了我要说什么了，是的，条件编译。<br>\n<br>\n条件编译在解决跨平台的问题上，确实是个利器，但这么用条件编译，就把它变成了一柄双刃剑。Robert Martin在《Clean Code》里告诉我们，函数应该只做一件事。从逻辑上来说，这段代码是做了一件事。但是，它还有另外一个维度，也就是条件编译的条件。这个维度的存在让一件事变成了多件事。<br>\n<br>\n无他，提取函数吧！<br>\n&nbsp; int sys_old_mmap(struct tcb *tcp)<br>\n&nbsp; {<br>\n&nbsp; #if defined(IA64)<br>\n&nbsp;&nbsp;&nbsp; return sys_old_mmap_for_ia64(tcp);<br>\n&nbsp; #elif defined(SH) || defined(SH64)<br>\n&nbsp;&nbsp;&nbsp; return sys_old_mmap_for_sh_or_sh64(tcp);<br>\n&nbsp; #else<br>\n&nbsp;&nbsp;&nbsp; return default_sys_old_mmap(tcp);<br>\n&nbsp; #endif&nbsp; // defined(IA64)<br>\n&nbsp; }<br>\n<br>\n&nbsp; int sys_old_mmap_for_ia64(struct tcb *tcp) {<br>\n&nbsp;&nbsp;&nbsp; long u_arg[6];<br>\n&nbsp;&nbsp;&nbsp; int i, v;<br>\n&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 6; i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (umove(tcp, tcp-&gt;u_arg[0] + (i * sizeof(int)), &amp;v) == -1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_arg[i] = v;<br>\n<br>\n&nbsp;&nbsp;&nbsp; return print_mmap(tcp, u_arg);<br>\n&nbsp; }<br>\n<br>\n&nbsp; int sys_old_mmap_for_sh_or_sh64(struct tcb *tcp) {<br>\n&nbsp;&nbsp;&nbsp; long u_arg[6];<br>\n&nbsp;&nbsp;&nbsp; int i;<br>\n&nbsp;&nbsp;&nbsp; for (i=0; i&lt;6; i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_arg[i] = tcp-&gt;u_arg[i];<br>\n<br>\n&nbsp;&nbsp;&nbsp; return print_mmap(tcp, u_arg);<br>\n&nbsp; }<br>\n<br>\n&nbsp; int default_sys_old_mmap(struct tcb *tcp) {<br>\n&nbsp;&nbsp;&nbsp; long u_arg[6];<br>\n&nbsp;&nbsp;&nbsp; if (umoven(tcp, tcp-&gt;u_arg[0], sizeof(u_arg), (char *) u_arg) == -1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n<br>\n&nbsp;&nbsp;&nbsp; return print_mmap(tcp, u_arg);<br>\n&nbsp; }<br>\n<br>\n好，经过一番分解，函数比原来的规模小了许多，更重要的是，我们把针对不同的条件做法已经拆解开来了。<br>\n<br>\n相对于原来的版本，这是一段可以接受的代码。制约原有代码的出现，我们也可以用一个简单的规则：</p>\n<ul>\n<li>条件编译里面不允许包含多条执行语句。</li>\n</ul>\n<p>不过，这还不是终点。针对上面的情况，这种改法没有问题，因为提取出来的小函数在各个平台上都可以编译，但如果涉及到特定平台的操作，简单的提取就不起作用了。比如，用到了Windows API的代码在Linux上恐怕连编译这关都过不了。<br>\n<br>\n一种可能的解决方案是，把不同条件的内容放进不同的文件。<br>\n&nbsp; int sys_old_mmap(struct tcb *tcp) {<br>\n&nbsp;&nbsp;&nbsp; long u_arg[6];<br>\n&nbsp;&nbsp;&nbsp; int i, v;<br>\n&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 6; i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (umove(tcp, tcp-&gt;u_arg[0] + (i * sizeof(int)), &amp;v) == -1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_arg[i] = v;<br>\n<br>\n&nbsp;&nbsp;&nbsp; return print_mmap(tcp, u_arg);<br>\n&nbsp; }<br>\n&nbsp; (ia64.c)<br>\n<br>\n&nbsp; int sys_old_mmap(struct tcb *tcp) {<br>\n&nbsp;&nbsp;&nbsp; long u_arg[6];<br>\n&nbsp;&nbsp;&nbsp; int i;<br>\n&nbsp;&nbsp;&nbsp; for (i=0; i&lt;6; i++)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u_arg[i] = tcp-&gt;u_arg[i];<br>\n<br>\n&nbsp;&nbsp;&nbsp; return print_mmap(tcp, u_arg);<br>\n&nbsp; }<br>\n&nbsp; (sh.c)<br>\n<br>\n&nbsp; int sys_old_mmap(struct tcb *tcp) {<br>\n&nbsp;&nbsp;&nbsp; long u_arg[6];<br>\n&nbsp;&nbsp;&nbsp; if (umoven(tcp, tcp-&gt;u_arg[0], sizeof(u_arg), (char *) u_arg) == -1)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n<br>\n&nbsp;&nbsp;&nbsp; return print_mmap(tcp, u_arg);<br>\n&nbsp; }<br>\n&nbsp; (default.c)<br>\n<br>\n同之前的一个差别在于，不再有一个统一的sys_old_mmap，而是大家有了各自的sys_old_mmap，分别放在了对应的文件里。构建的时候，我们可以根据不同的条件编译链接不同的文件，这样就可以回避前面提到的问题。<br>\n<br>\n之前谈及的那些丑陋代码大多是在一个文件内部做着各种各样的变换，而这次的变动显然大了很多，甚至需要配合构建过程的修改。为了对付丑陋的代码，我们总是有办法的。</p>\n<p>即便劳神费力的修改构建过程，我依然认为是值得的。其实，我们想要的，无非是明天的日子好过一些。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/12/ugly-code-10\" target=\"_blank\">专栏：代码之丑（十）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201012202226",
    "date": "2010-12-20",
    "time": "22:26",
    "title": "代码之丑（九）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>这是一个让我纠结了很久的话题：缩进。<br>\n&nbsp; for (int j = 0; j &lt; attributes.size(); j++) {<br>\n&nbsp;&nbsp;&nbsp; Attr *attr = attributes.get(j);<br>\n&nbsp;&nbsp;&nbsp; if (attr == NULL ) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n<br>\n&nbsp;&nbsp;&nbsp; int IsCallFunc = -1;<br>\n&nbsp; &nbsp; if(attr-&gt;status() == STATUS_NEW || attr-&gt;status() == STATUS_MODIFIED) {<br>\n&nbsp; &nbsp; &nbsp; if(strcmp(attr-&gt;attrID(), \"CallFunc\") == 0) {<br>\n&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; if(0 == strcmp(attr-&gt;attrValue(), \"1\")) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; IsCallFunc = 1;<br>\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; } else if(0 == strcmp(attr-&gt;attrValue(), \"0\")) {<br>\n&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; IsCallFunc = 0;<br>\n&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; }<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp; } else if (attr-&gt;status() == STATUS_DELETED) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsCallFunc = 0;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n<br>\n&nbsp; &nbsp; ...<br>\n&nbsp; }<br>\n<br>\n不是因为它不够“丑”，而是表现它不那么容易。找出一段能表现它特点的代码轻而易举，但放到一篇文章里，大片的代码还是容易让人怀疑我在偷懒。<br>\n<br>\n咬咬牙，我还是拿出了一段。就是这样一段已经缩进很多层的代码，实际上，也只不过是一个更大缩进中的一小段。而且，省略号告诉我们，后面还有。<br>\n<br>\n回到这段代码上，能出现多层缩进，for循环功不可没。出现这种循环，很多情况下，都是对一个集合进行处理，而循环里的内容，就是对集合里的每一个元素进行处理。这里也不例外。所以，我们先做一次提取：<br>\n&nbsp; for (int j = 0; j &lt; attributes.size(); j++) {<br>\n&nbsp;&nbsp;&nbsp; processAttr(attributes.get(j));<br>\n&nbsp; }<br>\n<br>\n&nbsp; void processAttr(Attr *attr) {<br>\n&nbsp;&nbsp;&nbsp; if (attr == NULL ) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n<br>\n&nbsp;&nbsp;&nbsp; int IsCallFunc = -1;<br>\n&nbsp;&nbsp;&nbsp; if(attr-&gt;status() == STATUS_NEW || attr-&gt;status() == STATUS_MODIFIED) {<br>\n&nbsp;&nbsp; &nbsp;&nbsp; if(strcmp(attr-&gt;attrID(), \"CallFunc\") == 0) {<br>\n&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; if(0 == strcmp(attr-&gt;attrValue(), \"1\")) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsCallFunc = 1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if(0 == strcmp(attr-&gt;attrValue(), \"0\")) {<br>\n&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; IsCallFunc = 0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp; } else if (attr-&gt;status() == STATUS_DELETED) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsCallFunc = 0;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n<br>\n&nbsp;&nbsp;&nbsp; ...<br>\n&nbsp; }<br>\n<br>\n至此，我们去掉了一层缩进，而且因为这个提取，语义也变得很清晰：这个新函数只是处理集合里的一个元素。<br>\n<br>\n接下来，这个函数里面长长的代码是对IsCallFunc进行设值，后面省略的部分会根据这里求出的结果进行处理。所以，这里把processAttr进一步分拆：<br>\nvoid processAttr(Attr *attr) {<br>\n&nbsp; if (attr == NULL ) {<br>\n&nbsp;&nbsp;&nbsp; return;<br>\n&nbsp; }<br>\n<br>\n&nbsp; int IsCallFunc = isCallFunc(attr);<br>\n&nbsp; …<br>\n}<br>\n<br>\nint isCallFunc(Attr *attr) {<br>\n&nbsp; if(attr-&gt;status() == STATUS_NEW <br>\n&nbsp; || attr-&gt;status() == STATUS_MODIFIED) {<br>\n&nbsp;&nbsp;&nbsp; if(strcmp(attr-&gt;attrID(), \"CallFunc\") == 0) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(0 == strcmp(attr-&gt;attrValue(), \"1\")) {<br>\n&nbsp;&nbsp;&nbsp; return 1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if(0 == strcmp(attr-&gt;attrValue(), \"0\")) {<br>\n&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp; }<br>\n&nbsp; } else if (attr-&gt;status() == STATUS_DELETED) {<br>\n&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp; }<br>\n<br>\n&nbsp; return -1;<br>\n}<br>\n<br>\nisCallFunc的代码已经独立出来，但依然有多层缩进，分解可以继续：<br>\n&nbsp; int isCallFunc(Attr *attr) {<br>\n&nbsp; &nbsp; if(attr-&gt;status() == STATUS_NEW || attr-&gt;status() == STATUS_MODIFIED) {<br>\n&nbsp; &nbsp; &nbsp; return isCallFuncForNewOrModified(attr);<br>\n&nbsp;&nbsp;&nbsp; } else if (attr-&gt;status() == STATUS_DELETED) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n<br>\n&nbsp;&nbsp;&nbsp; return -1;<br>\n&nbsp; }<br>\n<br>\n&nbsp; int isCallFuncForNewOrModified(Attr *attr) {<br>\n&nbsp;&nbsp;&nbsp; if(strcmp(attr-&gt;attrID(), \"CallFunc\") == 0) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(0 == strcmp(attr-&gt;attrValue(), \"1\")) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if(0 == strcmp(attr-&gt;attrValue(), \"0\")) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp; }<br>\n<br>\n&nbsp;&nbsp;&nbsp; return -1;<br>\n&nbsp; }<br>\n<br>\n缩进还有，如果有兴趣，还可以继续分解。这里就到此为止吧！<br>\n<br>\n多层缩进是那种放在代码海一眼就可以认出来的代码，用一条简单的规则就可以限制它：</p>\n<ul>\n<li>不允许出现多层缩进。</li>\n</ul>\n<p>按照我的喜好，3就意味着“多”了。对于switch，我会给予特别的关照，因为switch一旦出场，条件少了，你都不好意思和人打招呼，再缩进就找不到北了。于是，对switch而言，我以为2就是多了，也就是说，switch里面就别再缩进了。<br>\n<br>\n写代码，千万别退让太多。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/12/ugly-code-9\" target=\"_blank\">专栏：代码之丑（九）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201012142247",
    "date": "2010-12-14",
    "time": "22:47",
    "title": "7年，依然前行",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>7年了，又blog了一年。<br>\n<br>\n对于这个blog而言，最大的变化是我申请成为了VIP用户，只是为了去掉blog里面的广告。至于年限，我选择了5年，因为我在这里blog的时间已经超过了5年。如果坚持下来，我就是一个有10+年blog经验的人了。<br>\n<br>\n最近公司不断在鼓励一些经验稍浅的同事写blog，于是，我也借此总结了一下自己写blog的经验。<br>\n<br>\n初涉blog之际，我从未考虑过为谁去写，没有想过所谓的风格。随着写得越来越多了，才逐渐的形成了自己的一个大方向，小方向也无数次的变过。<br>\n<br>\n如果说我有设想过我的受众，那就是我自己。我会自己写给自己看，自己给自己挑毛病。我自己喜欢了，肯定会有人喜欢：</p>\n<ul>\n<li>我不喜欢读大段的文字，所以，我的blog都是一个个小段落组成的；</li>\n<li>我不喜欢那些高屋建瓴的指导，所以，我会用尽可能平实的语言；</li>\n<li>我喜欢循序渐进的推理，所以，我会争取让推导过程变得清晰；</li>\n<li>我喜欢简单，所以，我会研究一些东西，写出一篇能体现出我以为核心的“Hello，XXX”。</li>\n<li>⋯⋯</li>\n</ul>\n<p>我跟很多人聊过，他们不写或写得少，很重要的一个原因是，怕别人嫌没技术含量。<br>\n<br>\n敢写blog，就不需要担心别人的议论。有人议论，说明有人关心你写的东西，这是好事；有人赞扬，说明有人认同你的观点；有人批评，至少可以让我们从多角度更仔细考虑；实在有的批评让人觉得受不了，忽略它吧！好的评论者会告诉你一二三，只有那些不负责任的才会抛出只让人生气的观点。<br>\n<br>\n定期写blog是很重要的。比如我基本上是一周一篇。坚持一段时间之后，一旦不写，就会觉得缺少些什么，所以，总会逼得自己去做。</p>\n<p>这就是习惯的力量。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201012122342",
    "date": "2010-12-12",
    "time": "23:42",
    "title": "代码之丑（八）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p><span id=\"zw-12cdd2ada6e5AZsmE438d2\">下面是一段代码，出现在一个函数里面：</span>\n<br id=\"zw-12cdd2ada6e60ts5G438d2\">\n&nbsp;&nbsp;\n<span id=\"zw-12cdd2ada6eAbiyeC438d2\">XString groupid;</span>\n<br id=\"zw-12cdd2ada6f24bNkm438d2\">\n&nbsp;&nbsp;\n<span id=\"zw-12cdd2ada6fpYDSed438d2\">getGroupidByTel(tel,\n groupid);</span>\n<br id=\"zw-12cdd2ada6fIyOz7438d2\">\n<br id=\"zw-12cdd2ada6fDFZEF438d2\">\n&nbsp;&nbsp;\n<span id=\"zw-12cdd2ada6fW_D89V438d2\">YString\n sql;</span>\n<br id=\"zw-12cdd2ada6fkSNaD2438d2\">\n&nbsp;&nbsp;\n<span id=\"zw-12cdd2ada6fMPLSfk438d2\">sql.SetData(\"select subsid from \nsubscriber b\");</span>\n<br id=\"zw-12cdd2ada70SMxzy5438d2\">\n<br id=\"zw-12cdd2ada704LCkYX438d2\">\n<span id=\"zw-12cdd2ada70Cr4FUZ438d2\">如果你没有注意到问题，我稍微提醒一下，这里用到了两个字符串类型。</span>\n<br id=\"zw-12cdd2ada70sUCUYK438d2\">\n<br id=\"zw-12cdd2ada70qzOBkn438d2\">\n<span id=\"zw-12cdd2ada70XWMlpW438d2\">这确实是一段真实的代码，于是，我找到了项目组中的人，询问两个字符串的来历。终于，一个颇有资历的人给了我一个答案。</span>\n<br id=\"zw-12cdd2ada70S-Pxt5438d2\">\n<br id=\"zw-12cdd2ada70tvtLsh438d2\">\n<span id=\"zw-12cdd2ada714s5-ox438d2\">项目之初，有人编写了XString，用了一段时间之后，在某些特定的场景\n下，XString会出问题，于是，又有英雄出现，编写了YString。从此，XString和YString并立于江湖。</span>\n<br id=\"zw-12cdd2ada710h7gN-438d2\">\n<br id=\"zw-12cdd2ada71pvPrei438d2\">\n<span id=\"zw-12cdd2ada711IXxOR438d2\">其实，我想搞清楚的只是一个问题，什么时候该用哪个类。</span>\n<br id=\"zw-12cdd2ada71om0Kkc438d2\">\n<br id=\"zw-12cdd2ada71UNLIr3438d2\">\n<span id=\"zw-12cdd2ada71r2dRBI438d2\">可是，我把这个问题抛给了不只一个人，却没有人能给我一个确定性的答案。好吧！当时，编写YString的动机是XString出了问题，那问题是什么呢？我看到的依旧是困惑的面孔。</span>\n<br id=\"zw-12cdd2ada71Lmm9X438d2\">\n<br id=\"zw-12cdd2ada71jFc5jb438d2\">\n<span id=\"zw-12cdd2ada72gAsiBh438d2\">XString和YString让我不安，原因在于，它们的并存破坏了概念一致性。一旦要写一段用到字符串的代码，我会纠结于到底该用XString还是YString。有时候，没有选择是幸福的。对于大规模团队而言，尤其如此。</span>\n<br id=\"zw-12cdd2ada724KaNfI438d2\">\n<br id=\"zw-12cdd2ada72ED6gzX438d2\">\n<span id=\"zw-12cdd2ada72mi8kog438d2\">最简单的做法自然是，选择其一，一统江湖。方法很简单，做一次全局替换就好了。</span>\n<br id=\"zw-12cdd2ada72JJnlPi438d2\">\n<br id=\"zw-12cdd2ada72R9-1F4438d2\">\n<span id=\"zw-12cdd2ada72ZNHekg438d2\">不过，理性告诉我，这是冲动的做法，特别是没有人对两个字符串有足够清晰认识的情况下。在一个叫现实的东西面前，我不得不低下头，改动遗留代码风险极大，况且没有足够的测试支撑我们。</span>\n<br id=\"zw-12cdd2ada72gjHeYO438d2\">\n<br id=\"zw-12cdd2ada73s5og8438d2\">\n<span id=\"zw-12cdd2ada73hPM6cY438d2\">但我们至少可以在编写的新代码中做出统一的要求，选择一条路走下去，而不是放任所有开发\n人员根据自己的脾气秉性、喜怒哀乐，甚至天气，随机的做出选择。</span>\n<br id=\"zw-12cdd2ada73ixGqcX438d2\">\n<br id=\"zw-12cdd2ada736cFHvB438d2\">\n<span id=\"zw-12cdd2ada73Pqgriq438d2\">好吧！\n我可以再退一步，如果在全系统统一确实是一件困难的事情，但至少，至少在一个函数内别再混用不同的字符串了。</span>\n</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/12/ugly-code-8\" target=\"_blank\">专栏：代码之丑（八）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201012061813",
    "date": "2010-12-06",
    "time": "18:13",
    "title": "代码之丑（七）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p id=\"zw-12cbb2d41eeRx8ytp438d2\"><span id=\"zw-12cbb2d5635RHygVO438d2\">这是一段用C++编写的数据库访问代码：</span>\n<br id=\"zw-12cbb2d5636bK84aA438d2\">\n<span id=\"zw-12cbb2d5636SD-npR438d2\">&nbsp; int Comm::setIDBySevNum(const XString&amp; servnumber) { </span>\n<br id=\"zw-12cbb2d5636UiS_Ii438d2\">\n<span id=\"zw-12cbb2d5636LeA_0V438d2\">&nbsp;&nbsp;&nbsp; \nDB db;</span>\n<br id=\"zw-12cbb2d5636qiyer6438d2\">\n<span id=\"zw-12cbb2d5636tyoZVl438d2\">&nbsp;&nbsp;&nbsp; db.setSQL(\"select id from users where\n servnumber=:servnumber\");</span>\n<br id=\"zw-12cbb2d5636wqBJ3F438d2\">\n<span id=\"zw-12cbb2d56372HKOq-438d2\">&nbsp;&nbsp;&nbsp; db.bind(\":servnumber\", \nservnumber.c_str()); </span>\n<br id=\"zw-12cbb2d5637AVIrRn438d2\">\n<span id=\"zw-12cbb2d5637cmZMNe438d2\">&nbsp;&nbsp;&nbsp; db.open();</span>\n<br id=\"zw-12cbb2d563722ZDhd438d2\">\n<br id=\"zw-12cbb2d5637hboNwp438d2\">\n<span id=\"zw-12cbb2d5637IDvrWr438d2\">&nbsp;&nbsp;&nbsp; if (!db.next()) {</span>\n<br id=\"zw-12cbb2d5637K8GI2C438d2\">\n<span id=\"zw-12cbb2d5637wNpelT438d2\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n return -1;</span>\n<br id=\"zw-12cbb2d5638fK0ZjW438d2\">\n<span id=\"zw-12cbb2d5638LCn-t7438d2\">&nbsp;&nbsp;&nbsp; }</span>\n<br id=\"zw-12cbb2d5638pVPfVS438d2\">\n<br id=\"zw-12cbb2d56382XL7t438d2\">\n<span id=\"zw-12cbb2d5638RcKhks438d2\">&nbsp;&nbsp;&nbsp; setID(db.getString(”id\"));</span>\n<br id=\"zw-12cbb2d5638tbLxF8438d2\">\n<span id=\"zw-12cbb2d5638NJn_t438d2\">&nbsp;&nbsp;&nbsp; \nreturn 0; </span>\n<br id=\"zw-12cbb2d56387Z_RNS438d2\">\n<span id=\"zw-12cbb2d56390YQiAo438d2\">&nbsp; }</span>\n<br id=\"zw-12cbb2d56397YN6Tw438d2\">\n<br id=\"zw-12cbb2d563992M51x438d2\">\n<span id=\"zw-12cbb2d5639YzQ-ZV438d2\">它告诉我们，如果找不到需要的值，那么操作失败，返回-1，否则，返回0，成功了。</span>\n<br id=\"zw-12cbb2d5639q9lZLZ438d2\">\n<br id=\"zw-12cbb2d5639zb6J3r438d2\">\n<span id=\"zw-12cbb2d5639aXfZL438d2\">显然，写下这段代码的人有着C语言的背景，因为在C语言里面，我们常常会用整数表示成功失败。我说过，这是一段C++代码，而C++里面有一种类型叫做bool。</span>\n<br id=\"zw-12cbb2d563aYu0p1k438d2\">\n<br id=\"zw-12cbb2d563asUN0yW438d2\">\n<span id=\"zw-12cbb2d563aYebCR438d2\">整数之所以能够占有本该属于布尔类型的舞台，很大程度上是受到C语言本身的限制。当然，C99之后，C程序员们终于有了属于自己的体面的布尔类型。</span>\n<br id=\"zw-12cbb2d563a7W8PIb438d2\">\n<br id=\"zw-12cbb2d563acifWE438d2\">\n<span id=\"zw-12cbb2d563aDjgKJ438d2\">只是还有为数不少的C程序员依然生活在那个蛮荒年代。于是，很多人通过各种不尽如人意的方式模拟着布尔类型。不过，我们也看到了，偏偏就有这些生在福中不知福的程序员努力的重现着旧日时光。在我的职业生涯中，我见过许多用不同语法编写的C程序。</span>\n<br id=\"zw-12cbb2d563aC2nNmY438d2\">\n<br id=\"zw-12cbb2d563a4EpVa4438d2\">\n<span id=\"zw-12cbb2d563ag5Olct438d2\">就个人学习语言经验而言，了解了基本的语法之后，如果有可能，我希望找到一本\nEffective，寻求这门语言的编程之道。很多语言都有着自己的Effective，比如《Effective \nC++》、《Effective Java》、《Effective C#》，等等。</span>\n<br id=\"zw-12cbb2d563bIpvkA438d2\">\n<br id=\"zw-12cbb2d563bk5cxoa438d2\">\n<span id=\"zw-12cbb2d563bHIvZai438d2\">不了解语言，也会给丑陋代码可乘之机。比如，下面这段C++代码；</span>\n<br id=\"zw-12cbb2d563bxq6Z438d2\">\n<span id=\"zw-12cbb2d563br52lck438d2\">&nbsp; \nvoid CommCode::notifyCRM(XString* retparam) { </span>\n<br id=\"zw-12cbb2d563b08ll-T438d2\">\n<span id=\"zw-12cbb2d563btyTMJh438d2\">&nbsp;&nbsp;&nbsp; \nif (NULL == retparam) { </span>\n<br id=\"zw-12cbb2d563b648D1J438d2\">\n<span id=\"zw-12cbb2d563coyYmQS438d2\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw \nIllegalArgumentsException(GetErrorMsg(\"</span>\n<span id=\"zw-12cbb2d563br52lck438d2\">CommCode</span>\n<span id=\"zw-12cbb2d563coyYmQS438d2\">::notifyCRM\"));</span>\n<br id=\"zw-12cbb2d563cYz8BOw438d2\">\n<span id=\"zw-12cbb2d563cBXI_Q438d2\">&nbsp;&nbsp;&nbsp; }</span>\n<br id=\"zw-12cbb2d563c-eU7H4438d2\">\n<span id=\"zw-12cbb2d563c9P3-Oy438d2\">&nbsp;&nbsp;&nbsp;\n ... </span>\n<br id=\"zw-12cbb2d563cHJG438d2\">\n<span id=\"zw-12cbb2d563c7lpXMJ438d2\">&nbsp; }</span>\n<br id=\"zw-12cbb2d563ctGV_ww438d2\">\n<br id=\"zw-12cbb2d563d8j_lTe438d2\">\n<span id=\"zw-12cbb2d563dEzAZar438d2\">如果把指针换成引用，就可以省去参数为空的判断，因为在C++里，引用不为空。这里选择了一个简单的例子，而在真实的代码里，这种检查漫天遍野，其丑陋可想而知。某些函数里面，检查甚至超过了真正的执行部分。</span>\n<br id=\"zw-12cbb2d563ddI0Y7c438d2\">\n<br id=\"zw-12cbb2d563dldr4Cx438d2\">\n<span id=\"zw-12cbb2d563distOfk438d2\">工欲善其事，必先利其器。有了铲子，就别再用手挖地了。</span>\n<br id=\"zw-12cbb2d55b7e1pT438d2\">\n</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/12/ugly-code-7\" target=\"_blank\">专栏：代码之丑（七）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201012011206",
    "date": "2010-12-01",
    "time": "12:06",
    "title": "代码之丑（二）（续二）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>一个叫夏勇杰的朋友看了《<a href=\"http://dreamhead.blogbus.com/logs/81144620.html\" target=\"_blank\">代码之丑》（二）</a>\n》\n和《<a href=\"http://dreamhead.blogbus.com/logs/81550344.html\" target=\"_blank\">续</a>\n》之后，给我写了封邮件，就原来的问题，给出了自己的解决方案，这里分享一下。<br>\n<br>\n他的思路是把所有判断条件转换成数字，然后，利用常见的位操作的技巧来处理。上代码：<br>\n&nbsp; enum Type {<br>\n&nbsp;&nbsp;&nbsp; PreDropGroupSubs&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1,<br>\n&nbsp;&nbsp;&nbsp; StopUserGroupSubsCancel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 1,<br>\n&nbsp;&nbsp;&nbsp; QFStopUserGroupSubs&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 2,<br>\n&nbsp;&nbsp;&nbsp; QFStopUserGroupSubsCancel&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 3,<br>\n&nbsp;&nbsp;&nbsp; QZStopUserGroupSubs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 4,<br>\n&nbsp;&nbsp;&nbsp; QZStopUserGroupSubsCancel&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 5,<br>\n&nbsp;&nbsp;&nbsp; SQStopUserGroupSubs&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 6,<br>\n&nbsp;&nbsp;&nbsp; SQStopUserGroupSubsCancel&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 7,<br>\n&nbsp;&nbsp;&nbsp; StopUseGroupSubs&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 8,<br>\n&nbsp;&nbsp;&nbsp; PreDropGroupSubsCancel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1 &lt;&lt; 9,&nbsp;&nbsp; <br>\n&nbsp;&nbsp;&nbsp; // ...<br>\n&nbsp; };<br>\n<br>\n&nbsp; int canExecute = PreDropGroupSubs | StopUserGroupSubsCancel <br>\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | QFStopUserGroupSubs | QFStopUserGroupSubsCancel <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | QZStopUserGroupSubs | QZStopUserGroupSubsCancel <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | SQStopUserGroupSubs | SQStopUserGroupSubsCancel <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | StopUseGroupSubs | PreDropGroupSubsCancel;<br>\n<br>\n&nbsp; bool shouldExecute(Record&amp; record) {<br>\n&nbsp;&nbsp;&nbsp; return ((rec.type &amp; canExecute) != 0);<br>\n&nbsp; }<br>\n<br>\n当然，这么做的一个前提是，需要把type的类型转换成数字。这不是太大的问题，只要在整个处理开始的部分做一次转换就可以了。从执行效率上来说，这段代码会比原来的方案高得多：一方面在于字符串比较，另一方面在于原来是循环判断。<br>\n<br>\n写《代码之丑》（二）的时候，我没想着写《续》，因为那些内容不是在讨论“丑”，而纯粹是编程技巧了。写《续》的时候，我更没想到会有《续二》。这两个续篇都是看过前面内容的朋友驱动出来的，而这就是分享的乐趣，不是吗？</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011301140",
    "date": "2010-11-30",
    "time": "11:40",
    "title": "代码之丑（六）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p id=\"zw-12c9adc32caufAkHW438d2\" style=\"margin-left: 0in; margin-bottom: 12pt; margin-top: 0pt;\"><span id=\"zw-12c9adc32caiM858k438d2\">这是一段长长的C++代码，我的问题是：relaPri、relaSec和\nscoutBySec这三个变量在哪里用到了？</span>\n<br id=\"zw-12c9adfa66fsSUTWD438d2\">\n<span id=\"zw-12c9adc32cayZqxjq438d2\">&nbsp; void DealForServiceA(const char *oprCode,\n const char *subID, const char *oID, XList *callCicsList) {</span>\n<br id=\"zw-12c9adfa670Ntj_l438d2\">\n<span id=\"zw-12c9adc32calE8scP438d2\">&nbsp;&nbsp;&nbsp; \nXString relaPri(“NULL”);</span>\n<br id=\"zw-12c9adfa670_gnqdM438d2\">\n<span id=\"zw-12c9adc32ca6sjjDN438d2\">&nbsp;&nbsp;&nbsp; XString relaSec(“NULL”);</span>\n<br id=\"zw-12c9adfa671LR21Lv438d2\">\n<span id=\"zw-12c9adc32camWUaR7438d2\">&nbsp;&nbsp;&nbsp; \nXString scoutBySec(“0”);</span>\n<br id=\"zw-12c9adfa671yOq8zx438d2\">\n<span id=\"zw-12c9adc32cb2XmqhD438d2\">&nbsp;&nbsp;&nbsp; XList *tempList = new </span>\n<span id=\"zw-12c9adfa736iEKicl438d2\">XList</span>\n<span id=\"zw-12c9adc32cb2XmqhD438d2\">;</span>\n<br id=\"zw-12c9adfa672uQ4Hu0438d2\">\n<span id=\"zw-12c9adc32cbvglqDQ438d2\">&nbsp;&nbsp;&nbsp; \ncallCicsList-&gt;Add(tempList);</span>\n<br id=\"zw-12c9adfa673lsOzkC438d2\">\n<span id=\"zw-12c9adc32cbu8FEEf438d2\">&nbsp;&nbsp;&nbsp; tempList-&gt;Add(new \nXString(oprCode));</span>\n<br id=\"zw-12c9adfa673ML6E2L438d2\">\n<span id=\"zw-12c9adc32cbGc6kt438d2\">&nbsp;&nbsp;&nbsp; tempList-&gt;Add(new XString(oID));</span>\n<br id=\"zw-12c9adfa673iE8QGB438d2\">\n<span id=\"zw-12c9adc32cb66_AXd438d2\">&nbsp;&nbsp;&nbsp;\n XString *psTelNum = new XString;</span>\n<br id=\"zw-12c9adfa674sibap438d2\">\n<span id=\"zw-12c9adc32cbmen1Ct438d2\">&nbsp;&nbsp;&nbsp; \ntempList-&gt;Add(psTelNum);</span>\n<br id=\"zw-12c9adfa67465B1-7438d2\">\n<span id=\"zw-12c9adc32cbLnhqOB438d2\">&nbsp;&nbsp;&nbsp; GetServnumberBySubsID(subID, \n*psTelNum);&nbsp;&nbsp;&nbsp; </span>\n<br id=\"zw-12c9adfa674VH3FmK438d2\">\n<span id=\"zw-12c9adc32ccN3a610438d2\">&nbsp;&nbsp;&nbsp; tempList-&gt;Add(new XString(relaPri.table { font-size: 10pt;}c_str()));</span>\n<br id=\"zw-12c9adfa675vAuA7438d2\">\n<span id=\"zw-12c9adc32ccQRHpcH438d2\">&nbsp;&nbsp;&nbsp; \ntempList-&gt;Add(new XString(relaSec.c_str()));</span>\n<br id=\"zw-12c9adfa6753IEggi438d2\">\n<span id=\"zw-12c9adc32ccowZ5cK438d2\">&nbsp;&nbsp;&nbsp; \ntempList-&gt;Add(new XString(scoutBySec.c_str()));</span>\n<br id=\"zw-12c9adfa676gMP3f438d2\">\n<span id=\"zw-12c9adc32ccrszYFz438d2\">&nbsp; }</span>\n<br id=\"zw-12c9adfa676yW_Yw8438d2\">\n<br id=\"zw-12c9adfa676QQlzo438d2\">\n<span id=\"zw-12c9adc32ccKMK053438d2\">经过认真仔细的查看，或是使用传说的中“查找”功能，我们发现上面提到的那三个变量只在最后用了一下。</span>\n<br id=\"zw-12c9adfa677hwM-ii438d2\">\n<br id=\"zw-12c9adfa677gSO20q438d2\">\n<span id=\"zw-12c9adc32ccD0XXVm438d2\">不知道你是否注意到，我在最初特意强调了一下这是C++代码。这意味着，变量可以随用随声明，而不必像传统的C程序那样，只能在函数的开头把函数内部用到的变量一口气声明。</span>\n<span id=\"zw-12c9ae02ffbiUslY7438d2\">那么</span>\n<span id=\"zw-12c9adc32ccOgYers438d2\">，我们就让声明和使用团聚吧！</span>\n<br id=\"zw-12c9adfa678iM58Nv438d2\">\n<br id=\"zw-12c9adfa678Ge9Az438d2\">\n<span id=\"zw-12c9adc32ccl8rwxn438d2\">&nbsp;&nbsp;&nbsp; XString relaPri(“NULL”);</span>\n<br id=\"zw-12c9adfa678fEtUW438d2\">\n<span id=\"zw-12c9adc32cc1XSEey438d2\">&nbsp;&nbsp;&nbsp; \ntempList-&gt;Add(new XString(relaPri.c_str()));</span>\n<br id=\"zw-12c9adfa679sDOpdu438d2\">\n<span id=\"zw-12c9adc32ccINjI438d2\">&nbsp;&nbsp;&nbsp; \nXString relaSec(“NULL”);</span>\n<br id=\"zw-12c9adfa679MdnWJj438d2\">\n<span id=\"zw-12c9adc32ccoTmuvl438d2\">&nbsp;&nbsp;&nbsp; tempList-&gt;Add(new XString(relaSec.c_str()));</span>\n<br id=\"zw-12c9adfa679ic4tk438d2\">\n<span id=\"zw-12c9adc32cdBNnszU438d2\">&nbsp;&nbsp;&nbsp; \nXString scoutBySec(“0”);</span>\n<br id=\"zw-12c9adfa67ao0tjiO438d2\">\n<span id=\"zw-12c9adc32cdv2SwOD438d2\">&nbsp;&nbsp;&nbsp; tempList-&gt;Add(new \nXString(scoutBySec.c_str()));</span>\n<br id=\"zw-12c9adfa67aA083H9438d2\">\n<br id=\"zw-12c9adfa67apWCVX438d2\">\n<span id=\"zw-12c9adc32cdVZr6LP438d2\">当声明和使用走到一起，我们的观察就有了新的视角，其实，这几个变量完全是可以不声明的，于是，代码再进一步：</span>\n<br id=\"zw-12c9adfa67bcgdk_X438d2\">\n<span id=\"zw-12c9adc32cdMz8awe438d2\">&nbsp;&nbsp;&nbsp; \ntempList-&gt;Add(new XString(“NULL”));</span>\n<br id=\"zw-12c9adfa67bW-cik8438d2\">\n<span id=\"zw-12c9adc32cdKGt9438d2\">&nbsp;&nbsp;&nbsp; \ntempList-&gt;Add(new XString(“NULL”));</span>\n<br id=\"zw-12c9adfa67biPndSt438d2\">\n<span id=\"zw-12c9adc32cd8VWw_q438d2\">&nbsp;&nbsp;&nbsp; \ntempList-&gt;Add(new XString(“0”));</span>\n<br id=\"zw-12c9adfa67crurvu438d2\">\n<br id=\"zw-12c9adfa67cgz7h0Z438d2\">\n<span id=\"zw-12c9adc32cdPk9Xiv438d2\">看到这里，我们就可以看出原来的做法到底有多么浪费：浪费时间给变量起名字——我们都知道，起个好名字不容易，也浪费了时间在执行上，修改前的代码创建了两个XString对象，而修改后，只创建了一个对象。</span>\n<span id=\"zw-12c9adc32cd2xQu7m438d2\"> </span>\n<br id=\"zw-12c9adfa67caAjNz438d2\">\n<br id=\"zw-12c9adfa67dwIVYGr438d2\">\n<span id=\"zw-12c9adc32cdjc4cb438d2\">或许，你会觉得，有个变量会让我们了解这里实际上填加的内容到底是什么。不过，也许一个好的函数命名才是更好的选择，比如addRelaPri。这个疑问会揭示出这段代码存在另外一个问题，直接使用基本的数据结构而没有进行封装。不过，这不是这里讨论的目标，就到此打住吧！</span>\n<br id=\"zw-12c9adfa67ddsNgZl438d2\">\n<br id=\"zw-12c9adfa67dHl9prN438d2\">\n<span id=\"zw-12c9adc32cd_IH6zD438d2\">根据这段代码的调整，我们得出一条规则：</span>\n<br id=\"zw-12c9adfa67dvRjAM6438d2\">\n</p>\n<ul>\n<li><span id=\"zw-12c9adc32cecD2cK438d2\">代码的声明和使用应尽量接近。</span>\n</li>\n</ul>\n<p id=\"zw-12c9adc32caufAkHW438d2\" style=\"margin-left: 0in; margin-bottom: 12pt; margin-top: 0pt;\"><span id=\"zw-12c9adc32cefqVSPW438d2\">有的C程序员会暗自念叨，这个要求对C程序来说，简直太不合情理了。好吧！我承认，从语言的角度来说，是这样的。但是，我们需要仔细想想，为什么对于C语言来说，变量的声明和使用会距离遥远。通常，遥远的背后意味着硕大的函数，这才是让声明和使用天各一方的重要原因。</span>\n<br id=\"zw-12c9adfa67e54Jcj7438d2\">\n<br id=\"zw-12c9adfa67f-LPLmI438d2\">\n<span id=\"zw-12c9adc32cePed93A438d2\">在干净代码的世界里，大函数永远是不受欢迎的。为了让声明和使用尽早团聚，请把函数写小。</span>\n</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-6\" target=\"_blank\">专栏：代码之丑（六）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011120930",
    "date": "2010-11-12",
    "time": "09:30",
    "title": "代码之丑（五）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>不知道为什么，初见它时，我想起了郭芙蓉的排山倒海：<br>\n&nbsp; ColdRule *newRule = new ColdRule();<br>\n&nbsp; newRule-&gt;SetOID(oldRule-&gt;GetOID());<br>\n&nbsp; newRule-&gt;SetRegion(oldRule-&gt;GetRegion());<br>\n&nbsp; newRule-&gt;SetRebateRuleID(oldRule-&gt;GetRebateRuleID());<br>\n&nbsp; newRule-&gt;SetBeginCycle(oldRule-&gt;GetBeginCycle() + 1);<br>\n&nbsp; newRule-&gt;SetEndCycle(oldRule-&gt;GetEndCycle());<br>\n&nbsp; newRule-&gt;SetMainAcctAmount(oldRule-&gt;GetMainAcctAmount());<br>\n&nbsp; newRule-&gt;SetGiftAcctAmount(oldRule-&gt;GetGiftAcctAmount());<br>\n&nbsp; newRule-&gt;SetValidDays(0);<br>\n&nbsp; newRule-&gt;SetGiftAcct(oldRule-&gt;GetGiftAcct());<br>\n&nbsp; rules-&gt;Add(newRule);<br>\n<br>\n就在我以为这一片代码就是完成给一个变量设值的时候，突然，在那个不起眼的角落里，这个变量得到了应用：它被加到了rules里面。什么叫峰回路转，这就是。<br>\n<br>\n既然它给了我们这么有趣的体验，必然先杀后快。下面重构了这个函数：<br>\n&nbsp; ColdRule* CreateNewRule(ColdRule&amp; oldRule) {<br>\n&nbsp;&nbsp;&nbsp; ColdRule *newRule = new ColdRule();<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetOID(oldRule.GetOID());<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetRegion(oldRule.GetRegion());<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetRebateRuleID(oldRule.GetRebateRuleID());<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetBeginCycle(oldRule.GetBeginCycle() + 1);<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetEndCycle(oldRule.GetEndCycle());<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetMainAcctAmount(oldRule.GetMainAcctAmount());<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetGiftAcctAmount(oldRule.GetGiftAcctAmount());<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetValidDays(0);<br>\n&nbsp;&nbsp;&nbsp; newRule-&gt;SetGiftAcct(oldRule.GetGiftAcct());<br>\n&nbsp;&nbsp;&nbsp; return newRule<br>\n&nbsp; }<br>\n<br>\n&nbsp; rules-&gt;Add(CreateNewRule(*oldRule));<br>\n<br>\n把这一堆设值操作提取了出来，整个函数看上去一下子就清爽了。不是因为代码变少了，而是因为代码按照它职责进行了划分：创建的归创建，加入的归加入。之前的代码之所以让我不安，多重职责是罪魁祸首。<br>\n<br>\n谈论干净代码时，我们总会说，函数应该只做一件事。函数做的事越多，就会越冗长。也就越难发现不同函数内存在的相似之处。为了一个问题，要在不同的地方改来改去也就难以避免了。<br>\n<br>\n即便大家都认同了函数应该只做一件事，但多大的一件事算是一件事呢！不同的人心里有不同的标准。有人甚至认为一个功能就是一件事。于是，代码会越来越刺激。</p>\n<p>想写干净代码，就别怕事小。哪怕一个函数只有一行，只要它能完整的表达一件事。在干净代码的世界里，大心脏是不受喜欢的。<br>\n<br>\n接下来，我需要用历经沧桑的口吻告诉你，这么跌宕起伏的代码也只不过是一个更大函数的一个部分。此刻，浮现在我脑海里的是层峦叠嶂的山峰。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-5\" target=\"_blank\">专栏：代码之丑（五）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011072129",
    "date": "2010-11-07",
    "time": "21:29",
    "title": "代码之丑（四）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>这是一个找茬的游戏，下面三段代码的差别在哪：<br>\n&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(i, NewCatalog);<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Add(NewCatalog);<br>\n&nbsp; }<br>\n<br>\n&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(m, NewCatalog);<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Add(NewCatalog);<br>\n&nbsp; }<br>\n<br>\n&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(j, NewPrivNode);<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Add(NewPrivNode);<br>\n&nbsp; }<br>\n<br>\n答案时间：除了用到变量之外，完全相同。我想说的是，这是我从一个文件的一次diff中看到的。<br>\n<br>\n不妨设想一下修改这些代码时的情形：费尽九牛二虎之力，我终于找到该在哪改动代码，改了。作为一个有职业操守的程序员，我知道别的地方也需要类似的修改。于是，趁人不备，把刚做修改拷贝了一份，放到另外需要修改的地方。修改了几个变量，编译通过了。世界应该就此清净，至少问题解决了。<br>\n<br>\n好吧！虽然这个程序员有职业操守的程序员，却缺少了些职业技能，至少在挥舞“拷贝粘贴”时，他没有嗅到散发出的臭味。<br>\n<br>\n只要意识到坏味道，修改是件很容易的事，提出一个新函数即可：<br>\n&nbsp; void AddNode(List&amp; RetList, int SignRunToInsert, int Pos, Node&amp; Node) {<br>\n&nbsp;&nbsp;&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(Pos, Node);<br>\n&nbsp;&nbsp;&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RetList-&gt;Add(Node);<br>\n&nbsp;&nbsp;&nbsp; }<br>\n&nbsp; }<br>\n<br>\n于是，原来那三段代码变成了三个调用：<br>\n&nbsp; AddNode(RetList, SignRunToInsert, i, NewCatalog);<br>\n&nbsp; AddNode(RetList, SignRunToInsert, m, NewCatalog);<br>\n&nbsp; AddNode(RetList, SignRunToInsert, j, NewPrivNode);<br>\n<br>\n当然，这种修改只是一个局部的微调，如果有更多的上下文信息，我们可以做得更好。<br>\n<br>\n重复，是最为常见的坏味道。上面这种重复实际上是非常容易发现的，也是很容易修改。但所有这一切的前提是，发现坏味道。<br>\n<br>\n长时间生活在这种代码里面，我们会对坏味道失去嗅觉。更可怕的是，一个初来乍到的嗅觉尚灵敏的人意识到这个问题，那些失去嗅觉的人却告诫他，别乱动，这挺好。<br>\n<br>\n趁嗅觉尚在，请坚持代码正义。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-4\" target=\"_blank\">专栏：代码之丑（四）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011072129",
    "date": "2010-11-07",
    "time": "21:29",
    "title": "代码之丑（四）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>这是一个找茬的游戏，下面三段代码的差别在哪：<br>\n&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(i, NewCatalog);<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Add(NewCatalog);<br>\n&nbsp; }<br>\n<br>\n&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(m, NewCatalog);<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Add(NewCatalog);<br>\n&nbsp; }<br>\n<br>\n&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(j, NewPrivNode);<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; RetList-&gt;Add(NewPrivNode);<br>\n&nbsp; }<br>\n<br>\n答案时间：除了用到变量之外，完全相同。我想说的是，这是我从一个文件的一次diff中看到的。<br>\n<br>\n不妨设想一下修改这些代码时的情形：费尽九牛二虎之力，我终于找到该在哪改动代码，改了。作为一个有职业操守的程序员，我知道别的地方也需要类似的修改。于是，趁人不备，把刚做修改拷贝了一份，放到另外需要修改的地方。修改了几个变量，编译通过了。世界应该就此清净，至少问题解决了。<br>\n<br>\n好吧！虽然这个程序员有职业操守的程序员，却缺少了些职业技能，至少在挥舞“拷贝粘贴”时，他没有嗅到散发出的臭味。<br>\n<br>\n只要意识到坏味道，修改是件很容易的事，提出一个新函数即可：<br>\n&nbsp; void AddNode(List&amp; RetList, int SignRunToInsert, int Pos, Node&amp; Node) {<br>\n&nbsp;&nbsp;&nbsp; if ( 1 == SignRunToInsert)&nbsp;&nbsp;&nbsp; {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RetList-&gt;Insert(Pos, Node);<br>\n&nbsp;&nbsp;&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RetList-&gt;Add(Node);<br>\n&nbsp;&nbsp;&nbsp; }<br>\n&nbsp; }<br>\n<br>\n于是，原来那三段代码变成了三个调用：<br>\n&nbsp; AddNode(RetList, SignRunToInsert, i, NewCatalog);<br>\n&nbsp; AddNode(RetList, SignRunToInsert, m, NewCatalog);<br>\n&nbsp; AddNode(RetList, SignRunToInsert, j, NewPrivNode);<br>\n<br>\n当然，这种修改只是一个局部的微调，如果有更多的上下文信息，我们可以做得更好。<br>\n<br>\n重复，是最为常见的坏味道。上面这种重复实际上是非常容易发现的，也是很容易修改。但所有这一切的前提是，发现坏味道。<br>\n<br>\n长时间生活在这种代码里面，我们会对坏味道失去嗅觉。更可怕的是，一个初来乍到的嗅觉尚灵敏的人意识到这个问题，那些失去嗅觉的人却告诫他，别乱动，这挺好。<br>\n<br>\n趁嗅觉尚在，请坚持代码正义。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-4\" target=\"_blank\">专栏：代码之丑（四）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011052207",
    "date": "2010-11-05",
    "time": "22:07",
    "title": "欢迎参加Agile Tour西安站",
    "tags": [
      "敏捷",
      "AgileTour"
    ],
    "body": "<p><a href=\"http://agiletourchina.agilewizard.org/xian/\" target=\"_blank\">Agile Tour西安站<br>\n</a>\n<a href=\"http://agiletour.org/cn/agilechina_registration.html\" target=\"_blank\">在线注册</a>\n<br>\n<br>\n很多人都知道了，ThoughtWorks回到了西安，它在中国起步的地方。<br>\n<br>\n对于社区活动，ThoughtWorks一向是大力支持的。所以，才有<a href=\"http://www.beijing-open-party.org/\" target=\"_blank\">OpenParty</a>\n在北京办公室长期的举办。离开西安之前，我们也曾经举办过敏捷西安这样的活动。重新回到西安，重建社区是很多ThoughtWorker共同的想法。<br>\n<br>\n为了建设西安的社区，我们和很多朋友在一些邮件里进行了很多的讨论，现在缺乏的就是一个导火索，让更多的人彼此相识。现在机会来了，Agile Tour西安站给了西安的软件开发人员一个近距离交流的机会。<br>\n<br>\n作为对这次社区活动的支持，我准备贡献一个《<a href=\"http://dreamhead.blogbus.com/tag/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/\" target=\"_blank\">代码之丑</a>\n》的session。如果你是我blog的读者，在<a href=\"http://dreamhead.blogbus.com/logs/80223223.html\" target=\"_blank\">《代码之丑》（零）</a>\n里面我说过，这个系列来自我给客户讲的一些东西。我会基于那份材料，进一步打磨一下，和大家一起回归一下软件开发的技术本源，与大家分享我在长期漂泊的咨询生涯中的一些感悟。<br>\n<br>\nAgile Tour对于西安的社区来说，不是一个终点，而是一个起点。这次活动之后，会有更多的活动，西安也会有属于自己的OpenParty。在那里，你可以大开眼界，也可以分享心得，可以认识牛人，也可以结交朋友。<br>\n<br>\n如果你在西安工作，或是碰巧11月20日就在西安，欢迎你来参加Agile Tour西安站的活动。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011052207",
    "date": "2010-11-05",
    "time": "22:07",
    "title": "欢迎参加Agile Tour西安站",
    "tags": [
      "敏捷",
      "AgileTour"
    ],
    "body": "<p><a href=\"http://agiletourchina.agilewizard.org/xian/\" target=\"_blank\">Agile Tour西安站<br>\n</a>\n<a href=\"http://agiletour.org/cn/agilechina_registration.html\" target=\"_blank\">在线注册</a>\n<br>\n<br>\n很多人都知道了，ThoughtWorks回到了西安，它在中国起步的地方。<br>\n<br>\n对于社区活动，ThoughtWorks一向是大力支持的。所以，才有<a href=\"http://www.beijing-open-party.org/\" target=\"_blank\">OpenParty</a>\n在北京办公室长期的举办。离开西安之前，我们也曾经举办过敏捷西安这样的活动。重新回到西安，重建社区是很多ThoughtWorker共同的想法。<br>\n<br>\n为了建设西安的社区，我们和很多朋友在一些邮件里进行了很多的讨论，现在缺乏的就是一个导火索，让更多的人彼此相识。现在机会来了，Agile Tour西安站给了西安的软件开发人员一个近距离交流的机会。<br>\n<br>\n作为对这次社区活动的支持，我准备贡献一个《<a href=\"http://dreamhead.blogbus.com/tag/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91/\" target=\"_blank\">代码之丑</a>\n》的session。如果你是我blog的读者，在<a href=\"http://dreamhead.blogbus.com/logs/80223223.html\" target=\"_blank\">《代码之丑》（零）</a>\n里面我说过，这个系列来自我给客户讲的一些东西。我会基于那份材料，进一步打磨一下，和大家一起回归一下软件开发的技术本源，与大家分享我在长期漂泊的咨询生涯中的一些感悟。<br>\n<br>\nAgile Tour对于西安的社区来说，不是一个终点，而是一个起点。这次活动之后，会有更多的活动，西安也会有属于自己的OpenParty。在那里，你可以大开眼界，也可以分享心得，可以认识牛人，也可以结交朋友。<br>\n<br>\n如果你在西安工作，或是碰巧11月20日就在西安，欢迎你来参加Agile Tour西安站的活动。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011042252",
    "date": "2010-11-04",
    "time": "22:52",
    "title": "代码之丑（三）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>又见switch：<br>\n&nbsp; switch(firstChar) {<br>\n&nbsp; case ‘N’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘O’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘O’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘P’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘P’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘Q’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘Q’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘R’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘R’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘S’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘S’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘T’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘T’:<br>\n&nbsp;&nbsp;&nbsp; throw Ebusiness();<br>\n&nbsp; default:<br>\n&nbsp; }<br>\n<br>\n出于多年编程养成的条件反射，我对于switch总会给予更多的关照。研习面向对象编程之后，看见switch就会想到多态，遗憾的是，这段代码和多态没什么关系。仔细阅读这段代码，我找出了其中的规律，nextFirstChar就是firstChar的下一个字符。于是，我改写了这段代码：<br>\n&nbsp; switch(firstChar) {<br>\n&nbsp; case ‘N’:<br>\n&nbsp; case ‘O’:<br>\n&nbsp; case ‘P’:<br>\n&nbsp; case ‘Q’:<br>\n&nbsp; case ‘R’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = firstChar + 1;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘T’:<br>\n&nbsp;&nbsp;&nbsp; throw Ebusiness();<br>\n&nbsp; default:<br>\n&nbsp; }<br>\n<br>\n现在，至少看起来，这段代码已经比原来短了不少。当然这么做基于一个前提，也就是这些字母编码的顺序确确实实连续的。从理论上说，开始那段代码适用性更强。但在实际开发中，我们碰到字母不连续编码的概率趋近于0。<br>\n<br>\n但这段代码究竟是如何产生的呢？我开始研读上下文，原来这段代码是用当前ID产生下一个ID的，比如当前是N0000，下一个就是N0001。如果数字满了，就改变字母，比如当前ID是R9999，下一个就是T0000。在这里，字母也就相当于一位数字，根据情况进行进位，所以有了这段代码。<br>\n<br>\n代码上的注释告诉我，字母的序列只有从N到T，根据这个提示，我再次改写了这段代码：<br>\n&nbsp; if (firstChar &gt;= ‘N’ &amp;&amp; firstChar &lt;= ‘S”) {<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = firstChar + 1;<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; throw Ebusiness();<br>\n&nbsp; }<br>\n<br>\n这里统一处理了字母为T和default的情形，严格说来，这和原有代码并不完全等价。但这是了解了需求后做出的决定，换句话说，原有代码在这里的处理中存在漏洞。</p>\n<p>修改这段代码，只是运用了非常简单的编程技巧。遗憾的是，即便如此简单的编程技巧，也不是所有开发人员都驾轻就熟的，很多人更习惯于“平铺直叙”。这种直白造就了代码中的许多鸿篇巨制。我听过不少“编程是体力活”的抱怨，不过，能把写程序干成体力活，也着实不值得同情。写程序，不动脑子，不体力才怪。</p>\n<p>无论何时何地，只要switch出现在眼前，请提高警惕，那里多半有坑。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-3\" target=\"_blank\">专栏：代码之丑（三）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201011042252",
    "date": "2010-11-04",
    "time": "22:52",
    "title": "代码之丑（三）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>又见switch：<br>\n&nbsp; switch(firstChar) {<br>\n&nbsp; case ‘N’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘O’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘O’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘P’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘P’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘Q’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘Q’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘R’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘R’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘S’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘S’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = ‘T’;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘T’:<br>\n&nbsp;&nbsp;&nbsp; throw Ebusiness();<br>\n&nbsp; default:<br>\n&nbsp; }<br>\n<br>\n出于多年编程养成的条件反射，我对于switch总会给予更多的关照。研习面向对象编程之后，看见switch就会想到多态，遗憾的是，这段代码和多态没什么关系。仔细阅读这段代码，我找出了其中的规律，nextFirstChar就是firstChar的下一个字符。于是，我改写了这段代码：<br>\n&nbsp; switch(firstChar) {<br>\n&nbsp; case ‘N’:<br>\n&nbsp; case ‘O’:<br>\n&nbsp; case ‘P’:<br>\n&nbsp; case ‘Q’:<br>\n&nbsp; case ‘R’:<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = firstChar + 1;<br>\n&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp; case ‘T’:<br>\n&nbsp;&nbsp;&nbsp; throw Ebusiness();<br>\n&nbsp; default:<br>\n&nbsp; }<br>\n<br>\n现在，至少看起来，这段代码已经比原来短了不少。当然这么做基于一个前提，也就是这些字母编码的顺序确确实实连续的。从理论上说，开始那段代码适用性更强。但在实际开发中，我们碰到字母不连续编码的概率趋近于0。<br>\n<br>\n但这段代码究竟是如何产生的呢？我开始研读上下文，原来这段代码是用当前ID产生下一个ID的，比如当前是N0000，下一个就是N0001。如果数字满了，就改变字母，比如当前ID是R9999，下一个就是T0000。在这里，字母也就相当于一位数字，根据情况进行进位，所以有了这段代码。<br>\n<br>\n代码上的注释告诉我，字母的序列只有从N到T，根据这个提示，我再次改写了这段代码：<br>\n&nbsp; if (firstChar &gt;= ‘N’ &amp;&amp; firstChar &lt;= ‘S”) {<br>\n&nbsp;&nbsp;&nbsp; nextFirstChar = firstChar + 1;<br>\n&nbsp; } else {<br>\n&nbsp;&nbsp;&nbsp; throw Ebusiness();<br>\n&nbsp; }<br>\n<br>\n这里统一处理了字母为T和default的情形，严格说来，这和原有代码并不完全等价。但这是了解了需求后做出的决定，换句话说，原有代码在这里的处理中存在漏洞。</p>\n<p>修改这段代码，只是运用了非常简单的编程技巧。遗憾的是，即便如此简单的编程技巧，也不是所有开发人员都驾轻就熟的，很多人更习惯于“平铺直叙”。这种直白造就了代码中的许多鸿篇巨制。我听过不少“编程是体力活”的抱怨，不过，能把写程序干成体力活，也着实不值得同情。写程序，不动脑子，不体力才怪。</p>\n<p>无论何时何地，只要switch出现在眼前，请提高警惕，那里多半有坑。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-3\" target=\"_blank\">专栏：代码之丑（三）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201010312123",
    "date": "2010-10-31",
    "time": "21:23",
    "title": "代码之丑（二）（续）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>sinojelly在《<a href=\"http://dreamhead.blogbus.com/logs/81144620.html\" target=\"_blank\">代码之丑（二）</a>\n》的评论里问了个问题，“把这个type列表变成声明式”，什么样的声明式？<br>\n<br>\n好吧！我承认，我偷懒了，为了省事，一笔带过了。简单理解声明式的风格，就是把描述做什么，而不是怎么做。一个声明式编程的例子是Rails里面的数据关联，为人熟知的has_many和belongs_to。通过声明，模型类就会具备一些数据关联的能力。<br>\n<br>\n具体到实际开发里，声明式编程需要有两个部分：一方面是一些基础的框架性代码，另一方面是应用层面如何使用。框架代码通常来说，都不像应用层面代码那么好理解，但有了这个基础，应用代码就会变得简单许多。<br>\n<br>\n针对之前的那段代码，按照声明性编程风格，我改造了代码，下面是框架部分的代码：<br>\n<br>\n#define BEGIN_STR_PREDICATE(predicate_name) \\<br>\nbool predicate_name(const char* field) { \\<br>\n&nbsp; static const char* predicate_true_fields[] = {<br>\n&nbsp;&nbsp;&nbsp; <br>\n#define STR_PREDICATE_ITEM(item) #item ,<br>\n<br>\n#define END_STR_PREDICATE \\<br>\n&nbsp; };\\<br>\n&nbsp; \\<br>\n&nbsp; int size = ARRAY_SIZE(predicate_true_fields);\\<br>\n&nbsp; for (int i = 0; i &lt; size; i++) { \\<br>\n&nbsp;&nbsp;&nbsp; if (strcmp(field, predicate_true_fields[i]) == 0) {\\<br>\n&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return true;\\<br>\n&nbsp;&nbsp;&nbsp; }\\<br>\n&nbsp; }\\<br>\n\\<br>\n&nbsp; return false;\\<br>\n}<br>\n<br>\n这里用到了C/C++常见的宏技巧，为的就是让应用层面的代码写起来更像声明。对比一下之前的函数，就会发现，实际上二者几乎是一样的。有了框架，就该应用了：<br>\n<br>\nBEGIN_STR_PREDICATE(shouldExecute)<br>\n&nbsp; STR_PREDICATE_ITEM(PreDropGroupSubs)<br>\n&nbsp; STR_PREDICATE_ITEM(StopUserGroupSubsCancel)<br>\n&nbsp; STR_PREDICATE_ITEM(QFStopUserGroupSubs)<br>\n&nbsp; STR_PREDICATE_ITEM(QFStopUserGroupSubsCancel)<br>\n&nbsp; STR_PREDICATE_ITEM(QZStopUserGroupSubs)<br>\n&nbsp; STR_PREDICATE_ITEM(QZStopUserGroupSubsCancel)<br>\n&nbsp; STR_PREDICATE_ITEM(SQStopUserGroupSubs)<br>\n&nbsp; STR_PREDICATE_ITEM(SQStopUserGroupSubsCancel)<br>\n&nbsp; STR_PREDICATE_ITEM(StopUseGroupSubs)<br>\n&nbsp; STR_PREDICATE_ITEM(SQStopUserGroupSubsCancel)<br>\n&nbsp; STR_PREDICATE_ITEM(StopUseGroupSubs)<br>\n&nbsp; STR_PREDICATE_ITEM(PreDropGroupSubsCancel)<br>\nEND_STR_PREDICATE<br>\n<br>\nshouldExecute就此重现出来了。不过，这段代码已经不再像一个函数，而更像一段声明，这就是我们的目标。有了这个基础，实现一个新的函数，不过是做一段新的声明而已。</p>\n<p>接下来就是如何使用了，与之前略有差异的是，这里为了更好的通用性，把字符串作为参数传了进去，而不是原来的整个类对象。<br>\n&nbsp; shouldExecute(r.type);<br>\n<br>\n虽然应用代码变得简单了，但写出框架的结构是需要一定基础的。它不像应用代码那样来得平铺直叙，但其实也没那么难，只不过很多人从没有考虑把代码写成这样。只要换个角度去思考，多多练习，也就可以驾轻就熟了。</p>\n<p>&nbsp;</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-2\" target=\"_blank\">专栏：代码之丑（二）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201010281730",
    "date": "2010-10-28",
    "time": "17:30",
    "title": "代码之丑（二）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>这是一个长长的判断条件：<br>\n&nbsp; if ( strcmp(rec.type, \"PreDropGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"StopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QFStopUserGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QFStopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QZStopUserGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QZStopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"SQStopUserGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"SQStopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"StopUseGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"PreDropGroupSubsCancel\") == 0)<br>\n<br>\n之所以注意到它，因为最后两个条件是最新修改里面加入的，换句话说，这不是一次写就的代码。单就这一次而言，只改了两行，这是可以接受的。但这是遗留代码。每次可能只改了一两行，通常我们会不只一次踏入这片土地。经年累月，代码成了这个样子。<br>\n<br>\n这并非我接触过的最长的判断条件，这种代码极大的开拓了我的视野。现在的我，即便面对的是一屏无法容纳的条件，也可以坦然面对了，虽然显示器越来越大。<br>\n<br>\n其实，如果这个判断条件是这个函数里仅有的东西，我也就忍了。遗憾的是，大多数情况下，这只不过是一个更大函数中的一小段而已。<br>\n<br>\n为了让这段代码可以接受一些，我们不妨稍做封装：<br>\n&nbsp; bool shouldExecute(Record&amp; rec) {<br>\n&nbsp;&nbsp;&nbsp; return (strcmp(rec.type, \"PreDropGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"StopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QFStopUserGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QFStopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QZStopUserGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"QZStopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"SQStopUserGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"SQStopUserGroupSubsCancel\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"StopUseGroupSubs\") == 0<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || strcmp(rec.type, \"PreDropGroupSubsCancel\") == 0);<br>\n&nbsp; }<br>\n<br>\n&nbsp; if (shouldExecute(rec)) {<br>\n&nbsp;&nbsp;&nbsp; ...<br>\n&nbsp; }<br>\n<br>\n现在，虽然条件依然还是很多，但和原来庞大的函数相比，至少它已经被控制在一个相对较小的函数里了。更重要的是，通过函数名，我们终于有机会说出这段代码判断的是什么了。<br>\n<br>\n提取函数把这段代码混乱的条件分离开来，它还是可以继续改进的。比如，我们把判断的条件进一步提取：<br>\nbool shouldExecute(Record&amp; rec) {<br>\n&nbsp; static const char* execute_type[] = {<br>\n&nbsp;&nbsp;&nbsp; \"PreDropGroupSubs\",<br>\n&nbsp;&nbsp;&nbsp; \"StopUserGroupSubsCancel\",<br>\n&nbsp;&nbsp;&nbsp; \"QFStopUserGroupSubs\",<br>\n&nbsp;&nbsp;&nbsp; \"QFStopUserGroupSubsCancel\",<br>\n&nbsp;&nbsp;&nbsp; \"QZStopUserGroupSubs\",<br>\n&nbsp;&nbsp;&nbsp; \"QZStopUserGroupSubsCancel\",<br>\n&nbsp;&nbsp;&nbsp; \"SQStopUserGroupSubs\",<br>\n&nbsp;&nbsp;&nbsp; \"SQStopUserGroupSubsCancel\",<br>\n&nbsp;&nbsp;&nbsp; \"StopUseGroupSubs\",<br>\n&nbsp;&nbsp;&nbsp; \"PreDropGroupSubsCancel\"<br>\n&nbsp; };<br>\n<br>\n&nbsp; int size = ARRAY_SIZE(execute_type);<br>\n&nbsp; for (int i = 0; i &lt; size; i++) {<br>\n&nbsp;&nbsp;&nbsp; if (strcmp(rec.type, execute_type[i]) == 0) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n&nbsp; }<br>\n<br>\n&nbsp; return false;<br>\n}<br>\n<br>\n这样的话，再加一个新的type，只要在数组中增加一个新的元素即可。如果我们有兴趣的话，还可以进一步对这段代码进行封装，把这个type列表变成声明式，进一步提高代码的可读性。<br>\n<br>\n发现这种代码很容易，只要看到在长长的判断条件，就是它了。要限制这种代码的存在，我们只要以设定一个简单的规则：</p>\n<ul>\n<li>判断条件里面不允许多个条件的组合</li>\n</ul>\n<p>在实际的应用中，我们会把“3”定义为“多”，也就是如果有两个条件的组合，可以接受，如果是三个，还是改吧！<br>\n<br>\n虽然通过不断调整，这段代码已经不同于之前，但它依然不是我们心目中的理想代码。出现这种代码，往往意味背后有更严重的设计问题。不过，它并不是这里讨论的内容，这里的讨论就到此为止吧！</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-2\" target=\"_blank\">专栏：代码之丑（二）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201010242111",
    "date": "2010-10-24",
    "time": "21:11",
    "title": "代码之丑（一）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>诸位看官，上代码：<br>\n\n&nbsp; if (0 == iRetCode) {<br>\n\n&nbsp;&nbsp;&nbsp; this-&gt;SendPeerMsg(\"000\", \"Process Success\", outRSet);<br>\n\n&nbsp; } else {<br>\n\n&nbsp;&nbsp;&nbsp; this-&gt;SendPeerMsg(\"000\", \"Process Failure\", outRSet);<br>\n\n&nbsp; }<br>\n\n<br>\n\n乍一看，这段代码还算比较简短。那下面这段呢？<br>\n\n&nbsp; if(!strcmp(pRec-&gt;GetRecType(), PUB_RECTYPE::G_INSTALL)) {<br>\n\n&nbsp;&nbsp;&nbsp; CommDM.jkjtVPDNResOperChangGroupInfo(<br>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_cast(CommDM.GetProdAttrVal(\"vpdnIPAddress\", <br>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;(pGroupSubs-&gt;m_ProdAttr))), <br>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true);<br>\n\n&nbsp; } else {<br>\n\n&nbsp;&nbsp;&nbsp; CommDM.jkjtVPDNResOperChangGroupInfo(<br>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const_cast(CommDM.GetProdAttrVal(\"vpdnIPAddress\", <br>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;(pGroupSubs-&gt;m_ProdAttr))), <br>\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false);<br>\n\n&nbsp; }<br>\n\n<br>\n\n看出来问题了吗？经过仔细的对比，我们发现，对于如此华丽的代码，if/else的执行语句真正的差异只在于一个参数。第一段代码，二者的差异只是发送的消息，第二段代码，差异在于最后那个参数。<br>\n\n<br>\n\n看破这个差异之后，新的写法就呼之欲出了，以第一段代码为例：<br>\n\n&nbsp; const char* msg = (0 == iRetCode ? \"Process Success\" : \"Process Failure\");<br>\n\n&nbsp; this-&gt;SendPeerMsg(\"000\", msg, outRSet);</p>\n<p>为了节省篇幅，我选择了条件表达式。我知道，很多人不是那么喜欢它。如果if/else依旧是你的大爱，勇敢追求去吧！</p>\n<p>由这段代码调整过程，我们得出一个简单的规则：</p>\n<ul>\n<li>让判断条件做真正的选择。</li>\n</ul>\n<p>这里判断条件真正判断的内容是消息的内容，而不是消息发送的过程。经过我们的调整，得到消息内容和和发送消息的过程严格分离开来。<br>\n\n<br>\n\n消除了代码中的冗余，代码也更容易理解，同时，给未来留出了可扩展性。如果将来iRetCode还有更多的情形，我们只要在消息获取的时候进行调整就好了。当然，封装成一个函数是一个更好的选择，这样代码就变成了：<br>\n\n&nbsp; this-&gt;SendPeerMsg(\"000\", peerMsgFromRetCode(iRetCode), outRSet);<br>\n\n<br>\n\n至于第二段代码的调整，留给你练手了。<br>\n\n<br>\n\n这样丑陋的代码是如何从众多代码中脱颖而出的呢？很简单，只要看到，if/else两个执行块里面的内容相差无几，需要我们人工比字符寻找差异，恭喜你，你找到它了。</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-1\" target=\"_blank\">专栏：代码之丑（一）</a>\n》，如需转载，请务必附带本声明，谢谢。</p>\n<p>\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201010212305",
    "date": "2010-10-21",
    "time": "23:05",
    "title": "代码之丑（零）",
    "tags": [
      "代码之丑"
    ],
    "body": "<p>看到下面这段代码，你会做何感想？<br>\n\n&nbsp; if(db.Next()) {<br>\n\n&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp; <br>\n\n&nbsp; } else {<br>\n\n&nbsp;&nbsp;&nbsp; return false;<br>\n\n&nbsp; }<br>\n\n<br>\n\n有的人会想，怎么写得这么笨啊！但是，请放心，绝对会有人这么想，挺好的，实现功能了。这并非我臆造出的代码，而是从一个真实的codebase上找到。<br>\n\n<br>\n\n成为一个咨询师之后，我有机会在不同的项目中穿梭。同客户合作的过程中，我经常干的一件事是：code diff。也就是用源码管理工具的diff功能把当天全部修改拿出来，从编码的角度来分析代码写得怎么样。<br>\n\n<br>\n\n因为这个工作，我看到了许多不同人编写的代码，我的编码底线不断受到挑战。许多东西，我以为是常识，但实际上不为许多人所知，比如上面那段代码。<br>\n\n<br>\n\n我把在看到的问题总结成一个session，与客户的程序员分享。结束之后，有人建议，为什么不能把这些问题写下来，与更多人分享。于是，我产生了写下《代码之丑》念头，以此向《<a href=\"http://book.douban.com/subject/3224524/\" target=\"_blank\">代码之美</a>\n\n》致敬。</p>\n<p>最后要说的是，开始那段代码可以写成这样：<br>\n\n&nbsp; return db.Next();</p>\n<hr>\n<p>本文已经首发于<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n\n，版权所有，原文为《<a href=\"http://www.infoq.com/cn/news/2010/11/ugly-code-0\" target=\"_blank\">专栏：代码之丑——开篇</a>\n\n》，如需转载，请务必附带本声明，谢谢。\n<br>\n\n<a href=\"http://www.infoq.com/cn\" target=\"_blank\">InfoQ中文站</a>\n\n是一个面向中高端技术人员的在线独立社区，为Java、.NET、Ruby、SOA、敏捷、架构等领域提供及时而有深度的资讯、高端技术大会如<a href=\"http://www.qconbeijing.com/\" target=\"_blank\">QCon</a>\n\n、免费迷你书下载如《<a href=\"http://www.infoq.com/cn/architect\" target=\"_blank\">架构师</a>\n\n》等。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201010142243",
    "date": "2010-10-14",
    "time": "22:43",
    "title": "喘息中的回忆",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>漫长的出差，终于有了喘息的机会。<br>\n<br>\n今天是<a href=\"http://www.agilechina.net/\" target=\"_blank\">敏捷中国</a>\n开始的日子，不过，因为校园招聘的缘故，我又错过了，也就错过了和许多老朋友见面的机会。我曾开玩笑说，我只参加双数届的敏捷中国，因为各种原因，我总会错过单数届的大会，纯属巧合。<br>\n<br>\n在外出差的时候，心里是非常疲惫的。有很多东西该写下来，却没有做。有机会坐在办公室，我也会尝试回忆一下曾经发生过的种种，on beach的日子总是让我向往的。<br>\n<br>\n刚好最近<a href=\"http://exceedhl.thoughtworkers.org/\" target=\"_blank\">黄亮</a>\n也在办公室。虽然是同一个办公室的同事，但各自奔波在不同的城市，彼此也差不多半年没有见到了。他尝试在内部发起一个新的计划，给未来有志于投身咨询事业的同事打一个基础。<br>\n<br>\n这个计划有个前提，就是要把之前我们在不同咨询项目所做的内容总结出来，给他们做一个参考。他极力怂恿我在其中贡献内容。这也刚好给了我一个机会，总结曾经发生过的那些事，与我的想法也算不谋而合了。于是，我也乐得去贡献一些内容。<br>\n<br>\n写这些内容就像在写回忆录一样，曾经发生的一幕幕又浮现在眼前。回想着自己一路走来，从对咨询完全没有概念，到如今改变不少团队对于软件开发的认识，这何尝不是一种乐趣，尽管这并非我所预期的改变。<br>\n<br>\n还在继续写，继续回忆曾经的故事。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201010092122",
    "date": "2010-10-09",
    "time": "21:22",
    "title": "历史是个什么玩意儿",
    "tags": [
      "读书",
      "历史是个什么玩意儿"
    ],
    "body": "<p>近来对历史来了兴趣，《历史是个什么玩意儿》读了两卷。<br>\n<br>\n小时候，老妈为了让我拓展知识面，买了本小册子，里面涉及了各种各样的知识，包括历史。这本小册子是我最爱，翻了不知多少遍，基本上就翻烂了。在这本小册子的引导之下，从小到大，历史、地理等一类课程对我来说，一直就不在话下。<br>\n<br>\n那时候看历史更多的是在看历史事件，什么时候发生了什么事。于我而言，看历史和看小说并没有太多的差别。人大了，那些东西成了常识，对于历史，也就没有了太多的兴趣。<br>\n<br>\n今年的入司年度礼物，我照例选择买书，刚好那时《历史是个什么玩意儿》火爆。原本我对这种书没有寄以太高的期望，只是想当作小说来读。<br>\n<br>\n期望低的时候，常常会有意外收获，这套书就是。原本的预期就是作者用幽默的语言串联起一个个历史事件。结果，它不仅仅讲发生了什么，还对背后的原因进行了分析，比如元曲的发展很大程度上是由于主流社会汉语水平不怎样，有时也会站在发展的角度进行分析，比如皇帝与相的斗争，从独大的丞相，到后来对相的限制，再后来变成群相，再再后来干脆没了相。<br>\n<br>\n或许，这种探寻背后道理的思考方式刚好符合我的胃口，所以，我觉得这本书格外的好看，顺便还可以有一些额外的思考。比如，很多人奉华盛顿为圣人，因为他建了美国，却没有自己一直当老大，而主动下台，而这就是数千年前，尧舜禅让所干的事。<br>\n<br>\n读过两卷，第一卷中国古代史的部分写得异常精彩，而第二卷中国近代史部分就稍显平淡，尤其是到推翻帝制之后，进度飞快却显得有些平铺直叙，那些精彩的分析也少了。当然，我也可以理解作者如此着笔的意图，有些分析写不出。<br>\n<br>\n后面还有两卷世界史，继续读。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201009132315",
    "date": "2010-09-13",
    "time": "23:15",
    "title": "一个用C++实现的Dispatcher（三）",
    "tags": [
      "向上走",
      "咨询"
    ],
    "body": "<p><a href=\"http://ebenzhang.blogbus.com/\" target=\"_blank\">eBen</a>给《<a href=\"http://dreamhead.blogbus.com/logs/74698689.html\" target=\"_blank\">一个用C++实现的Dispatcher（二）</a>》提出了一些非常好的问题，修正了一些细节。但有一点需要稍加讨论一下：<br>那几个new,可能某些做服务器端程序的人会受不了. handlers倒是可以做成static的.所有对象共用一份就可以了. <br><br>这个问题在实现这个dispatcher的时候，有人提出来过，但我依然坚持我的选择。<br><br>似乎做过服务器应用的人对性能和内存都有着特别的敏感，我也做过，我也一样。如果每个请求都去创建dispatcher的话，不仅是内存，还有创建的成本在里面。<br><br>但是，我们为什么要每次都去创建呢？如果一次创建好，就存放在内存中，不就没有这样的问题了。<br><br>把handlers设计成static，不是一个好的设计，这样的话，这个dispatcher类本身就是有状态的了，一个对象的误操作很容易就影响到另外的对象。一个好的设计应该是尽可能无状态的，这也是全局变量不受欢迎的一个原因，杀伤力太大，且错误不好定位。<br><br>之所以有人曾经给我提出过这个问题，因为他们的代码里有太多这样的代码：<br>void Main::run() {<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; MsgDispatcher dispatcher;<br>&nbsp;&nbsp;&nbsp; dispatcher.dispatch(&amp;msg);<br>&nbsp;&nbsp;&nbsp; ...<br>}<br><br>这样的用法去使用这个dispatcher当然会有他们所担心的问题。解决起来很容易，把这个局部变量提取出来，比如做成类成员。<br><br>我们现在知道了正确的做法是只初始化一次。不过，如果这是一个内层的代码就稍微麻烦一些了，即便这个类修正好了，我们不能保证这个代码在外层只调用了一次。面对遗留代码时，事往往不如意。<br><br>在这种情况下，我会为这个dispatcher实现一个singleton：<br>class MsgDispatcherSingleton {<br>public:<br>&nbsp;&nbsp;&nbsp; static MsgDispatcher* getDispatcher() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NULL == dispatcher) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dispatcher = new MsgDispatcher;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dispatcher;<br>&nbsp;&nbsp;&nbsp; }<br>private:<br>&nbsp;&nbsp;&nbsp; MsgDispatcherSingleton() {}<br><br>&nbsp;&nbsp;&nbsp; static MsgDispatcher* dispatcher;<br>}<br><br>MsgDispatcher* MsgDispatcherSingleton::dispatcher = NULL;<br><br>需要知道的是，这是为了遗留代码所做的妥协，并不是我们真正设计的一部分。所以，我把它独立出来，如果有一天遗留代码被消除了，这个类也该随风而去。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201009102333",
    "date": "2010-09-10",
    "time": "23:33",
    "title": "一个用C++实现的Dispatcher（二）",
    "tags": [
      "向上走",
      "咨询"
    ],
    "body": "<p>遗留代码就是遗留代码，总会有一些让人意想不到的地方，原以为所有消息都是由一个类（MsgHandler）处理的，可事实上，不是。<br>if (msg-&gt;id == \"open\") {<br>&nbsp;&nbsp;&nbsp; MsgHandler handler(msg);<br>&nbsp;&nbsp;&nbsp; handler.open();<br>} else if (msg-&gt;id == \"close\") {<br>&nbsp;&nbsp;&nbsp; MsgHandler2 handler(msg);<br>&nbsp;&nbsp;&nbsp; handler.close();<br>} else if (…) {<br>&nbsp;&nbsp;&nbsp; …<br>} else {<br>&nbsp;&nbsp;&nbsp; // exception handler<br>&nbsp;&nbsp;&nbsp; …<br>}<br><br>上面的代码里面只有消息处理类的名字不同，其它的处理完全相同。不过，这样就让之前那个dispatcher就显得势单力薄。解决程序设计的问题，有一个很好用的处理手法：加个间接层。于是，<br>class DispatchHandler {<br>public:<br>&nbsp;&nbsp;&nbsp; virtual void execute(Msg* msg) = 0;<br>};<br><br>对于前面的两种类型，道理上来说，我们需要分别为两个类型（MsgHandler和MsgHandler2）分别编写对应的子类。不过，我们用的是C++，是的，模板：<br>template&lt;typename T&gt;<br>class DispatchHandlerImpl : public DispatchHandler {<br>&nbsp;&nbsp;&nbsp; typedef void (T::*Func)();<br>public:<br>&nbsp;&nbsp;&nbsp; DispatchHandlerImpl(Func sourceHandler)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :handler(sourceHandler) {}<br><br>&nbsp;&nbsp;&nbsp; void execute(Msg* msg) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T msgHandler(msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (msgHandler.*(this-&gt;handler))();<br>&nbsp;&nbsp;&nbsp; }<br><br>private:<br>&nbsp;&nbsp;&nbsp; Func handler;<br>};</p>\n<p>原来的dispatcher也要相应的调整：<br>#include &lt;map&gt;<br><br>class MsgDispatcher {<br>public:<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; void dispatch(Msg* msg);<br>private:<br>&nbsp;&nbsp;&nbsp; std::map&lt;string, DispatchHandler&gt; handlers;<br>};<br><br>void MsgDispatcher::dispatch(Msg* msg) {<br>&nbsp;&nbsp;&nbsp; DispatchHandler* handler = this-&gt;handlers[msg-&gt;id];<br>&nbsp;&nbsp;&nbsp; if (handler) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler-&gt;execute(msg);<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exception handler<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>对应的注册代码也就变成：<br>handlers[\"open\"] = new DispatchHandlerImpl&lt;MsgHandler&gt;(&amp;MsgHandler::open);<br>handlers[\"close\"] = new DispatchHandlerImpl&lt;MsgHandler2&gt;(&amp;MsgHandler2::close);<br><br>有代码洁癖的我们发现类名在这里重复了，于是，定义一个宏对其进行简化：<br>#define DISPATCH_HANDLER(className, funcName) \\<br>&nbsp; DispatchHandlerImpl &lt;className&gt;(&amp;className::funcName)<br><br>handlers[\"open\"] = new DISPATCH_HANDLER(MsgHandler, open);<br>handlers[\"close\"] = new DISPATCH_HANDLER(MsgHandler2, close);</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201009092304",
    "date": "2010-09-09",
    "time": "23:04",
    "title": "一个用C++实现的Dispatcher（一）",
    "tags": [
      "向上走",
      "咨询"
    ],
    "body": "<p>又和一个团队合作，面前又摆着一堆分发的代码，不同的是，这次用的是C++：<br>if (msg-&gt;id == \"open\") {<br>&nbsp;&nbsp;&nbsp; MsgHandler handler(msg);<br>&nbsp;&nbsp;&nbsp; handler.open();<br>} else if (msg-&gt;id == \"close\") {<br>&nbsp;&nbsp;&nbsp; MsgHandler handler(msg);<br>&nbsp;&nbsp;&nbsp; handler.close();<br>} else if (…) {<br>&nbsp;&nbsp;&nbsp; …<br>} else {<br>&nbsp;&nbsp;&nbsp; // exception handler<br>&nbsp;&nbsp;&nbsp; …<br>}<br><br>不要问我为什么不是每个消息对应一种处理类，要是知道为什么，就不是遗留代码了。于是，我们尝试着用C++写了一个dispatcher。下面是这个dispatcher的声明：<br>#include &lt;map&gt;<br><br>typedef void (MsgHandler::*handlerFunc)();<br><br>class MsgDispatcher {<br>public:<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; void dispatch(Msg* msg);<br>private:<br>&nbsp;&nbsp;&nbsp; std::map&lt;string, handlerFunc&gt; handlers;<br>};<br><br>因为要处理遗留代码，这里用到了指向成员函数的指针，也就提高了理解这段代码的门槛。具体实现如下：<br>void MsgDispatcher::dispatch(Msg* msg) {<br>&nbsp;&nbsp;&nbsp; handlerFunc func = this-&gt;handlers[msg-&gt;id];<br>&nbsp;&nbsp;&nbsp; if (func) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgHandler msgHandler(pkg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (msgHandler.*func)();<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // exception handler<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>注册很简单：<br>handlers[\"open\"] = &amp;MsgHandler::open;<br>handlers[\"close\"] = &amp;MsgHandler::close;</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201009082230",
    "date": "2010-09-08",
    "time": "22:30",
    "title": "一个用C实现的Dispatch框架",
    "tags": [
      "向上走",
      "咨询"
    ],
    "body": "<p>用条件语句做分发是一件很常见的事：<br>switch(msg-&gt;id) {<br>&nbsp;&nbsp;&nbsp; case ID1: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID1Handler(msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; case ID2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID2Handler(msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; ...<br>}<br><br>条件稍微多一些点，函数就会变得冗长不堪。有的团队会直接用if..else，进行判断，于是我们有幸知道了，VC不支持超过128个的选择分支。为了让这种代码的可维护性更好，我们做了一些尝试。<br><br>下面定义了一个dispatcher：<br>BEGIN_DISPATCHER(MSG, ID, MsgHandler)<br>&nbsp;&nbsp;&nbsp; DISPATCH_ITEM(ID1, ID1Handler)<br>&nbsp;&nbsp;&nbsp; DISPATCH_ITEM(ID2, ID2Handler)<br>END_DISPATCHER(DisasterHandler)<br><br>首先，用BEGIN_DISPATCH_MAP定义了这个dispatcher的名字（MSG），用做分发键值的类型（ID）和处理函数的类型（MsgHandler）。接下来，用DISPATCH_ITEM定义了几个分发项，也就是说，如果传入的值是ID1，会用ID1Handler进行处理，如果是ID2，则对应着ID2Handler。最后，用END_DISPATCH_MAP定义了一个错误处理函数。这样的话，就把使用的时候，就不必额外去做判空的操作了。这是Null Object模式的一种体现。<br><br>这个dispatcher的使用方式如下：<br>dispatch(to(MSG), with(msg-&gt;id))(msg);<br><br>这段代码的含义是使用MSG这个dispatcher，根据msg-&gt;id找到对应的处理函数，传入的参数是msg。<br><br>这个dispatch框架的实现如下：<br>#include <br>#define SIZE_OF_ARRAY(array) sizeof(array)/sizeof(array[0])<br><br>/* dispatcher definition */<br><br>#define __DISPATCHER_NAME(name) __dispatcher_##name<br>#define __DISPATCH_ITEM_NAME(name) __dispatch_item_##name<br>#define __IsMatched(target, source) (0 == memcmp(&amp;target, &amp;source, sizeof(target)))<br><br>#define BEGIN_DISPATCHER(name, key_type, handler_type) \\<br>&nbsp;&nbsp;&nbsp; struct __DISPATCH_ITEM_NAME(name) {\\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_type key;\\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler_type *handler;\\<br>&nbsp;&nbsp;&nbsp; };\\<br>&nbsp;&nbsp;&nbsp; \\<br>handler_type* __DISPATCHER_NAME(name)(key_type key) \\<br>{\\<br>&nbsp;&nbsp;&nbsp; static struct __DISPATCH_ITEM_NAME(name) dispatchers[] = {\\<br><br>#define END_DISPATCHER(disaster_handler) \\<br>&nbsp;&nbsp;&nbsp; };\\<br>&nbsp;&nbsp;&nbsp; int i;\\<br>&nbsp;&nbsp;&nbsp; int array_size = SIZE_OF_ARRAY(dispatchers); \\<br>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; array_size; i++)\\<br>&nbsp;&nbsp;&nbsp; {\\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__IsMatched(dispatchers[i].key, key)) {\\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dispatchers[i].handler;\\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\\<br>&nbsp;&nbsp;&nbsp; }\\<br>&nbsp;&nbsp;&nbsp; return disaster_handler;\\<br>}<br><br>#define DISPATCH_ITEM(key, handler) {key, handler},<br>#define DISPATCH_ITEM_2(key1, key2, handler) {key1, key2, handler},<br>#define DISPATCH_ITEM_3(key1, key2, key3, handler) {key1, key2, key3, handler},<br>#define dispatch(name, key) __DISPATCHER_NAME(name)(key)<br>#define to(name) name<br>#define with(key) key<br><br>从这里可以看出，定义dispatcher，实际上是定义了一个函数，这个函数的返回值是一个函数指针，而这个函数指针的类型是由handler_type定义的。这样的话，就解决了不同dispatcher之间函数参数不同的问题。<br><br>当然，这个处理里面采用了最简单的数组，在分发项不是很多的情况下是适用的。如果分发项较多，可以考虑改为map实现。另外，这里还运用了一些宏的技巧。在写应用代码时，我们并不鼓励多用宏。但写一些框架代码，为了提高使用上的表现力时，宏也会是一个利器。<br><br>如果有兴趣，欢迎讨论！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201009012348",
    "date": "2010-09-01",
    "time": "23:48",
    "title": "咨询师 != 救世主",
    "tags": [
      "我眼看世界",
      "敏捷",
      "ThoughtWorks",
      "咨询"
    ],
    "body": "<p><a href=\"http://shenheng.blogbus.com/\" target=\"_blank\">shenheng</a>对《<a href=\"http://dreamhead.blogbus.com/logs/74044317.html\" target=\"_blank\">系统复杂之路</a>》评论道：<br>连自己也维护不了的代码，难道可以靠神一般的咨询师？玩笑开大了吧，咨询师的到来，与葬礼上的神父无异！<br><br><strong>咨询师会带来天翻地覆的变化，这样的期许本身就是不现实的。</strong><br><br>其实，我也不喜欢咨询师。<br><br>做咨询之前，我一直想不通，有什么问题自己搞不定，非要请咨询师。<a href=\"http://osthoughts.blogbus.com/\" target=\"_blank\">founder_chen</a>说，如果大家都像你一样，咨询就没活干了。<br><br>可惜，世界上还有很多咨询师，后来，我也成了一个。<br><br>做咨询一段时间，我常困惑于我到底可以给客户带来什么。<br><br>于今，我释然了。我只不过关注着一些那些人不曾关注过的东西，比如软件设计，比如Clean Code，比如重构，比如TDD，比如如何做程序员，比如如何做事。而在客户那里，我所做的，只是把这些东西以他们习惯的方式展现给他们。<br><br>我只是打开一扇门。<br><br>做了个培训，结尾，有人问，怎样才能保证设计的一些东西在后续的开发过程中不被破坏。<br><br>好问题，保证不了。<br><br>真正保证设计不被破坏的是团队，而不是软件设计本身。团队里需要有人知道代码应该写成什么样子，需要有人清楚系统架构是什么样子，需要有人有正义感，在有人无心伤害时，敢于出来喊一嗓子。</p>\n<p>在原有的环境下，这样的人对于其他的工作方式知之甚少。不是他们不努力，很多时候，他们只是不知道自己不知道。我所能带给他们的就是，让他们知道另一片风景的存在。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201008302327",
    "date": "2010-08-30",
    "time": "23:27",
    "title": "系统复杂之路",
    "tags": [
      "敏捷",
      "ThoughtWorks",
      "咨询"
    ],
    "body": "<p>好，大家写的是C++程序，那么用过virtual的，请举手！<br>举起的手屈指可数。<br><br>这次是系统架构的梳理，一个C++编写的大型系统，写到了添加一个新东西，自己都很难受的地步。是的，健康状况良好的系统是不会找咨询师的。<br><br>几个对系统很熟悉的人给我介绍了系统的架构，其实，它并不像我预期的那样不堪，从宏观的层面上，有着相对比较清晰的结构。我很好奇，一个还算不错的架构如何演变成今天的模样。<br><br>听完他们对于现阶段困境的介绍，我打开了代码，出现在眼前的是一大堆if，我逐渐明白了。<br><br>每次来了新需求，他们都会在现有的代码上找一个适合处理的地方，然后，加上一个判断条件，填上一大堆处理，OK，收工。下一次，又来新需求，又找到一个地方，又加上一个判断条件，又填上一堆处理。同样的事情，每天发生着。经年累月，系统成了今天的样子。<br><br>在我们看来，写完代码要重构，函数应该尽可能短小，重复尽可能少，遗憾的是，这并不是这个团队的开发人员的行事风格。<br><br>在巨大的交付压力面前，他们所能做的低着头赶代码，他们眼里，写程序就是照着别人的代码，把功能堆砌出来。他们没有时间去学习，甚至连自己用的语言都不了解：用C++的不了解virtual，写C的不知道函数指针。周边的人大多以同样的方式工作着，没有时间抬头看路的人，以为这就是天经地义的工作方式。<br><br>就是这样一支团队，日复一日的“努力”工作，系统复杂起来，于是，咨询师有了用武之地。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201008232210",
    "date": "2010-08-23",
    "time": "22:10",
    "title": "搭建Scala工程——测试",
    "tags": [
      "Scala",
      "Buildr",
      "ScalaTest"
    ],
    "body": "<p>作为一个ThoughtWorker，缺少测试会让我内心充满不安，面对Scala也不例外。书接<a href=\"http://dreamhead.blogbus.com/logs/73555884.html\" target=\"_blank\">上文</a>。有了Buildr，在工程里组织测试也很容易。<br><br>具体了解之前，先来看看Scala的测试框架。《Programming Scala》中介绍了JUnit和ScalaTest，其中<a href=\"http://www.scalatest.org/\" target=\"_blank\">ScalaTest</a>是个纯粹的Scala的框架。不过，书中只介绍了非常基本的用法。如今，ScalaTest已然变化了许多。<br><br>ScalaTest<a href=\"http://www.scalatest.org/quick_start\" target=\"_blank\">支持很多种测试风格</a>，从最传统的Assert到<a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\" target=\"_blank\">BDD</a>，再到<a href=\"http://en.wikipedia.org/wiki/Feature_Driven_Development\" target=\"_blank\">FDD</a>。所以，选择ScalaTest，先要选择一种风格，以便统一，至少在同一类测试中应该遵循同一种风格。即便是选择了一条路，有时，也会有分叉路。比如BDD，<a href=\"http://www.scalatest.org/getting_started_with_bdd\" target=\"_blank\">有三种风格可选</a>：<a href=\"http://www.scalatest.org/getting_started_with_spec\" target=\"_blank\">Spec</a>、<a href=\"http://www.scalatest.org/getting_started_with_word_spec\" target=\"_blank\">WordSpec</a>和<a href=\"http://www.scalatest.org/getting_started_with_flat_spec\" target=\"_blank\">FlatSpec</a>。<br><br>Spec是受Ruby的<a href=\"http://rspec.info/\" target=\"_blank\">Rspec</a>影响而产生的，用过Rspec的人，看到describe、it这样的字眼会倍感亲切。WordSpec的灵感来自<a href=\"http://code.google.com/p/specs/\" target=\"_blank\">specs</a>——另一个Scala测试框架，字符串放在前面让这个DSL看上去更有感觉。如果不喜欢太多缩进，那FlatSpec是个另外一个选择。<br><br>选择太多未必是件好事，作为一个团队，将风格统一是最重要的。ScalaTest让人想起了C++，够强大，但选择太多，花了大量精力学习之后，才会发现很多东西应该避免混合使用。<br><br>Buildr对Scala提供了内建的支持，只要我们把代码放到src/test/scala即可。下面是一个采用了Spec风格编写的测试：<br>import org.scalatest.Spec<br>import org.scalatest.matchers.ShouldMatchers<br><br>class AddSuite extends Spec with ShouldMatchers {<br>&nbsp; describe(\"plus\") {<br>&nbsp;&nbsp;&nbsp; it(\"should return 2 for 1 plus 1\") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 + 1 should be === 2<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>}<br>(src/test/scala/AddSuite.scala)<br><br>然后，运行测试：<br>&nbsp; buildr test<br><br>Buildr 1.4.1支持的ScalaTest版本是1.0.1，而ScalaTest的新版已经发布了，如果想采用新版本的ScalaTest可以自行设定版本。<br>require 'buildr/scala'<br><br>Buildr.settings.build['scala.version'] = \"2.7.7\"<br>Buildr.settings.build['scala.test'] = '1.1'<br><br>define 'demo' do<br>&nbsp; project.version = '0.0.1'<br>&nbsp; package :jar<br>end<br>(buildfile)<br><br>Buildr还对specs提供了内建的支持，只要把代码放到src/spec/scala下。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201008222354",
    "date": "2010-08-22",
    "time": "23:54",
    "title": "搭建Scala工程",
    "tags": [
      "Scala",
      "Buildr"
    ],
    "body": "<p>搭建Scala工程，一个比较简单的做法是选择Buildr。<br><br><a href=\"http://buildr.apache.org/\" target=\"_blank\">Buildr</a>是构建工具，类似于Ant和Maven，它的构建脚本是用Ruby编写的，对于不喜欢XML配置文件的人来说，这是一个福音。就这里而言，我们最需要的是它对Scala的支持。顺便说一下，它也对Groovy提供了内建支持。<br><br>安装Buildr，可以参考<br><a href=\"http://buildr.apache.org/installing.html\" target=\"_blank\">http://buildr.apache.org/installing.html</a><br><br>Buildr缺省的构建文件叫做buildfile，下面是一个最简单的支持Scala的buildfile：<br>require 'buildr/scala'<br><br>define 'demo'<br>(buildfile)<br><br>我们把Scala源程序放到src/main/scala下：<br>class Person<br>(src/main/scala/Person.scala)<br><br>熟悉Maven的人可能会发现，这个文件布局方式类似于Maven，没错，在Buildr主页上有这样一段描述：<br>A drop-in replacement for Maven 2.0, Buildr uses the same file layout, artifact specifications, local and remote repositories.<br><br>接下来，我们就可以进行编译了：<br>&nbsp; buildr compile<br><br>如果是第一次编译，buildr会自动去下载项目相关的库，这和Maven的行为是一致的。<br><br>如果要把自己编写程序打成一个JAR包，只要稍微修改一下buildfile<br>require 'buildr/scala'<br><br>define 'demo' do<br>&nbsp; project.version = '0.0.1'<br>&nbsp; package :jar<br>end<br>(buildfile)<br><br>然后，运行命令：<br>&nbsp; buildr package<br><br>缺省情况下，Buildr会尝试使用Scala最新的稳定版本，如今，Scala 2.8已经发布，所以，最新的稳定版本已经成了2.8，但并不是所有库的支持都升级到了2.8。所以，有时候我们需要指定Scala的版本。<br>require 'buildr/scala'<br><br>Buildr.settings.build['scala.version'] = \"2.7.7\"<br><br>define 'demo' do<br>&nbsp; project.version = '0.0.1'<br>&nbsp; package :jar<br>end<br>(buildfile)<br><br>使用Buildr，还可以生成IDE的工程文件，当然，请在IDE中安装好对应的插件。比如为了在IntelliJ IDEA中使用我们的工程，只要：<br>&nbsp; buildr idea<br><br>要想了解当前buildfile所支持的任务，可以：<br>&nbsp; buildr -T<br>或者<br>&nbsp; buildr help:tasks</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201008182311",
    "date": "2010-08-18",
    "time": "23:11",
    "title": "开发即将开始",
    "tags": [
      "脚下的路",
      "敏捷",
      "ThoughtWorks",
      "咨询"
    ],
    "body": "<p>面前坐着一个开发人员，他马上就要开始一段新的开发任务，而我，一个咨询师，要通过他了解一下开发状况。<br>我：你了解要做的东西吗？<br>开发人员：知道，就是一个查询。<br>我：具体如何做呢？做过任务分解吗？<br>开发人员：没，我也是刚接触这个部分，不是很清楚。<br>我：这个Story估计只有一个点？<br>开发人员：不是我做的估计。<br>我：那我们一起做一下任务分解吧！<br>开发人员：好。<br><br>分解出来的任务还是有些让人困惑的地方。<br>我：这个地方，你知道怎么做吗？<br>开发人员：不太清楚。<br>我：问过分析的人吗？<br>开发人员：还没。<br>我：那就去问一下吧！<br>开发人员：人家忙着吧？<br>我：他们总会很忙，去吧！否则，就堵在这了。<br><br>和“忙碌”的分析人员聊过，开发人员显然有了谱，我和他继续分解工作。<br>我：这个地方是什么意思？<br>开发人员：方案要调整一下。<br>我：那它作这个Task的一部分合适吗？这可能会牵扯到很大的一个调整。<br>开发人员：你说的有道理，那我们把它单独拿出来作为一个Task。<br>我：现在你还觉得它是一个点的Story吗？<br>开发人员：一个点肯定不够。<br><br>开发即将开始，我们真的理解了要做的事情吗？</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201008091021",
    "date": "2010-08-09",
    "time": "10:21",
    "title": "旁观茶餐会",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>之前咨询过的一个团队，有一个叫茶餐会的活动，顾名思义，大家坐在一起喝茶、吃饭、聊天。实际上，就是让团队里面说得算的人聚到一起，讨论一下团队遇到的问题。在我们还在咨询的时候，这个活动让我们有机会和各位领导做近距离的沟通，解决了在敏捷实施过程中遇到的问题。<br><br>出乎我意料的是，我们离开后，他们把这个活动坚持了下来。得知我在，他们邀请我一起参加。时隔几个月，我也想了解一下我们咨询的成果，于是，我参加了这次茶餐会。<br><br>老朋友见面寒暄一番是无可避免的。我给大家介绍了自己这几个月四处云游的经历，而他们则向我展示了工作成果。让我印象颇深的一点是，遥想当初，为了搭建CI，负责人四处找机器，如今鸟枪换炮，新的数据中心建立起来了，数千个CPU可用于CI，并发性得到了大幅度提升。<br><br>当然，这些人坐在一起不是为了自我表扬的，大家开始讨论起问题，因为我和他们曾经在一起很长时间，所以，他们也不见外，不避讳的把问题摆了出来。只是这次，我不再是咨询师，而是一个旁观者。<br><br>大多数人已经认识到诸如单元测试这些实践的益处，当初我带的一个团队，因为坚持了做好基础，和整个代码合在一起之后，错误极少。不过，团队的压力依然巨大，在压力面前，很多人还是会倾向于走回老路。<br><br>无论如何，代码的基础在提高，却把另外一个问题暴露出来：需求分析。对测试的回溯会发现，很多问题是由于几方理解不一致造成的。团队里总有人抱怨需求不清晰，做需求的人也冤，原来就是这么做的。大家在一起讨论发现，原来之所以可以这么做，是原来团队的成员经验丰富，经过一次搬迁，原有团队的很多成员离开了，现在团队的成员经验要浅得多，那些潜经验消失了。<br><br>人，人，还是人，人总是不够，怎么算都不够，需求分析的缺人，开发的缺人，支持的缺人。他们饶有兴致的问我，你们怎么做估计呢？实事求是。我看见了一丝无奈闪过，我知道，他们总要“挑战一下”。<br><br>还是人，在讨论的过程中，有人表现极强的防御心理。无论别人给出什么样建议，他都会列举出无数的理由，说这么做会有怎样怎样的问题，总而言之，就是我还按照原来的路来走。这种情形，我在咨询过程中，见过很多了。其实，这样的人本身都会很有想法，在团队里面也有很大的影响力，一旦能够改变，会是巨大的推动力。<br><br>作为旁观者，我乐得欣赏这样的讨论，大家开诚布公的把问题摆在台面上讨论，一起讨论解决方案，这样的团队是有希望的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201008022215",
    "date": "2010-08-02",
    "time": "22:15",
    "title": "《Programming Scala》出版了",
    "tags": [
      "脚下的路"
    ],
    "body": "<p><a href=\"http://dreamhead.blogbus.com/logs/60061451.html\" target=\"_blank\">启动翻译《Programming Scala》<br>翻译《Programming Scala》</a><br><br>《Programming Scala》离开我的视线已经有很长一段时间了。在即将遗忘自己曾经翻译过一本书之际，它出版了。出版社给了它起了个中文名字，叫做《<a href=\"http://www.china-pub.com/196931\" target=\"_blank\">Scala程序设计</a>》。<br><br>无论如何，它是第一本正式出版的Scala中文书籍，希望对大家了解Scala有所帮助。顺便附上自己写的译者序，分享一些心得。<br><br><strong>写代码的层次</strong><br><br>初涉代码之时，我的关注点在于实现功能。初窥门径的我，不了解语言，不熟悉常见的编码技巧。那时，只要代码能够跑出想要的效果，我便欣喜若狂，无暇顾及其他。<br><br>积累一定经验之后，对于编写代码，我越来越有感觉，实现一个功能不再高不可攀。我开始了解在工程中编写代码，如何在一个系统而不仅仅是一个局部处理问题，如何解决各种bug，更重要的是，从中汲取教训，在编码中避免这些问题。<br><br>读一些软件开发的书，了解一下外面的世界，我知道了，除了自娱自乐外，代码应该是为明天而写。有个说法，对程序员最严厉的惩罚，就是让他维护自己编写的代码。于是，我开始尝试编写干净代码：短小的函数，清晰的结构……所做的一切无非就是让自己明天的日子好过一些。<br><br>历经磨练，代码逐渐干净，窃喜之际，我见到了Ruby。孤陋寡闻的我第一次听到了代码的表现力。原来代码不仅仅可以写得让开发人员容易理解，也可以让业务人员看懂。事实上，更容易懂的代码常常也意味着更容易维护。许多人关注的DSL，背后就是对于表现力的追求。<br><br>Scala就是Java平台上追求表现力的探索。<br><br>我是通过Java开始真正理解软件开发的，所以，对Java这个平台有一种难以割舍的情结。初见Scala，我看到的是，一个几乎不舍弃任何Java的优点，又能拥有更好表现力的“Java”。当有机会系统地了解这门语言时，我欣然接受了。<br><br>翻译向来是一件费力不讨好的事。认真准备的考试不见得能拿到满分，尽最大的努力，做最坏的打算。于我，只希望这个译本得到的评价不是太糟糕就好。<br><br>感谢我的合作者，李剑，你给我这样的机会，让我知道，我居然还可以做翻译，你的认真让我受益良多。感谢本书的原作者Venkat Subramaniam，和你讨论让我们对Scala有了更深刻的理解。</p>\n<p>最后，感谢我的父母，你们教会我踏实做人，支持着我沿着软件开发这条路一直走下去。<br><br>郑　晔<br>2010年4月18日于成都 </p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201008011459",
    "date": "2010-08-01",
    "time": "14:59",
    "title": "选择题？问答题？",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p><strong>选择题比问答题更容易回答。</strong><br><br>团队有条不紊的进行着开发，突然，一个业务问题出现了，开发团队里没有人知道这个问题在业务场景下到底该怎么解决，还好，我们还有一个叫做“客户”的救星。<br><br>虽然在敏捷软件开发中，我们希望有一个随叫随到的on-site customer，但是，现实往往不如人意。于是，我们决定给客户写封邮件，期望他们解救我们于水火。<br><br>在邮件里，我们把自己面临的问题列了出来，然后问他该怎么办。点下“发送”按钮那一刻起，我们便开始等待他们的回复。<br><br>奇怪的是，几天过去了，一向和蔼可亲的客户却一直没有给我们答复。于是，和他们一起交流时，我们善意的提醒了他们一下。大家都是明白人，客户当然知道问题确实是个问题，但他最近确实忙得没有时间仔细想想这个问题如何解决。毕竟除了和我们打交道，人家还有别的事，这种情况我们也能理解。<br><br>就这样，问题一拖再拖，解决方案似乎遥遥无期。</p>\n<p>这是不是一个让人很熟悉的场景？似乎大家都没做错什么，但问题就这样耽搁着。<br><br>时光逆转，我们再来面对一次同样的问题，又到了写邮件的环节。<br><br>这次我们列出的不只是问题，还针对问题的根因给出了自己的分析，并结合我们已有的了解给出了几个备选方案，分析这些备选的方案的优劣，给出我们的推荐。<br><br>客户的回复很快就回来了。一切顺利的话，他就直接同意了我们的做法，稍有一些情况的话，他会基于某个方案中给出自己的理解，几个回合下来，大路通畅了。<br><br>这不是我的臆造，而是真真切切发生在身边的故事。其实，两种做法的差别只在于我们给客户提供了不同的选择，前一种是问答题，后一种是选择题。<br><br>选择题比问答题更容易回答，客户不需要更多的投入就可以给出回答，而复杂的问答题需要更多的投入，如果和其它更紧急的事情比起来，它的优先级很容易就放低了。对客户而言，他不觉得是这有什么，而对团队来说，这却是一种伤害。<br><br>换个角度来看，谁把有难度的事做了，谁的价值就大。如果我们轻易的就把不经思考的结果抛给别人，对自己来说，省事了，但也容易让人看轻我们做事的能力。而提出有质量的问题，这会更加让人欣赏。<br><br>《程序员》杂志曾经刊载过一篇Danny Thorpe的访谈录，其中有一段是他向Chuck Jazdzewski提问的故事。Chuck对于Danny的问题如是说，“真正令我烦恼的是，当一个人打断我的工作，问的却是通过阅读文档和源代码，或是思考一会儿就能解决的问题。这些问题浪费了我的时间。然而，你的问题常常触及有趣或棘手的话题，这说明你下过功夫并思考了很多问题。我欣赏你去努力地理解问题，而不是指望别人提供所有答案。我永远欢迎你提问题。”<br><br>关于提问，Eric Raymond在《<a href=\"http://catb.org/esr/faqs/smart-questions.html\" target=\"_blank\">提问的智慧</a>》是一篇很好的参考材料。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201007121028",
    "date": "2010-07-12",
    "time": "10:28",
    "title": "在外工作（三）",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>西班牙，从欧洲冠军升级成了世界冠军，章鱼帝压倒了未来哥，四年盼一次的世界杯结束了。<br><br>出发的日子是6月11日，世界杯开赛的日子，这就注定了不能很完整的欣赏这次世界杯。<br><br>一直以为在国内熬夜看世界杯是很痛苦的事情，跑到了地球的另一端，时间刚好颠倒过来，可以在白天欣赏世界杯。熬夜看球至少还有得看，白天时间固然好，但实际上，那个时间大多数情况下是在上班，所以，连看的机会都没有。<br><br>真正有机会完整欣赏的阶段，只有八强赛和最后的决赛，因为是在周末。<br><br>有机会看的时候，还是不错的，宾馆的电视很大，赶上ESPN的转播，还有高清频道。几个同事坐在一起，天南海北的胡扯，对场上的比赛品头论足。<br><br>除了比赛，世界杯还有氛围。据说，北京办公室在世界杯期间展开了竞猜，不少人因此吃到了好多冰淇淋。而我们这些飘在外面的，就只有比赛了。<br><br>所幸，赶上的比赛还算有看头，总有一些精彩：诡异的巴西糊里糊涂的输给了荷兰，乌拉圭和加纳加时最后一分钟的天堂地狱转换，年轻的德国水银泻地的进攻击退了马大帅的阿根廷，西班牙最后时刻击退巴拉圭，三四名跌宕起伏的打进五个球。至于决赛，还算不错，只是功利心让精彩程度打了折扣。</p>\n<p>从2008年的欧洲杯开始，舍弃了劳尔的西班牙走上了巴萨的路线，于是他们转运了。到了这次世界杯，巴萨的痕迹更重了，算上要成巴萨人的比利亚和出身巴萨的小法，最多的时候，除了门将和边后卫，场上会有8个巴萨人。近些年巴萨的强大和西甲的繁荣支撑出这支西班牙。</p>\n<p>2010给了世界一个新的冠军，2014年巴西，希望到时候，我可以更完整的欣赏。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201006282314",
    "date": "2010-06-28",
    "time": "23:14",
    "title": "在外工作（二）",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>在做的这个项目是为一个遗留系统提供Web Service，从技术上来说并不复杂。说起来就是接到请求，然后调用一下已有代码。<br><br>让这个项目有难度的是后面庞大的遗留系统。整个系统大概已经有十多年的历史了，已有codebase里面大量运用的JDBC可见一斑。真正要搞清楚如何把接收过来的请求对应到现有的代码上并不是那么容易的。虽然我们很快就把主体代码完成了，但随着项目的进展，对系统的不断发掘，一些遗漏的点就会不断显现出来。<br><br>客户有一个对系统比较了解的人和我们一起工作，但事实证明，他也不可能对每一个细节都了如指掌，更重要的是，他也有别的工作，不可能与我们时时刻刻在一起工作，这也在很大程度上增加了我们工作的难度。所以，我们更多的时候，要靠自己发掘问题，然后，和他确认我们的理解。他很忙，找到他人是件很困难的事情，与我们约时间，他很少有准时到的。原来，在忙碌的甲方问题上，国内国外都一样。<br><br>虽然我们是在用敏捷的方式进行开发，但是，客户并没有以敏捷的方式与我们衔接。比如，挂在Story Wall上的卡大多数都处于Ready for QA的状态。客户的QA从我刚刚到这边的时候就说要加入，两个星期过去了，QA的人除了standup和showcase之外，就只和我们真正坐在一起不到两个小时。每次我们的PM和客户提起这个问题，他们总会抛出各种各样的理由，证明问题不在他们身上。原来，在自保的问题上，国内国外都一样。<br><br>行将发布之际，我们解决了主要问题，要扫一些边角。于是，和我们的技术接口人进行讨论，他看到我们的开发速度比较快，于是，做出了一个有神来之笔的决定，让我们开发另外一个需求。是的，另外一个需求，不只是简单的修补。和客户讨论完，我们有些晕，怎么就又冒出个这么大的需求。于是，我们赶紧拉来了我们的PM和另外的同事一起讨论。冷静下来之后，我们明确了一个方向，要和这个接口人仔细讨论一下，不盲目承诺。事实证明，他也确实没有想明白，第二天，见到我们，还没有等我们把精心准备的问题抛给他，他自己就说，他和别人开会讨论了一下，这个需求确实不该放到我们这里来做。原来，在天马行空的问题上，国内国外都一样。<br><br>说来说去，这种企业级项目，人总是一个问题。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201006271733",
    "date": "2010-06-27",
    "time": "17:33",
    "title": "在外工作（一）",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>又住了两个星期的宾馆。不同于之前，这是我第一次在国外工作。<br><br>由于有12个小时的时差，初来乍到时，每天上午还能坚持，一到下午，整个人就完全不在状态了。为了不公然在客户现场睡觉，我只能选择以咖啡坚持，即便如此，也经常神游天外。在先期到来的冰云和米高强迫下，我按照当地的时间进行作息，用了几天，我逐渐适应了当地的时间，但是每天下午开始工作之前喝咖啡的习惯保留了下来。<br><br>这次出来实现的第一个愿望是买到了<a href=\"http://www.apple.com/ipad/\" target=\"_blank\">iPad</a>。我对iPad的需求很简单，不要让我旅途太无聊。来之前听说iPad买了200万，真的到了自己去买才知道这东西到底有多火。来的第一天，我就直奔苹果专卖店，得到的答复是没有了。第二天再去，只有3G版64G的。事不过三，当我开始绝望，准备在网上预订的时候，第三次拜访专卖店，刚好赶上一批新货，于是，我拿到了自己的iPad。<br><br>在这边客户现场工作有一个不错的方式，只要每周工作40小时即可，换句话说，如果每天工作10小时，一周只要工作4天就好了，此外，公司每周都可以提供回家的机票。所以，很多在客户这边工作的人都会选择这种工作方式，周五飞回家，与家人共度周末，然后周日再飞回来，许多人因此攒了很多飞行的积分。<br><br>因为有这样的政策，在冰云的同学的帮助下，我第一个周末就“回了趟家”——去了趟公司总部，刚好总部在那个周末举办了一个野餐会。在ThoughtWorks工作时间稍微长一点，就会发现，经常会在不同的地方遇到熟人，总部自然更不例外。之前曾经遇到的一些故人又相见了，大家免不了寒暄一番。<br><br>野餐在户外，为了证明自己到过总部，我专程拜访了一下周末无人的总部办公室。ThoughtWorks的办公室总是相似的，一进去就会感到这是公司。宽畅的空间，大大的圆桌，随处可见的白板、技术书籍以及各种小玩意。行政人员的工作区里插着有办公室国家的国旗。总部办公室的面积很大，大约有一层半，北京办公室是半层。据说和北京一样，总部也经常承办一些技术活动，所以，有一个很大的空间专门布置成了开放的会场。<br><br>办公室所在的大厦是一座摩天大厦，这个办公室在20多层，站在窗边，可以看出去很远。作为导游的冰云，还带着我到顶层——80层转了一圈，坐电梯坐出了飞机的感觉。只可惜当时那里正在举办一个聚会，我们只是匆匆看了一下。</p>\n<p>初来乍到，新鲜的感觉还不错。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "201006092331",
    "date": "2010-06-09",
    "time": "23:31",
    "title": "欢迎回归",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>今天，一个之前的ThoughtWorks同事来到了简陋的新西安办公室。<br><br>我们聊起了他现在的工作，准确的说，他在向我倒苦水。</p>\n<ul>\n<li>他现在负责业务分析，按照他对于这个角色的理解，他应该有很多的机会面对客户，可事实上，他却根本见不到客户。</li>\n<li>他希望在业务分析方面有深入的理解，结果，老大们许给他的未来是个管理职位，按他的说法，这根本不是他想要的。</li>\n<li>他算是业务分析方面的负责人，所以，他总是竭尽所能给自己下属排除干扰，但老大们认为，他的人干的活太单一了。</li>\n<li>他总喜欢做一些分享，却被周边的人认为是炫耀。</li>\n<li>他老大想让他带动公司的敏捷，却不给予他任何支持。</li>\n<li>⋯⋯</li>\n</ul>\n<p>从他的种种观点可以看出，他身上打下了深深的ThoughtWorks烙印，谁让他毕业工作的第一家公司就是ThoughtWorks呢！<br><br>当年ThoughtWorks离开西安，因为家庭原因，一些同事离开了。当西安办公室重新开张，几个当年带着不舍离开的同事回归了。<br><br>和这些同事聊天，最大的感受是他们现在更加珍惜ThoughtWorks这样的工作环境了。他们都是毕业就进入了ThoughtWorks，离开公司的这段时间让他们知道这样的工作环境来之不易。反而最初在公司工作的那段时间，他们并没有意识到这一点，认为一切都是理所当然的。</p>\n<p>在公司之外，他们才认识到公司的好。或许这才是促使他们回归的动力吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200805192323",
    "date": "2008-05-19",
    "time": "23:23",
    "title": "哀悼，逝去的生命",
    "tags": [
      "我眼看世界"
    ],
    "body": "这是一个全国哀悼的日子，为那些在地震中逝去的生命。<br><br>关于地震，我一直想写点什么，又不知从何下手，因为我着实不是一个愿意记录悲伤的人。但我还是决定写一些东西，让思绪飘散一下。<br><br>这注定不是一个平静的年景：雪灾，火车相撞，地震。国难让中国人空前的团结起来。<br><br>对我而言，今天也是姥姥过世三周年的纪念日。我是姥姥一手带大的，对姥姥有着深厚的感情。所以，我深知亲人离开的痛苦。地震让那么多人失去了亲人，对于活着的人，那是一种折磨，无论你怎样的坚强。<br><br>和老妈通电话，她对于地震的记忆要比我深刻，因为75年的海城地震和76年的唐山地震，对于家里都是有影响的。因为曾经离地震很近，所以，她更知道今天的地震意味着什么。<br><br>地震时，我以为自己眩晕，后来，才意识到不对，但也并没有往心里去，因为念高中时，学校离矿区很近，矿里放炮的时候，就会感到楼在晃。当我得知地震发生在四川，北京可以感到明显的震动，我知道这会是一场灾难。<br><br>其实，最近一段时间，我有意无意在回避关于地震的消息，因为我知道，那些消息会让自己心痛。<br><br>有人以为，有些公司或个人捐款是在作秀。如果真是这样，我希望这样的秀越多越好，只要是对灾区有益的。<br><br>默哀那一刻，站在办公室里，耳边是响亮的喇叭声和警报声，思绪是混乱的。<br><br>自然面前，人很渺小。这是我写在自己饭否上的一句话。渺小的一方，价值何在？在抗震救灾的过程中，一个个感人的故事给了我们答案：人性的光辉。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200805152306",
    "date": "2008-05-15",
    "time": "23:06",
    "title": "ThoughtWorks的开源土壤",
    "tags": [
      "我眼看世界"
    ],
    "body": "今天到CSDN参加了一个关于开源的讨论，谈到了自己参加开源项目的感受，也谈到了公司的一些情况。关于自己的部分，前前后后在blog里提到了不少。这里稍微整理一下自己对公司开源情况的一些理解，不见得完全正确，只是基于自己看到的和理解的，如果哪位同事觉得不对或不足，不妨站出来纠正或补充我。<br><br>ThoughtWorks是一个咨询公司，这意味着我们有很多机会参与到不同领域的开发之中，也就让我们的经验可以得到不断丰富，更重要的是，我们有机会知道哪些经验是可以复用的。一些可以被复用的知识就在开发过程中被识别出来。ThoughtWorker们是一群愿意不断把事情做得更好的人，于是，就会有一些人把这些可以复用的部分提炼出来，将其开源，把这些知识分享到给社区。据说，<a href=\"http://cruisecontrol.sourceforge.net/\" target=\"_blank\">CruiseControl</a>、<a href=\"http://rubyworks.rubyforge.org/\" target=\"_blank\">RubyWorks</a>就是诞生自ThoughtWorks的实际项目。<br><br>ThoughtWorks最有价值的部分是人。和这样一群人一起工作，只要你把自己的想法抛出来，就会有人愿意与你讨论。相信大家都有类似的经验，很多时候，自己想一个问题很容易走进一个误区，而和别人稍微讨论一下，即便这个人的言论本身并不能给你带来太多的价值，但这个讨论的过程会让自己的思路逐渐清晰起来。ThoughtWorker们是一个巨大的思想来源，这样一群人之间的讨论经常会激荡出各种各样的火花。一个业余的例子是上周五下班之后，一群人玩编故事的游戏，其结果是包括周边的人在内，大家都已经乐得直不起腰了。<br><br>开源，需要一个环境。如果周围的人都在做开源，自己就会以为开源是一件理所当然的事情。列在公司开源网站上的项目，其实那只是一些比较知名的项目，也是冰山一角。平时，不经意间和某个人聊天，你就发现，原来身边的这个人正在做一个开源的东西。大家在一起讨论的时候，也经常可以听到这样的话，那就不妨开源一下试试。陶公子最近发起了一个<a href=\"http://www.javaeye.com/topic/191261\" target=\"_blank\">关于Domain Model的讨论</a>，我就对他说了类似的话。<br><br>公司内部有一个Innovation Community，也就是说，公司是鼓励大家进行创新的。经常会收到公司内部关于Innovation的邮件，介绍一些最近一段时间有人做的一些事情。其中很重要的一环就是一些ThoughtWorker新近发起的一些开源项目。gigix最近就在一次Innovation Community活动上，介绍了<a href=\"http://code.google.com/p/fluorida/\" target=\"_blank\">fluorida</a>。<br><br>如果一些开源项目能够证明自身的价值，公司也是愿意投入一些精力将它完善。<a href=\"http://selenium.openqa.org/\" target=\"_blank\">Selenium</a>和CruiseControl就是这样在ThoughtWorks的协助下，得到了快速的成长。当然，不只是公司员工的项目，对于一些其它有价值的项目，公司也会投入一定精力去做，比如Ruby和JRuby。<br><br>有了这样的土壤，开源也就变得自然而然。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200805122326",
    "date": "2008-05-12",
    "time": "23:26",
    "title": "客户来了",
    "tags": [
      "脚下的路"
    ],
    "body": "敏捷软件开发中，与客户的沟通是一项必不可少的内容，因为只有客户才知道他们自己想要的是什么，只有他们才真正了解自己的业务流程。于是，在ThoughtWorks，客户来访是很常见的，这不，我们的客户今天就来了。<br><br>一大清早，客户就到了办公室，他们给我们做了一个关于项目的介绍，让我们有机会聆听一下真正使用这个系统的人究竟如何看待这个系统，他们为什么会有这样的业务流程，在他们看来，哪些东西才是最有价值的部分以及他们希望这个系统未来会在他们的工作中起到怎样的作用。虽然在这个项目也工作了一段时间，但我也只是知道有哪些东西，对于为什么是这样，完全没有概念。今天客户的到来算是给我们补上了欠缺的一课。<br><br>对于开发者而言，客户到来的作用很直接的体现在某些细节问题的确定上。通常，我们有了问题会问我们的BA（业务分析师），但BA不能给出答案的部分，就只能等待客户的回答了。原本因为时差的关系，一旦涉及到客户，这个过程至少需要一天。而如今客户就在身边，一旦我们有了问题，几乎瞬间就可以得到解决，开发周期大大的缩短。当然，客户不会一直在这里，所以，趁着客户在的这几天，我们要充分发掘他们的作用。<br><br>以前也曾经历过客户到来，但这次给我留下的印象却特别深刻。因为，客户让我们近距离的接触到他们的业务。<br><br>我们的项目是一个关于宾馆审计的项目，简而言之，有人制定标准，有人按照标准进行检查。虽然听起来很简单，但是系统里面的概念却离我们很远，很难想象究竟是什么样子的。今天，客户就带着我们亲身体验了一下做审计的感觉。<br><br>我们去的是客户旗下的一家五星级宾馆，宾馆的总经理带着我们在宾馆内部进行参观，过程之中，还为我们解释了很多真正的检查过程中会出现的问题，在这个过程中，一个个曾经因为写程序而听说过的名词不断的出现在耳边，那个曾经遥不可及的概念，一下子变得异常清晰。上午的讲解和晚上的参观让这个系统变得更加真实了。以前只是住过宾馆，还从来没有从其他角度想过问题。今天的参观，明显是抱着“找茬”的心理。顺便说一下，我们的“审计”还真起到了一定作用，有人在宾馆的游泳池边上的宣传牌上发现了错别字。<br><br>客户到来，还有一个很直接的好处，那就是，给了我们一次team building的机会。即便单从这个角度说，我们也总是欢迎客户来访的。^_^\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200805052352",
    "date": "2008-05-05",
    "time": "23:52",
    "title": "最佳雇主",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p><a href=\"http://blog.csdn.net/programmer_editor/archive/2008/05/05/2392083.aspx\" target=\"_blank\">谁是最受程序员欢迎的雇主？</a><br><br>一篇关于最佳雇主的帖子，很高兴在里面看到了ThoughtWorks的名字。<br><br>很快，成为ThoughtWorker就要满一年了，这一年时间里，我一直享受着在ThoughtWorks工作的乐趣。确实，它和我之前工作的环境差别很大：开放的工作环境、没大没小的工作关系、不利于保持身材的零食、需要排队的游戏机等等。这段时间一直在考虑一个问题，对我而言，ThoughtWorks到底好在哪里。思来想去，我的答案是人文环境。<br><br>依然记得当年，我在当时的部门里发邮件尝试与大家讨论技术，应者寥寥；<br>依然记得当年，有人劝我放弃所谓新鲜想法，老老实实走在原来的道路上；<br>依然记得当年，有人对我说，只有做管理才有更大的价值，怎么你对管理一点兴趣都没有；<br>依然记得当年，我们把“以人为本”作为笑话来听；<br>……<br><br>我也依然记得，当年选择软件开发作为职业是因为热爱；<br>我也依然记得，当初遇到Darwin点燃了我对技术的热情；<br>我也依然记得，在本应完成一个功能的时间里完成整个系统重写的快感；<br>我也依然记得，修改别人留下的bug缠身的程序直至深夜；<br>……<br><br>用了自己职业发展的最初几年，我逐渐清晰了自己在职业发展路上的追求。我会努力走在自己预期的路上，如果环境不能再给予我所需要的，我会寻觅其它的环境。<br><br>在这里，我得以继续走在技术的路上；<br>在这里，身边有一群有想法的人，让讨论可以深入下去；<br>在这里，总有人能在不同的角度给你一些新鲜的东西，让我不得不偷偷去补各种各样的新知；<br>在这里，可以和有很多年的工作经验的人一起工作，学习他们解决问题的思路；<br>在这里，完成功能绝对不是开发的终点，大家总是竭尽所能让程序看上去更清晰；<br>在这里，关注用户价值会成为程序员也要思考的问题；<br>在这里，我有机会体验不同的角色；<br>在这里，我终于弄清楚了leadship和management不是一回事；<br>……</p><p>幸运的是，我坚持了自己的选择；幸运的是，我成为了ThoughtWorker。 </p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200804252116",
    "date": "2008-04-25",
    "time": "21:16",
    "title": "新项目，新体验",
    "tags": [
      "脚下的路"
    ],
    "body": "又到周末了，由于<a href=\"http://dreamhead.blogbus.com/logs/19475526.html\" target=\"_blank\">CodeJam</a>的原因，这已经是我连续第十二天的工作了，有些许疲惫。在这个即将到来的周末，要好好让自己放松一下。<br><br>这周开始了一个新的项目，一个Ruby on Rails的项目，一个让我期盼了很久的项目，也是我之前<a href=\"http://dreamhead.blogbus.com/logs/19324827.html\" target=\"_blank\">学习Rails</a>的最重要原因。不过，Rails是我最近的blog中出现频率很高的字眼，所以，我并不打算在这里聊Rails的话题。<br><br>既然不谈技术，那就不妨聊一些与自己之前做项目不同的体验吧！<br><br>在我们这里开发的准确的说是这个项目的第二阶段，也就是这个项目已经有了很多东西，之前这个项目是由美国那边的团队来做，所以，我得到了一个观察国外的ThoughtWorker如何做事的机会。原来参与过的项目里面，更多的是中国这边的ThoughtWorker，所以，我饶有兴致去观察一下二者之间的差异。由于参与这个项目的ThoughtWorker大多是有经验的开发者，所以，很多方面做得成熟许多。<br><br>这个项目的自动化程度很高，显然，这些ThoughtWorker在开发之初做了很多工作，把许多可以自动化处理的部分都放到的Rakefile里面。所以，我们得以把更多的精力放在开发本身上，少了很多繁琐的操作。一个简单的例子是，我们提交代码只要简单敲一个命令，首先会到SVN进行更新，然后重做数据库，运行测试，随后，把增加的部分找出来添加到SVN中，最后，它会问我们Pair的人，Story的编号，以及做了哪些工作，以便生成SVN提交的日志。和大多数自动化的工作一样，这些工作本身没有任何技术难度，但有了这些之后，我们可以少敲一些命令，更关注开发本身。其实，之前的几个项目也有一些自动化，比如用Cruise Control做持续集成，但这个项目应该是我经历过的自动化程度最高的项目，差不多常见的重复性工作都自动化了，看看那长长的Rake任务列表便可见一斑。<br><br>每天早上，Standup之后，我们会把所有的Dev召集到一起，一起来看一下昨天的工作。我们用SVN diff把代码的差异列出来，大家一起来过。如果恰好是自己做的代码，编写代码的人就会站出来，为大家简单解释一下做了些什么。这样，这样保证大家都会了解到项目的进展。这样做还有另外一个原因，因为我们是一个分布式团队，除了我们在中国这边，还有几个人在美国开发，这样过代码，便可以大致了解到美国那边在我们睡觉的时候干了些什么。<br><br>这个项目还有一个做得我觉得不错的地方，就是Story做得很细致。我们在Mingle里面的Story，很多都会有完成这个Story要做哪些步骤的描述。我们只要按照这些步骤一步步做下去就可以了，每完成一个步骤，就做一个简单的标记，这样，几乎不会有遗漏。除了Mingle上的Story，我们还会有专门的文档对这个Story进行比较详细的解释，包括一些验收条件。显然，这个项目的BA做了大量的工作，让我们后续的开发更容易。<br><br>这个项目从美国过来了一个BA和两个Dev，而Pair的过程，让我不得不每一天都以英语进行交流。私下里，我经常说，我的英语水平代表了TW的最低水平。当年面试的时候，我自认为表现的最差的就是结对编程，因为一个英国同事高高兴兴搬了把椅子做在我边上，害得我不得不英语解释我在做什么，思路一下子就乱了。不过，少了面试的压力，这时候和人用英语Pair，效果还算可以接受，至少我还可以思考。实在不理解的，就让自己的Pair多解释几次，好在ThoughtWorker们都是很好的人，我的Pair总是不厌其烦的为我解释，直到我确切的直到了我们要干什么。<br><br>在这个项目里面，我很高兴的扮演起学生的角色。一方面，我们不是很了解需求，需要向“过来人”学习，另一方面，来这边工作的两个Dev确实都有很长时间的工作经验。和他们在一起工作，我乐得把控制权交到他们手上，自己虚心的观察他们如何思考，如何解决问题。和他们在一起工作，会让人感觉很放心。正如我在《<a href=\"http://dreamhead.blogbus.com/logs/13258146.html\" target=\"_blank\">与高手共事</a>》中提到的，他们做的那些工作都很简单，经过一步步简单的工作，一个个Story就完成了。<br><br>对我来说，这个项目才开始一个星期，已经学到了不少的好东西，值！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200804211724",
    "date": "2008-04-21",
    "time": "17:24",
    "title": "ThoughtWorks CodeJam",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>周末没得闲，因为参加了一次CodeJam。<br><br>CodeJam，是公司组织的一个编程活动，就是要在周末两天时间内开发出一个东西，据说此类的活动在其他的办公室举办过。这是我第一次参加类似的活动，参加这次活动的Dev都是公司内比较优秀的程序员，平时很难把这些人都放到一个团队里面，有机会和这些人在一起工作，本身就是一件令人期待的事。<br><br>这次活动的目标是为一个支援乡村教育的组织开发一个分享平台。在活动开始之前，我们对需求一无所知，所以，几乎就是看两天内能够写出多少东西。因为这个项目要开发的是一个Web应用，从生产率的角度来看，我们当仁不让的选择了Rails作为开发工具，这也是我最近在<a href=\"http://dreamhead.blogbus.com/logs/19324827.html\" target=\"_blank\">学习Rails</a>的原因之一。<br><br>万事开头难，这次CodeJam也不例外。在一群Dev准备甩开膀子大干一场的时候，我们发现了一个问题，没有需求。需求，是<a href=\"http://blog.nona.name/\" target=\"_blank\">冰云</a>（BA）和<a href=\"http://qihuiqihui.spaces.live.com/\" target=\"_blank\">QQ</a>（QA）在之前一天和我们的客户谈好的。QQ在离开办公室之前，把从需求整理出的Story卡片锁到了自己的抽屉里，结果，第二天，她闹肚子了。好在冰云临危不惧，顶着我们的巨大压力，把部分Story重写了出来。直到QQ重新归队，打开宝箱，需求问题才得到了彻底的解决。<br><br>正式开工，场面那是相当壮观。一群ThoughtWorker，一群快手，一帮人抢着提交代码。做用户登录部分的高喊着，他们应该是第一个提交数据库表的，结果，更新代码时，已经有了数据库版本已经到了3。那是我和WPC干的，因为我们俩负责搭建开发环境，所以，先下手为强了。不过，我们高兴得有些过，用scaffold生成的代码出现了一个拼写错误。这时我们才发现，修改这些生成代码是多么痛苦的一件事。<br><br>在这里，我们用的典型的ThoughtWorks工作方式，一对Pair，拿到一张Story卡，然后，小步前进：测试、编码、重构、提交。正是因为步幅很小，所以，就出现了大家争抢着提交代码，因为稍微慢一点，就会更新下来一片代码，这种时候，便要重新运行测试。运气不好的话，破坏了别人的测试，还要帮别人修复。其实，在一个大的开发团队中，这种现象很常见，尤其是测试多到不能很快运行完，比如有集成测试的时候，常常是运行测试之后，又来了新代码。<br><br>典型的ThoughtWorks工作方式，还有另外一个含义。一群人一边写着代码，一边互相开着玩笑。在我的印象中，ThoughtWorks开发团队从来就不缺少笑声。其实，这次参加CodeJam的人，有很多我并没有直接在一起工作过，所以，这也是一个很好的了解大家的机会。比如，在我的印象中，WPC一直是闷着头写代码的家伙，和他Pair才知道，他原来也是那么有才，可以让人笑得肚子疼。至于像<a href=\"http://www.blogjava.net/raimundox/\" target=\"_blank\">徐X</a>和<a href=\"http://gigix.thoughtworkers.org/\" target=\"_blank\">gigix</a>这种平日里就给大家很多欢乐的家伙（也许也包括我自己）就更不用说了。当然，也有比较安静的，<a href=\"http://hl.thoughtworkers.org/\" target=\"_blank\">亮亮</a>和来自加拿大的<a href=\"http://www.rickylui.com/blog/\" target=\"_blank\">Ricky</a>被我评为“最安静的Pair“。<br><br>两天下来，从无到有，一个具备基本功能的网站就建立了起来。showcase的时候，看着这个小网站，心里还是很有一丝满足的。对我而言，这是我第一次做Rails项目，第一次尝试用TextMate去开发。</p><p>这次CodeJam，是在公司内部进行的，希望将来有机会把这个面扩大一些，让其他公司的人来和我们一起来做，一方面我们可以从其他人身上学习到一些东西，另一方面，也让别人了解一下ThoughtWorks是如何工作的。我相信在如何进行软件开发这个问题上，ThoughtWorks做得足够好。</p><p><strong>UPDATE</strong><br>其他的ThoughtWorker也有对这次活动发表了自己的看法。<br>冰云：<a href=\"http://blog.nona.name/200804274.html\" target=\"_blank\">Beijing Code Jam - 2 days agile development project</a><br>Ricky：<a href=\"http://www.rickylui.com/blog/2008/04/20/codejamthoughtworks-beijing/\" target=\"_blank\">CodeJam@Thoughtworks Beijing</a></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200804181729",
    "date": "2008-04-18",
    "time": "17:29",
    "title": "Rails初印象",
    "tags": [
      "我眼看世界"
    ],
    "body": "是的，我在学习Rails。<br><br>我所了解到的，大多数人是因为Rails而学习Ruby，像我这种了解Ruby却对Rails一窍不通似乎是异类。道理上来说，传统的途径应该是先学语言，再去了解相关的开发框架，像Rails这样喧宾夺主的情况，也算是异类了。当然，也正是因为Rails的喧宾夺主，才让人们有了更多的机会认识Ruby，了解Ruby的优雅。<br><br>趁着我还不那么了解Rails，把Rails留给我的初印象记录在这里，算是一个初学的记录。<br><br>Convention over Configuration（CoC），这是Rails广告给我留下的最深印象。这是一种改变业界对软件开发认知的思想。如同Spring让我们认识了Dependency Injection（DI），进而改变了我们的设计方法。Rails让我们认识到，原来有时候程序设计并不需要那么灵活。一片惊呼之后，效仿者蜂拥而至，人们纷纷尝试把这个想法带到自己熟悉的平台，其场面与Spring当年带来的DI容器热如出一辙。<br><br>如果Spring只有DI，它并不会带来真正的变革，同样，Rails也不是只有CoC。在我看来，CoC之外，Rails还集成了Web开发的实践。<br><br>Web开发实践有哪些？首当其冲的自然是MVC的架构，所以，在Rails中，明明白白的在目录结构上就把MVC分得清清楚楚。不过，我们还是抛开MVC这种路人皆知的答案，看一些具体的东西吧！<br><br>用Java写Web方面的应用时，我最担心的问题是如果一不小心上了某个框架的贼船，比如Servlet，结果就是为了看到自己程序能够正确运行，不得不把应用部署到服务器上。一旦出现了问题，解决问题就变成了一个非常低效的过程，因为我们不得不一次又一次的进行部署，大好的年华便随风而逝了。所以，对我而言，做Java应用的设计时，一个指导性原则就是尽量不依赖于任何框架，这样，就可以把真正的逻辑剥离出来进行测试了。初涉Rails，我也有类似的疑问。但我发现，原来Rails框架本身已经替你考虑好这个问题，它把测试的考虑也内建到框架之中，这样便可以很容易的针对每个Controller编写测试，而又不必理会部署的消耗。<br><br>Rails在测试方面有很多的考虑，它清楚的分出为Model而写单元的测试，为Controller而写的功能测试和跨越Controller的集成测试，而Fixture这个概念的存在，让我们很好解决测试数据的问题。这一切实际上都是一些优秀的软件开发实践。实际上，像这样的实践，Rails开发框架中还有很多，比如，如何处理页面布局、如何使用Ajax、如何管理数据库的迁移、如何让自己的应用Restful等等。使用Rails，不经意间，我们便可以走上一条正确的路。同许多开发实践一样，单独来看，这些做法本身并看不出多大的价值，但放到整个软件开发过程之中，便可以极大的提高开发生产率，尤其是在后期维护阶段。<br><br>不同于之前用过的一些框架，需要在实践中摸索正确的用法，Rails是第一个让我强烈的感受到开发实践内建其中的框架。只要走在Rails的道路（Rails Way）上，那么无论如何都不会偏离正确的方向太远。正确的道路何在？不得不提起《Agile Web Develpment with Rails》（中文版《Web敏捷开发之道》）。技术，常常是养在深闺无人识。其实，这个世界上一点都不缺好的想法，好的做法。我们经常会看到一些新东西让我们感慨，原来还可以这么做，但是，大多数时候，我们并不知道这些东西的存在。这本书的出现，恰到好处的向人们展示了Rails的优秀，比如前面提到的那些实践。不同于很多板着面孔教育人的计算机书，这本书轻松愉快的把一个完整的开发过程展现在人们面前。大多数人几乎是同时认识这本书和Rails框架的，所以，几乎一开始，Rails一族便走在正确的道路上。<br><br>不过，Rails还很年轻。年轻的结果就是不稳定。《Agile Web Develpment with Rails》第一版和第二版之间号称有70%的变动，而Rails 2.0又让第二版中的程序遭遇起步停车，一开始便会有差异。有些时候，这会打击初学者的积极性，也会让希望采用Rails的企业望而却步。<br><br>这便是我对Rails的初印象。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200803280844",
    "date": "2008-03-28",
    "time": "08:44",
    "title": "半路出家",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>不知道算是幸运，还是不幸，我参与的多数项目，如果不是从头开始，我也是最开始加入的几个人之一，所以，我通常对项目的来龙去脉都比较清楚。这次，我有机会尝试一下在一头雾水的情况下开始一个项目。<br><br>这个项目已经进行了超过一个月，因为客户需要在赶在最近的一次发布之前，增加一些功能。老板按照目前的进度估算了一下，如果不加人，这个任务很难完成，于是客户很合作的同意增加两个人。就这样，我成了临时工。事实上，在这个阶段进入，项目早就过了最初的阶段，远远望去，没有几百也有几十的程序文件屹立在那里。虽然有最熟悉项目的人为我们介绍了项目的背景和架构，但这些宏观层面上的东西，对于编写代码这样“微观”的操作而言，几乎是没有任何直接的帮助。作为一个新人加入到项目，除了发呆，我还能做什么呢？<br><br>回想在以前公司的情形，大多数新进项目的人多半是得到一大堆文档，然后，有人语重心长的说，先把文档看了吧！且不说这些文档这种东西几乎写出来就过时，单单读完这些文档就需要花费很多时间。运气好的话，还有代码可以对应，但千万不要指望你能够一下子读懂这些代码。也许，你会想找别人来问，如果不出意外，大多数人都会不明就里的非常忙，忙到有时间上网聊天却没有时间给你讲这些东西。事实上，很多人即便自己做了很多东西，也不一定能够清晰的描述出来，所以，即便找到一个“闲”人，成功从他那弄明白这些东西的概率也很低。其结果是，我们经常会看到一些人在那对着电脑上的文档发呆。<br><br>在ThoughtWorks，我也恨不得找到一堆这样的无聊文档来打发时间，以此来享受偷懒的时光。遗憾的是，完全没有这种机会。因为那些“文档”会被视为浪费，这在以消除浪费为己任的敏捷来看，是无论如何不能接受的。于是，我在找不到任何借口的情况下，进入项目的第一天，就开始写程序了。不了解项目，怎么写程序？这是个问题。<br><br>敏捷实践中，有一个叫做Pair Programming的，从字面上来看，就是两个人一起开发。对于ThoughtWorker们来说，Pair是一种常态。所以，我在开发时也会有一个Pair，虽然我对项目一头雾水，但我的Pair已经在这个项目上工作了很长一段时间，所以，他很清楚这个项目的一切，差不多一切，因为代码是集体所有，所以，他在开发过程中会接触到各个部分。<br><br>拿到我们要做的Story，我的Pair会结合这个Story给我介绍上下文，并结合代码大致描述一下我们要做的事情。虽然在这个项目上我是新手，但我并不是对编程一无所知。有了这些基本的信息，我至少对我们要做什么，以及如何来做，在心里已经形成了一个大致的印象。刚开始时，基本上是我的Pair在主导开发，一边做一边告诉我，我们已经走到了哪里。渐渐的，我已经对我们在做的代码有了一些认识，开发也开始由一个人主导转向两个人讨论。随着开发的深入，我也发现了现有做法的一些不足，于是，我提出对代码进行重构，并给出了自己的分析和建议。我的Pair在听了之后，认为这是一个可行的建议，于是，我们毫不留情的将那段大家看着不舒服的代码改掉，这段代码从此清净了。<br><br>这就是在加入项目前几天所做的事情，虽然我目前还不能对整个项目有个很好的把握，但是，我相信，我已经开始在这个项目中起作用了。我想，Pair Programming是主要原因。正如前面所说，虽然我对项目很无知，但我的Pair很好的弥补了我的不足。正是两个人的协调工作，让我可以在对项目没有完整认识的情况下，可以很快入门，以最快的速度融入到开发之中。</p><p>曾几何时，我对Pair Programming的认识还停留在大家一起写程序和知识分享上，原来它对半路出家的人帮助也很大。虽然《<a href=\"http://www.douban.com/subject/1102259/\">人月神话</a>》教导我们说，加人起不了很大的作用，但Pair的方式至少可以在相当大的程度上发挥新人的价值，削弱加人带来的负面影响。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200803252225",
    "date": "2008-03-25",
    "time": "22:25",
    "title": "程序设计语言的表达——内部DSL",
    "tags": [
      "向上走"
    ],
    "body": "<a href=\"http://www.infoq.com/cn/articles/internal-dsls-java\" target=\"_blank\">使用Java实现内部领域特定语言</a><br><a href=\"http://media.pragprog.com/titles/twa/martin_fowler.pdf\" target=\"_blank\">One Lair and Twenty Ruby DSLs</a><br><a href=\"http://martinfowler.com/dslwip/InternalOverview.html\" target=\"_blank\">Implementing an Internal DSL</a><br><br>上面几个文章都是关于DSL的，不过，在这里，我并不是太关心DSL的话题，我更感兴趣的是代码的写法。按照这几篇的分类方法，直接用程序设计语言编写的DSL算是内部DSL，也就是说，所谓内部DSL，也就是一种标准的程序代码。<br><br>Kent Beck在他的《<a href=\"http://www.douban.com/subject/2042269/\" target=\"_blank\">Implementation Patterns</a>》的第三章《A Theory Of Programming》中，谈到了编程的价值观（Value）：Communication（沟通）、Simplicity（简单）和Flexibility（灵活）。如果说简单和灵活很容易理解的话，那么把沟通放在价值观中，尤其排在所有价值观的第一位，则显现出Kent Beck对于编程的深刻。在这个软件开发越来越需要协作的年代，写代码的时候，多站在让别人理解的角度考虑一下，会极大提升代码的可读性。在ThoughtWorks的招聘流程中，有一个Code Review的环节，拜这个环节所赐，我看过很多人的代码，不在少数的应聘者其代码唯一的优点就是完成了需求。以沟通为标准进行衡量，这显然是不够的。<br><br>同样，以沟通为标准，那么内部DSL显然在这方面做得更好，因为DSL本身就是为了让人更容易理解而存在的。这几篇文章中提供了很多内部DSL的手法，比如<a href=\"http://martinfowler.com/dslwip/MethodChaining.html\" target=\"_blank\">Method Chaining</a>、<a href=\"http://martinfowler.com/dslwip/ExpressionBuilder.html\" target=\"_blank\">Expression Builder</a>等等。抛开DSL这样的BuzzWord，这些方法应该属于增强程序本身表达能力的方法。<br><br>JDK有一个很好的Method Chaining的例子：StringBuffer的append方法。<br><br>StringBuffer sb = new StringBuffer();<br>sb.append(\"log1\").append(\"log2\").append(\"log3\");<br><br>这样的写法显然比下面的写法更为简洁，尤其是需要往StringBuffer中添加很多内容的时候。<br><br>StringBuffer sb = new StringBuffer();<br>sb.append(\"log1\");<br>sb.append(\"log2\");<br>sb.append(\"log3\");<br><br>在我看来，这些内部DSL技术为我们打开了一扇窗，它让我们在编写代码，尤其作为API提供的代码时，有了一个新的思考方向。当然，并不是一味的应用这些内部DSL技术就会写出好代码，作为一个有经验的软件开发人员，我们需要一定的鉴别能力，分辨出究竟怎样做才会真正的提高代码的“沟通”能力。<br><br>之前写过两篇关于程序设计语言表达的blog（<a href=\"http://dreamhead.blogbus.com/logs/3252068.html\" target=\"_blank\">1</a>、<a href=\"http://dreamhead.blogbus.com/logs/10692436.html\" target=\"_blank\">2</a>），虽然这篇不像那两篇一样讨论语言的差异，但也算是在语言表达能力上的探讨吧！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200803111655",
    "date": "2008-03-11",
    "time": "16:55",
    "title": "Hello, Weka",
    "tags": [
      "向上走"
    ],
    "body": "<p>Weka，是一个用Java编写的数据挖掘软件。数据挖掘，从字面上来看，它是一个从数据中找寻有用信息的过程，不过，它涉及的内容很多，所以，这里借用“分类”这一面来说事。<br><br>分类，从名称上来看，再简单不过了，给你一样东西，给它分个类。你如何知道怎么分类呢？显然，这是基于你已有的经验。对于计算机而言，这种经验从何而来呢？只有让人来告诉它，也就是说，我们要拿一批数据训练计算机，经过训练的计算机，便具备了一定的识别能力，就可以完成一些简单的分类工作。现实中，可以用到分类的机会有很多，比如我之前，曾经参与过的一个项目就是用这种方法来做车辆的识别。<br><br>下面便是一段使用Weka完成一段分类程序。<br><br>import weka.classifiers.Classifier;<br>import weka.classifiers.bayes.NaiveBayesMultinomial;<br>import weka.core.Attribute;<br>import weka.core.FastVector;<br>import weka.core.Instance;<br>import weka.core.Instances;<br>import weka.filters.Filter;<br>import weka.filters.unsupervised.attribute.StringToWordVector;<br><br>public class Main {<br>&nbsp; private static final String GOOD = \"G\";<br>&nbsp; private static final String BAD = \"B\";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; private static final String CATEGORY = \"category\";<br>&nbsp; private static final String TEXT = \"text\";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; private static final int INIT_CAPACITY = 100;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; private static final String[][] TRAINING_DATA = { <br>&nbsp;&nbsp;&nbsp; {\"Good\", GOOD},<br>&nbsp;&nbsp;&nbsp; {\"Wonderful\", GOOD},<br>&nbsp;&nbsp;&nbsp; {\"Cool\", GOOD},<br>&nbsp;&nbsp;&nbsp; {\"Bad\", BAD},<br>&nbsp;&nbsp;&nbsp; {\"Disaster\", BAD},<br>&nbsp;&nbsp;&nbsp; {\"Terrible\", BAD}<br>&nbsp; };<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; private static final String TEST_DATA = \"Good\";<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; private static Filter filter = new StringToWordVector();<br>&nbsp; private static Classifier classifier = new NaiveBayesMultinomial();<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp; FastVector categories = new FastVector(); <br>&nbsp;&nbsp;&nbsp; categories.addElement(GOOD);<br>&nbsp;&nbsp;&nbsp; categories.addElement(BAD);<br><br>&nbsp;&nbsp;&nbsp; FastVector attributes = new FastVector();<br>&nbsp;&nbsp;&nbsp; attributes.addElement(new Attribute(TEXT, (FastVector)null));<br>&nbsp;&nbsp;&nbsp; attributes.addElement(new Attribute(CATEGORY, categories));<br><br>&nbsp;&nbsp;&nbsp; Instances instances = new Instances(\"Weka\", attributes, INIT_CAPACITY);<br>&nbsp;&nbsp;&nbsp; instances.setClassIndex(instances.numAttributes() - 1);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; for (String[] pair : TRAINING_DATA) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String text = pair[0];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String category = pair[1];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instance instance = createInstanceByText(instances, text);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instance.setClassValue(category);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instances.add(instance);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; filter.setInputFormat(instances);<br>&nbsp;&nbsp;&nbsp; Instances filteredInstances = Filter.useFilter(instances, filter);<br>&nbsp;&nbsp;&nbsp; classifier.buildClassifier(filteredInstances);<br><br>&nbsp;&nbsp;&nbsp; // Test<br>&nbsp;&nbsp;&nbsp; String testText = TEST_DATA;<br>&nbsp;&nbsp;&nbsp; Instance testInstance = createTestInstance(instances.stringFreeStructure(), testText);<br><br>&nbsp;&nbsp;&nbsp; double predicted = classifier.classifyInstance(testInstance);<br>&nbsp;&nbsp;&nbsp; String category = instances.classAttribute().value((int)predicted);<br>&nbsp;&nbsp;&nbsp; System.out.println(category);<br>&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; private static Instance createInstanceByText(Instances data, String text) {<br>&nbsp;&nbsp;&nbsp; Attribute textAtt = data.attribute(TEXT);<br>&nbsp;&nbsp;&nbsp; int index = textAtt.addStringValue(text);<br><br>&nbsp;&nbsp;&nbsp; Instance instance = new Instance(2);<br>&nbsp;&nbsp;&nbsp; instance.setValue(textAtt, index);<br>&nbsp;&nbsp;&nbsp; instance.setDataset(data);<br><br>&nbsp;&nbsp;&nbsp; return instance;<br>&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp; private static Instance createTestInstance(Instances data, String text) throws Exception {<br>&nbsp;&nbsp;&nbsp; Instance testInstance = createInstanceByText(data, text);<br>&nbsp;&nbsp;&nbsp; filter.input(testInstance);<br>&nbsp;&nbsp;&nbsp; return filter.output();<br>&nbsp; }<br>}<br><br>这个程序分成两个大部分，前半部分用以训练分类器，后半部分则是测试这个分类器。<br><br>训练分类器，我们要做的包括，选择分类算法和准备训练数据。在Weka中，每一种分类算法都是Classifier的一个子类，这样的话，就可以在不改变其它部分的情况下，很容易的修改分类算法。<br><br>其实，稍微了解一下这方面的知识的人，都会知道，分类算法固然重要，但真正决定一个分类器本事大小的，是用以训练的数据。想要得到一个好的分类器，少不了不断调整训练数据和不断的训练。这同人类认识问题是一样的，经得多，见得广，才有更好的分辨能力。</p><p>在Weka中，用以训练的数据就是Instances，顾名思义，这是Instance的复数，显而易见，单独的一个训练数据就是Instance，而Instances这个类的存在，可以把Instance的一些公共的属性放到一起。在这里，我们可以看到，为了用文本作为训练数据，我们会把文本转换为Instance。同样，测试分类器的时候，我们也会把文本转换为一个Instance，然后再进行分类。<br><br>除此之外，这里还有一个Filter的概念，同常见的filter概念类似，它给了我们一个进行正式处理之前，对数据进行处理的机会。在这里，主要是对Instance做一些相关的变换。<br><br>当我们得到一个分类器之后，就可以利用这个分类器进行分类了，其中，最关键的代码是<br>&nbsp;&nbsp;&nbsp; classifier.classifyInstance(testInstance);<br>这段代码返回的是根据分类算法计算结果得到的一个相似度，我们可以利用这个值来估计我们测试用的数据应该属于哪个分类。<br><br>从代码上来说，这段代码本身并不复杂。正如前面所说，一个好的分类器是需要让数据帮忙的。所以，换几个测试数据，你就会发现，这段代码中实现的分类器一点都不强大。如果希望它强大起来，扩展训练数据是一个必然的结果。不过，对于这篇blog而言，这不重要，因为我们只是要和Weka问个好，进一步的工作，还需要进一步的努力。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200803062344",
    "date": "2008-03-06",
    "time": "23:44",
    "title": "Fluorida 0.0.1发布了！",
    "tags": [
      "flex"
    ],
    "body": "<a href=\"http://code.google.com/p/fluorida/\" target=\"_blank\">Fluorida</a>是一个Flash的功能测试工具。如果你听说过<a href=\"http://selenium.openqa.org/\" target=\"_blank\">Selenium</a>，那么可以把Fluorida理解为它对应的Flash版本。<br><br>前不久，<a href=\"http://gigix.thoughtworkers.org/\" target=\"_blank\">gigix</a>对我说，他打算做一个Flash的功能测试工具。我说，从语言的角度来说，我不喜欢Action Script，因为它缺乏美感，但我喜欢这个方向，所以，我觉得这件事靠谱。<br><br>上周末的Open Party，听了<a href=\"http://michael.nona.name/\" target=\"_blank\">Michael Chen</a>一个关于Rich Client的session，顺便清理了一下关于Rich Client发展的思路。C/S年代，最大的问题在于部署，升级起来很困难，进入到B/S年代，浏览器的广泛存在解决了部署的问题，不过，简单的页面表现力受到了极大的限制，所以，才有Ajax这样技术的流行。把部署和UI表现力一下子都解决了，那么服务器和客户端的威力就可以得到极大的提升。显然，一些公司看到了这方向，比如MS，它们祭出了Silverlight，不过，从目前的状况来看，在这个领域的领跑者无疑是Adobe的Flash。因为几乎所有拥有浏览器的计算机都安装了Flash Player，这是一个压倒性的优势。<br><br>最初的Flash，是为设计者而存在的，所以，谈到Flash，人们首先想到的是“炫”，显然，这不是程序员的强项，所以，大多数开发人员并不会和Flash太亲近。<a href=\"http://www.adobe.com/\" target=\"_blank\">Adobe</a>认为Flash应该扮演更重要的角色，比如成为前面提到的新一代C/S结构的领军人物，但是，想做到这一点，必然需要大量开发人员的支持，所以，Adobe不断的让Flash进化着，比如，Action Script从2到3，发生了巨大的变化，用Action Script 3加入了面向对象，用它写程序，感觉和用通常的程序设计语言并无二致。Adobe甚至更近一步推出了<a href=\"http://www.adobe.com/products/flex/\" target=\"_blank\">Flex</a>，实际上，它就是为开发人员提供的Flash。再在Eclipse的基础上，打造出Flex Builder，所有这一切都是为了亲近开发人员。<a href=\"http://www.adobe.com/products/air/\" target=\"_blank\">Adobe AIR</a>的推出，让Adobe在这方面野心显现无疑。可以看到的是，Adobe的脚步并未停止，它还打算<a href=\"http://www.javaeye.com/news/1305\" target=\"_blank\">让更多的语言运行在Flash上</a>，显然，它们要提供的是一个新的平台，用以抗衡.NET和Java。<br><br>站在开发者的角度，我们更关心怎么让自己的开发工作更舒服一点。作为一个ThoughtWorker，没有测试的日子是让人难以忍受的。在之前的一个进行Flash开发项目中，FlexUnit成功填补了Flash开发拼图的单元测试框架这块，而功能测试这块却一直没有很好的做起来，有人尝试过FunFX，但总觉得不爽。<br><br>当gigix要写一个Flash集成测试工具的时候，我知道，参与过Selenium开发的他，对于功能测试应该是什么样子，心里应该很有数。事实就是这样，从接口上来看，Fluorida与Selenium如出一辙。<br><br>欢迎任何对这个项目感兴趣的人加入，0.0.1意味这个项目中有许多事可做，你可以给出你的建议、意见或是代码，甚至你觉得这个项目的名字不好也可以建议修改。因为这个项目最开始叫做Fluorine，由于与一个Remoting框架相同，gigix把它改成了现在的Fluorida。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200803032330",
    "date": "2008-03-03",
    "time": "23:30",
    "title": "出门在外",
    "tags": [
      "脚下的路"
    ],
    "body": "俗话教导我们，在家千日好，出门一日难。<br><br>最近，因为工作需要，我有一段时间没有在自己办公室，而是在客户现场。按说，在那里，人家对我们客客气气的，尽可能帮助我们解决遇到的问题，而且，一般这种情况下，都是吃得好喝得好的，应该没有什么不舒服的。但是，无论如何，这些日子总是让人感觉很不爽。今天临下班的时候，当大家决定明天都回公司的时候，项目组的同事们几乎欢呼起来。<br><br>无论是在西安，还是在北京，甚至是在班加罗尔，只要是在ThoughtWorks的办公室，我都是感觉很放松，因为我是这里的人，在这里，我可以肆无忌惮。到了客户现场，下意识就会绷紧一根弦，无论说什么做什么都要小心翼翼，毕竟在外面，无论你愿意不愿意，你都代表着公司形象，为了不给公司丢脸，做什么都要经过一下大脑。所以，我觉得在客户现场，即便一天什么都不做，都会觉得很累。<br><br>其实，我早就知道，在别人的地盘不好玩。离开东软之前的最后一年，我就是被发配到北京的一家公司，进行现场的开发。按理说，那的物质条件比东软要好很多，而且，经常有机会参加那里组织的活动。但那一年，是我最为压抑的一年。在那里，虽然从来没有人故意另眼相待，但我总觉得自己不属于那里，虽然在那里工作将近一年的时间，却从未真正融入那里的圈子。或许，这种心灵上没有归属感坚定了我离开东软的信念吧！<br><br>我还听说过另一个关于在外工作的故事。我之前工作的一个部门，派了很多人到美国去做开发。在很多人看来，这些人有机会出国，而且拿着相对较高的补助。而事实是，那些去之前对美国无限向往的家伙，从美国回来之后，都对彻底那里失去了兴趣，甚至闻之色变。当然，这其中有很多故事。<br><br>总而言之，在外不如在家好。无论如何，明天要回办公室了！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200802221504",
    "date": "2008-02-22",
    "time": "15:04",
    "title": "起步的台阶",
    "tags": [
      "我眼看世界"
    ],
    "body": "我的程序人生是从微软的技术起步的。虽然那时已经是Windows的年代，但是目光的局限，让我依然还是在DOS上下了一些功夫。也是因为从DOS出发，后来顺理成章的进入了Windows开发的行列。那时候的我是很努力的，不断的探索着各种各样的技术实现，不断的阅读着各种各样的书刊杂志，也着实记住了一些所谓的技术。不过，有个问题一直困扰着我，我觉得自己记住的只是一些形，而非神，这些形的东西是很容易忘记的，所以，我一直觉得自己并没有真正的理解编程，我甚至一度怀疑适不适合做开发。<br><br>真正让我开始觉得心里踏实是以程序员为职业之后。我的职业之路起步于Java，做的是服务器端的开发。跨平台的Java让我的目光不在局限于微软的平台，而服务器端的开发，让我有机会更加关注软件设计本身，而并非花哨的表现形式。随着开发越做越多，我逐渐开始摸索到了一些共性的东西，对自己的程序人生充满了信心。<br><br>走不同的路，得到的结果差异会很大。从上面提到的我个人的经历反映出在不同的技术社区内的不同倾向。记得有人说过，微软社区更倾向于探究底层实现，而Java社区更关注设计架构。其实，差别并不只这些，比如，微软的技术社区倾向于追踪新技术，因为几乎差不多每隔几年，微软就要把自己的东西推翻了重来，从DOS到Windows，再到.NET的变化，而Java社区的人则是在一个稳定的基础上不断的发展。微软是为了商业上的发展，所以，它要不断推陈出新，而Java也有变化，比如EJB到without EJB，但决定因素多半是技术上的，而非商业上的。<br><br>如我前面所说，微软社区有很多人关注的是一些细节上的实现，所以，造成的结果是他们不得不在茂密的技术丛林中不断摸索，而无暇顾及其它。我们公司内部，有一个技能列表，上面记录着哪些人会哪些东西，比如Java、.NET、Ruby等等，这样方便做项目时进行资源调配。其中有一个有趣的现象，只拥有一项技能的开发人员大多都属于.NET阵营。而Java阵营的人，经过最初的探索，会发现原来自己学到的东西是可以用在很多其它的地方，于是他们的触角开始伸向其它地方，比如JavaEye这个以Java命名的网站上会有很多关于Ruby的讨论、关于函数式编程的讨论、关于Erlang的讨论，这些东西少有会对Java开发本身产生直接的帮助。<br><br>如果已经从最初的阶段突围而出，或许，这些差异并不重要，因为我们做事靠的是自己的方法和一些共性的东西。但对于刚开始成为程序员的人来说，并不知道这些差别的存在，一个人的见识有限时，他会认为自己见到的就是整个的世界，就像我刚开始编程那会儿。<br><br>其实，我觉得最适合编程起步的应该是Unix开发。这些年里，很多出自贝尔实验室的书，比如《Unix编程环境》、《程序设计实践》、《C程序设计语言》等等都是在探索软件开发本质的书，而Unix的诞生地正是贝尔实验室。Eric Raymond写过一本《Unix编程艺术》，品味之下，便不难发现，许多随着Unix而生的是做事的方法，而这些方法并不是把人限制在Unix这个具体的平台之上，而更多的是一种通用的软件开发理念，拥有了这些理念，即便进入了一个陌生的领域，只要稍加学习，从前的感觉便会回到身边。<br><br>起步固然重要，不过，即便起步并非一帆风顺，如果抱有一个开放的心和一个思考的大脑，最终，都会走上同样的开发之路。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200802141734",
    "date": "2008-02-14",
    "time": "17:34",
    "title": "回到工作中",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>休完了春节长假，回来上班了，整个人懒洋洋的，长假结束之后的正常反应。我给自己定下假期基调就是，尽可能让自己的脑子不去想太技术的东西，也算给大脑放一个假，所以，恢复到正常的工作状态，还需要调整一下，呵呵。<br><br>假期里，看了《<a href=\"http://blog.csdn.net/hitetoshi/\">疯狂的程序员</a>》。以前，很爱看这种程序员的故事，尤其刚刚开始学习编程的时候，特别想了解一下别人是怎么一步一步提高的，因为那时候，我并没有体会到真正做个程序员是怎样的感觉，于是，总是希望可以从那些故事里面得到一些值得借鉴的地方。可以说，这种故事中体现的那种激情是鼓励着我不断前进的动力。如今，我做程序员已经开始奔向第六个年头，逐渐有了一个相对清晰的发展方向，做一个程序员的酸甜苦辣也品尝了不少。如今，再看这种程序员拼搏的故事，更多的是为了怀念一下自己的青涩年代。</p><p>虽然，彼此的故事不同，但初学编程时那种努力、那种奋进是相同的。还记得刚开始工作的时候，我硬生生的照着协议写出一个SMTP的实现，所有的代码都放到一个文件里面。现在，依稀记得成功把一封邮件发送出去的时候，自己那种激动的心情，用我现在的说法形容，那时候的我，生猛。随着工作经验增多，做事更多的是在找最短路径，如果现在再让我去实现一个SMTP，我笃定是找一个已有的实现。青涩的自己，虽然很笨，却是最有干劲的，也是那时候培养出对程序的激情和热爱，让我可以在程序设计这条路上不断走下去。<br><br>刚刚回来，看到一个<a href=\"http://openjdk.java.net/projects/mlvm/\">Da Vince Machine</a>的项目，简而言之，为JVM增加更多的功能，主要是为了支持动态语言的特性。虽然并非这个项目的所有内容都会最终进入JVM，但它确实是一个有益的尝试。<br><br>其实，这个项目算不上新项目，关注这个项目领导者John Rose有一段时间了，因为他为在JVM上增加动态语言特性做了很多工作。之所以注意到这个项目，是因为<a href=\"http://www.infoq.com/news/2008/02/Da-Vinci-and-the-DLR\">InfoQ的一篇报道</a>。这篇报道中，不仅仅提到了JVM，还提到DLR。</p><p>从文章的叙述来看，DLR是建立在CLR之上的。这种做法给我的感觉是，它类似于XRuby的做法，在JVM上自己建立运行时。虽然不是不可以，但这种做法的性能肯定不如直接修改虚拟机，毕竟还差着一个层次。这是一种半调子解决方案，如果是站在平台之外来看，这种方法还不错，但是，作为平台开发者的微软，这么解决问题，就显得有些不靠谱了。也许它只是为了尽快的推向市场，赚些噱头吧！毕竟这种做法可以在尽可能小的影响现有系统的情况下实现。从长远来看，如果DLR能够在未来取得一定进展，如果它还想好的话，它会转向修改虚拟机这条路的。</p><p>又是一年，开始工作了！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200801282355",
    "date": "2008-01-28",
    "time": "23:55",
    "title": "跨越语言",
    "tags": [
      "我眼看世界"
    ],
    "body": "<a href=\"http://martinfowler.com/bliki/PreferDesignSkills.html\">      PreferDesignSkills</a><br>InfoQ评论英文版：<a href=\"http://www.infoq.com/news/2008/01/prefere-broad-design-skills\">Prefer Broad Design Skills over Platform Knowledge</a><br>InfoQ评论中文般：<a href=\"http://www.infoq.com/cn/news/2008/01/prefere-broad-design-skills\">丰富的设计技能胜过特定于平台的知识</a><br><br>我对程序设计语言有着偏好，所以，我喜欢不断接触各种新语言，喜欢研究语言背后的实现。<br><br>最近一段时间，我做的项目用到的几乎都是对我而言的新语言：C#、ActionScript、PHP……，这等价于我要不停的学习自己新语言。<br><br>我很享受学习新语言的过程，因为它们会带给我一些不同的体验。每一种语言都有自己不同的适用范围，这一点在学习像ActionScript和PHP这种有很强领域色彩的语言时，体现得尤为明显。运用这些语言写程序的过程中，很容易体会到语言作者在设计时的侧重。<br><br>学习新语言，某些情况下也有一些让人难受的地方。经常是，程序出现了语法错误，却瞪眼看不出来，突然意识到错误所在，原来自己用的是熟识语言的语法，不禁莞尔。有时，语言或程序库与自己熟悉的习惯不相一致，经常会被绊住一段时间。<br><br>好吧！回到开头，Martin说，设计技能更重要。我想说，设计技能只是很重要的一方面，更多的还是自己做事的方法和习惯。跨越语言时，对此体会会更加深刻。<br><br>最近是在写一些PHP代码，我完成一个功能的过程大致如此；弄清楚自己要做的是什么，想一下大概应该如何实现，用PHPUnit编写测试，然后完成功能，运行所有测试，确保这个实现正确以及没有破坏任何已有的东西。把PHP换成其它语言，相信过程是类似的。<br><br>如果你有机会像我一样在语言之间穿梭，在度过最初的痛苦期之后，你会发现一切会回到自己熟悉的轨道上。设计、编码、查文档、测试，没有什么不同，所做的一切，都是把自己的想法落实成代码，只不过，由于语言的差别，落实成具体的代码，形式上略有差别而已。<br><br>当然，我们不是教条主义者，不只是简单粗暴的知识映射。语言和语言之间是有差别的，所以，学习语言时，我们会注意到语言为我们提供的便利，比如，动态语言的特性，比如，函数的抽象等等，这样我们可以更好更优雅的完成我们的工作。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200801202154",
    "date": "2008-01-20",
    "time": "21:54",
    "title": "实践测试驱动开发",
    "tags": [
      "TDD"
    ],
    "body": "<p>作为一个有理想、有追求的程序员，你成天被各种名词包围着，你对其中一个叫做敏捷的东西特别感兴趣，因为它特别强调人的作用，这听着都让做程序员的你感到舒服。为了让自己早日敏捷起来，你从众多的敏捷实践中选择了一个叫做测试驱动开发（Test Driven Development，TDD）的作为你的起始点。因为它对你周遭的环境要求是最低的：它不像结对那样，要求其他人和你一起合作；也不像采用Story那样改变你所在团队的做事方式……你所需要做的，只是在你编写业务代码之前，把测试先写好。这完全是一种润物细无声的做法，根本无需告诉你之外的任何人。就在别人忙碌的找bug时，你便开始享受敏捷带给你的快乐了。顺便带来的好处是，下次在那里和别人争论敏捷的时候，你可以以一个实践者的姿态出现，而不是在那里信口开河。<br><br>你不会打无准备之仗，于是，你通读了Kent Beck的那本薄册子。通读之下，你对TDD更是充满了信心。因为“红——绿——重构”的步骤实在是简单得令人发指。好吧！总而言之，你已经信心十足的准备开始TDD，步入敏捷的康庄大道了。<br><br>理想很美好，现实很残酷。<br><br>当你着手在实际项目中体验TDD的时候，一切变得并不像最初看起来的那样美好。虽然你努力的坚持着TDD的原则，但你经常就会发现某些东西不好测，比如你遇到了数据库，比如你遇到了GUI，比如你遇到了计时器（Timer）。敏捷并非教条，当某些事不可为的时候，你完全可以不那么坚持。于是，你告诉自己，不好测的东西可以不测，这样，至少从心理上来说，你觉得舒服多了。随着工作的继续，你发现，你不能测的东西越来越多，单元测试的覆盖率随着开发的进行正在逐渐降低，一丝恐惧涌上心头。回过头来，再去看Kent Beck的书，你突然觉得，你似乎被骗了，因为Kent Beck的例子貌似全都是逻辑，如果只是逻辑，当然好测了，但现实从来就不是这样。<br><br>难道TDD只是看上去很美？<br><br>显然，你不愿意就这样放弃，放弃你苦心学来的软件开发秘籍，那些传说中的高手极力推崇的TDD必然有一定道理，TDD确实能够让你感觉很好：能测试的那部分代码确实极大的增强了你对软件质量的信心，而且出错了也确实好找，每次修改代码之后运行测试出现的绿条也确实让你身心愉悦。<br><br>那问题到底出在哪呢？你陷入了沉思。<br><br>信马由缰，你翻开了自己写过的代码。看着自己写的这些代码，你忽然意识到一个问题，自己遇到的问题并不属于TDD，而是属于单元测试。正如你之前所想到的那样，TDD做法本身的结果是让你感到快乐的。对，一定是单元测试本身出了问题。那单元测试出了什么问题，很显然，一大堆不能测试的部分让单元测试变得很难写，降低了单元测试的覆盖度。那是不是这会是一个无解的问题呢？你显然不愿意就此放弃，所以，顺着这个思路继续向前。<br><br>TDD之所以让你安心，主要是每次编写代码之后，运行测试会出现一个绿条，告诉你测试通过。这样，你可以放心大胆的向前继续，因为你的代码并没有破坏任何东西。究竟是什么让你感到不安，显然是那些测试没有覆盖到的代码。你又仔细翻看了一下那些没有测试覆盖的代码，你的思路一下子清晰起来。之所以这部分让你不安，因为里面除了那些确实不好测试的部分之外，里面还有一些逻辑。如果只是那些真正不好测试的部分没有被测试覆盖到，你会觉得心里还有一些安慰。你确定了，真正使你不安的就是与不好测试的代码共存亡的这些逻辑部分。<br><br>如果测试可以覆盖到这些逻辑的部分，至少从感情上来说，就可以接受了。那怎么才能让这些部分被测试覆盖到呢？你仔细观察着那些没有测试的代码，如果这样做，这个部分就可以测试了，如果那样做，那个部分也可以测试了，一来二去，这些貌似不可测试的代码可以分解出许多可以测试的部分。<br><br>你的心情一下子好了许多，因为这么做终于可以让测试的覆盖度达到让你心理上可以接受的范围。不过，新的问题也随之而来。我在做什么？拆来分去，这不就是设计吗？怎么走到这里来了。我不是在分析单元测试的问题吗？对了，我最初的问题是TDD，怎么一路跑到设计上来了？<br><br>TDD？设计？<br><br>你突然发觉自己对TDD的理解有一些偏差。TDD，并不代表不需要设计。读过很多书的你突然想起了Robert Martin那本著名的《敏捷软件开发》，上面有一个关于数据库访问的例子。那个例子里面，前后两个版本的差异正好就是考虑设计的结果。通常，在设计中考虑测试，会很容易找到设计中僵硬的部分，让程序更加灵活。再进一步，如果在开始动手之前，稍微进行一些设计，这些问题还是可能注意得到的。你突然觉得，正是因为TDD本身过于强调测试的价值所在，让你忽略软件开发中很重要的部分：设计。<br><br>思路一下子清楚起来，TDD其实不只是“红——绿——重构”，它还是与设计相关的：在动手之前，还是要有一定的设计，而且，在设计中要考虑测试的问题。终于解开了心中的困惑，现在的你，对于TDD有了一个新的认识，虽然这个认识不见得是什么终极真理，但至少是通过自己的思考得来的，这让你更加相信实践出真知的道理。</p><p>理清思路后，你更加坚信TDD本身的价值所在，也坚定了在日后开发中继续使用TDD的念头，当然，目光远大的你已经盯上了其它的敏捷实践。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200801071346",
    "date": "2008-01-07",
    "time": "13:46",
    "title": "Hello, Lucene",
    "tags": [
      "向上走"
    ],
    "body": "<a href=\"http://lucene.apache.org/\">Lucene</a>是什么？下面是官方回答。<br><br>Apache Lucene is a high-performance, full-featured text search engine library written entirely in Java.<br><br>简而言之，它是用来做搜索的库。提及搜索，我们的思绪就会情不自禁飞到串匹配上。没错，串匹配确实是一种搜索，但对于不同的应用，搜索的方法不一样，对于在一篇文档中进行搜索这种小规模应用而言，串匹配足够了，而Lucene为我们向大规模搜索铺上了一条大道。大规模？是不是想到了搜索引擎，事实上，Lucene就是被很多人用来构建搜索引擎。<br><br>关于搜索引擎的实现，很多人或多或少的听说过一些，比如网络爬虫，比如分布式的架构，比如PageRank。抛开其它其它复杂的部分，最关键的步骤便是建立索引，然后进行搜索。不妨让我们Lucene是如何实现这最关键的部分。<br><br>import java.io.File;<br>import java.io.FileReader;<br><br>import org.apache.lucene.analysis.standard.StandardAnalyzer;<br>import org.apache.lucene.document.Document;<br>import org.apache.lucene.document.Field;<br>import org.apache.lucene.index.IndexWriter;<br><br>public class Indexer {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File indexDir = new File(\"index\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File dataDir = new File(\"data\");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexWriter indexWriter = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexWriter = new IndexWriter(indexDir, new StandardAnalyzer(), true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (File file : dataDir.listFiles()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (file.isFile() &amp;&amp; file.getName().endsWith(\".txt\")) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Document document = new Document();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Field pathField = new Field(\"path\", file.getCanonicalPath(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Field.Store.YES, Field.Index.TOKENIZED);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.add(pathField);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Field contentField = new Field(\"contents\", new FileReader(file));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.add(contentField);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexWriter.addDocument(document);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexWriter.optimize();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (indexWriter != null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexWriter.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>这段代码很容易理解，遍历数据目录下的文本文件，为每个文件生成索引。<br><br>这里有一个Document的概念，它在Lucene表示的是索引和搜索的单位，也就是说，建立索引，是以Document为单位的，搜索也是以Document为单位的。Document中有一堆的Field，我们可以把它们理解为Document中一个一个小节。有了Field，我们可以为Document添加一些属性，比如这里，我们就添加了路径（path）和内容（content）两个属性。这样，搜索之后，我们可以利用这些属性提供更多的信息，比如，告诉别人搜索的词出现在哪个文档中。<br><br>上面的代码中，我们可以清楚看到，建立Document，并向其中插入Field的过程。有了Document，我们就可以把它借助IndexWriter将它们写入索引中，至于最后的optimize，显然是为了让搜索更有效率而存在的。<br><br>有了索引，那就该进行下一步的工作，搜索。<br><br>import org.apache.lucene.document.Document;<br>import org.apache.lucene.index.Term;<br>import org.apache.lucene.search.Hits;<br>import org.apache.lucene.search.IndexSearcher;<br>import org.apache.lucene.search.Query;<br>import org.apache.lucene.search.TermQuery;<br><br>public class Searcher {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String type = \"contents\";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String key = \"game\";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String path = \"index\";<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexSearcher searcher = new IndexSearcher(path);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Term t = new Term(type, key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Query query = new TermQuery(t);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hits hits = searcher.search(query);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; hits.length(); i++){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Document document = hits.doc(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"File: \" + document.get(\"path\"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>IndexSearcher是用来在索引中进行搜索主要帮手，前提是我们要告诉它到索引在哪。Term表示文本中的一个词，它说明了我们要在哪个Field（type）中找什么（key）。然后，我们用Term做成一个Query，表示我们要进行搜索了。做好准备，接下来，就是搜索了。搜索的结果叫做Hits。遍历这个Hits，便可以将搜索结果一一展示出来。如前面所说，这里利用路径这个属性报告搜索的结果。<br><br>有了Lucene做基础，能做的事就很多了，比如搭建一个搜索引擎。事实上，已经有了这样的开源项目，比如与Lucene同出一门的<a href=\"http://lucene.apache.org/nutch/\">Nutch</a>，比如比Nutch年纪更大的<a href=\"http://www.opensymphony.com/compass/\">Compass</a>。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200801032240",
    "date": "2008-01-03",
    "time": "22:40",
    "title": "与高手共事",
    "tags": [
      "脚下的路"
    ],
    "body": "大多数人都愿意与高手共事，因为他们指望着从高手身上可以学到很多东西。在ThoughtWorks，因为要pair，所以，我们可以有更多的机会与高手近距离一起工作。<br><br>如果真的有机会和高手一起工作，有时，你会发现，从具体做的事来说，这些高手做的事并不像想象的那么高深，甚至可以说很简单，简单到换了谁都能做。于是，心中的高手形象逐渐开始动摇，难道令N多人景仰的高手就是这个样子。<br><br>不知道你有没有想过这样一个问题，同样的事，如果没有高手的参与，换你来做，结果会怎样呢？<br><br>老大给我讲了一个他当年和Ward Cunningham在一起工作的故事。每天做的工作就是日常的测试驱动开发，写测试、写代码，所有的一切都是异常简单，下午从不会耽误喝咖啡的时间，到点也就正常下班。一个月后，要做的事情做完了，没有觉得有什么特别之处。不过，回想了一个月前对于这个项目的看法，老大突然发现，这一个月里原来做了许多事情：一个月前，他还觉得这是一项不可能完成的工作。<br><br>我最近的一个项目里，和我一起工作的是有我们中国区的CTO。这个项目的前期是一个类似于可行性论证的工作，项目最初，他为整个项目的结构订下了一个基调，让整个项目的结构显得特别清晰，准确的说，应该是很简单，简单到让人觉得理所当然。单从工作的具体内容来看，他并没有在这个项目里面做太多的事情，但从另外一个层面来说，正是他做的前期所做的工作，让后面的工作变得容易了许多。<br><br>这么一说，是不是有一种高手形象顿失的感觉。其实，高手通常不会觉得自己是高手。多年积累下的，只是良好的工作习惯而已。他们知道，自己是普通人，自己不能应付过于复杂的东西，于是，把自己要做的事分解成一些非常简单的小事。只要把这些微不足道的小事做好了，所谓的大事便也做成了。<br><br>我很喜欢读的书中，有几本书出自贝尔实验室，比如《程序设计实践》、《Unix编程环境》、《C程序设计语言》等等，每一本都是那么轻薄。这些书里面的内容读起来都是那么轻松，每一步做的事都让人觉得太过简单，但回过头来，可能你才发现，原来一些貌似很复杂的工作已经完成了。<br><br>曾有一段时间，我一直觉得自己掌握的东西不够复杂，为此，我总是惴惴不安。后来发现，但凡我学过的东西本质上都很简单，于是我想，到底怎么才能让自己复杂起来。读过那几本书之后，我释然了：做事本就该是做简单的事。如果你觉得复杂，多半是走错了路。<br><br>与高手共事，技术之外的东西，也许更值得学习。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200712252315",
    "date": "2007-12-25",
    "time": "23:15",
    "title": "圣诞聊敏捷",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>在ThoughtWorks待了大半年，听的见的经历的最多的当然是敏捷。圣诞之夜，不妨整理一下现时心目中的敏捷。<br><br>提及敏捷，主要是两种反映，济世良药或是洪水猛兽，当然，也有人置身事外。其实，敏捷只不过是一种软件开发方法而已，与传统软件开发方法开发方法并无本质区别：敏捷也需要知道到底软件要干什么，所以，分析需求不可或缺；敏捷最终也是把软件提交给客户，所以，也要一行行把代码写出来；敏捷出的软件也会有错误，所以，测试阶段是不可缺少的；敏捷出的软件业务也会变化，所以，代码也需要维护；敏捷的情况下，为了在给客户展示，所以，偶尔也要加班……<br><br>如此说来，敏捷是不是和传统软件没有分别了呢？显然不是，任何事物一旦拉高到本质的高度，恐怕都没有区别了，就像“人”可以涵盖人这个物种，但事实上，人还有男人、女人、好人、坏人……等等众多区别手段。<br><br>相信大多数人有这样的感觉，念书的时候，总有那么一些怪物，看起来，玩得不比别人少，书读得不比别人多，但考试成绩总比别人。这样的怪物是怎样炼成的呢？说起来，很简单，他们懂得了一些学习的方法，所以，他们可以在同样的时间内，取得比别人高许多的结果。<br><br>做事，是有方法的。<br><br>好的做事方法绝对是大幅度的提高效率的。相对来说，敏捷就是一种好的工作方法。<br><br>敏捷重视人在软件开发中的价值，所以，在敏捷团队中，开发者在团队中地位很高，这让我们在心理上得到了极大的满足，于是乎，心情很是愉悦。在很多强调传统软件工程的团队中，开发者不过是一颗螺丝钉，一个可有可无的角色，受重视程度自然很一般，除了自力更生，心情上与敏捷团队不可同日而语。两种团队，我都经历过，差异极大。其实，无论在什么样的团队中，我们都要完成类似的工作——编写代码，但是，想必人人都清楚，心情对于一个人工作的影响。<br><br>除了完成工作，我们需要的还有发展。专业技能上的成长，除了自己摸索，更重要的还有吸收来自别人的营养。在传统的方法团队中，除了读书，只有偶尔大家的交流才能让人得到向别人学习的机会，大多数情况下，我们所能做的就是单枪匹马的孤军奋战。幸运的话，也许能够走上的正确的道路，大多数人必然会绕很大的圈子，更不幸者，也许就此失去了对软件开发的兴趣，或默默忍受编程带给自己的痛苦，或干脆离开这个是非圈。</p><p>在敏捷团队中，过程本身采用的一些方法就是前人经验的总结，比如测试驱动开发。结对编程可以让人有机会观察别人是如何工作的，从中吸取养分，这些细节是几乎不可能从书本或是课堂学到的，比如，在ThoughtWorks工作之前，我从未意识到快捷键对工作的帮助如此之大，当看到其他人按键如飞后，我决定在今后的开发中，尽可能多的使用快捷键。在两个人共同开发的过程中，我们有机会看到自己同伴对于一个问题思考的过程，这对于我们的提高绝对是有益的，特别是和一些高水平的人合作。良性循环和恶性循环显然不是一回事。<br><br>软件是为人服务的。软件开发是为了将软件创造出来，而不是为了为难开发团队。如果你曾经在传统开发团队工作过，提到这一点，脑子中多半会浮现出“文档”这两个字。敏捷团队也会写文档，但我们写的是那些对客户有价值的文档，而不是把时间浪费在那些为了过级而编写而且完成之后便会束之高阁的文档。不给自己找麻烦是很必要的。</p><p>敏捷和某些传统软件开发过程可以说是殊途同归，比如，CMM到了最高的级别，会向自适应的方向发展，而敏捷本身也是在过程中不断的进行自我调整，做到兵来将挡。当然，走到一起之前，二者的差别显得还是很大。<br><br>以上这些都是站在我——一个开发者——的角度体会的敏捷，显然，并不全面。某些人提到敏捷，还会有更加伟大的角度，比如，业务之类的，那不是我所擅长的。<br><br>既然敏捷如此之好，为什么敏捷团队还是如此有限？回到最初那个读书的比喻上，优等生的方法不见得是每个人都知道的。即便知道了，相信、学习到掌握还要有一个过程。敏捷是不是终极解决方案，我想不会，天外总有天，如果哪一天，我知道更好的方法，我愿意接受。<br><br>写下这些文字的时候，<a href=\"http://groups.google.com/group/ruby-talk-google/browse_thread/thread/bc6ed379e4dab2a4\">Ruby 1.9.0发布了</a>，感谢Ruby开发团队带给大家的圣诞礼物！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200712172351",
    "date": "2007-12-17",
    "time": "23:51",
    "title": "2007 Away Day",
    "tags": [
      "脚下的路"
    ],
    "body": "第一次参加ThoughtWorks的Away Day。Away Day是公司给大家提供一个在一起交流放松的机会，一般会利用周末的两天，第一天有人各种各样的session，用以交流，第二天就是玩，用以放松。<br><br>Away Day，字面的意思是，一个离开办公室的日子，鉴于今年刚刚搬进新办公室，出于对新办公室的喜爱，今年Away Day第一天的活动就放在了办公室里。<br><br>Away Day，公司一下子变得很热闹。原来驻扎西安的大部队来到的北京办公室，原本分散在北京和西安两地的中国区员工终于团聚在一起。ThoughtWorks Studio的两个团队——<a href=\"http://studios.thoughtworks.com/cruisecontrol\">CCE</a>和<a href=\"http://studios.thoughtworks.com/mingle-project-intelligence\">Mingle</a>也在北京扎根。此外，还有不少从其他办公室来参加Away Day的同事和已经签约明年准备加入公司的毕业生。当所有人坐到一起的时候，我才第一次觉得ThoughtWorks在中国已经有很多人了。依稀记得我当初面试时，二三十个人围坐在桌边的情景。不到一年，我们壮大了许多。老大在讲话中回顾了当年和<a href=\"http://hl.thoughtworkers.org/\">黄亮</a>谈offer时的情景，颇有些忆往昔的感觉。<br><br>第一天的session内容很丰富，技术、招聘、公司策略、创新等等，应有尽有，甚至有人还组织了一个世界发展的话题。虽然是一次内部活动，但内容一点都不含糊，而且，讲者与听众通常很熟悉，所以，常常会有一些精彩的问答。据说，Jon Tirsen在介绍Erlang的session上，问到讲演者不得不说自己还不是太熟悉。我也亲见了一个session里面，一个“why not”让讲演者沉默了半天。<br><br>我也同样做了一个session，话题是关于招聘中的code review。因为在ThoughtWorks工作这段时间，除了写代码，干得最多的就是招聘了，而code review做得尤其多，几百个总是有的，所以，略有心得。原本我考虑讲一个技术的话题，但后来一想，Away Day是一个轻松的日子，讲生涩的技术会让大多数头疼的。事实证明，在Away Day中，技术讲座的听众相对来说会少一些，比如，<a href=\"http://www.blogjava.net/raimundox/\">徐X</a>那个关于用Ruby做interpreter的话题，只有为数不多的人在场。:)<br><br>对我而言，做session并不是一个最好的选择。因为当天我还是花了不少时间在准备上，所以，我只听了很少的内容，有些遗憾。我的session是当天的最后一个，因为前面人的超时，我不得不用绕口令的速度进行快速讲解，否则，耽误了大家的晚饭，后果会很严重。<br><br>结束了session，就彻底进入到一个交流的环节。无论是当天的晚饭，还是第二天的出游，感觉自己几乎一直在和不同的人说话。在ThoughtWorks，我们是鼓励和不熟悉的人进行交流的，因为指不定哪天大家可能就会在一起工作，即便是简短的交流，也会为未来奠定一个良好的基础。<br><br>虽然是第一次参加Away Day，感觉不错！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200710221105",
    "date": "2007-10-22",
    "time": "11:05",
    "title": "读《修改代码的艺术》",
    "tags": [
      "我眼看世界"
    ],
    "body": "作为一个程序员，获取知识是让我不断前进的动力，而读书是我获取知识的一条重要途径。在这个“经典”、“必读”过剩的年代里，大多数的书都仅仅扮演着传播知识的角色，真正改变自己对某些问题看法的书其实少之有少。限于读书时的眼界和能力，在我列表中，让我拍案惊奇的书只有几本。Martin Fowler的《重构》，严格说来，我并没有完整的读完这本书，不过，正如<a href=\"http://martinfowler.com/bliki/DuplexBook.html\">作者自己所说</a>，这样的书原本就不指望能够读完，因为有一大部分其实是参考手册。正是我读过的部分让我知道了重构，让我知道这么做可以把代码写得更好。Robert Martin的《敏捷软件开发》，这是一本名字赶潮流，内容很丰富的书，这本书让我开始理解软件设计，从此不再刻意追求设计模式。Kent Beck的《测试驱动开发》，我读的是英文版，因为当时中文版还没有出版，所以，我不敢说，我通过这本书很好的理解了测试驱动开发，但它却为我打开了一扇门，让我知道了一种更好的工作方式。<br><br>有好长一段时间，这个列表没再更新过，中间虽然我也读了很多书，也学到了很多东西，但却没有哪本书如这几本书一样给我带来巨大触动。新近加入我这个列表的书是《修改代码的艺术》，英文名是《Working Effectively with Legacy Code》。<br><br>对于很多软件开发人员来说，加入一个公司，通常意味要面对一大堆之前留下的代码。而面对沉重的负担，大多数人的感觉都是无可奈何。让无奈成为往事，也就是这本书的价值所在。<br><br>在我看来，这是一本讲解如何编写测试的书。之所以遗留代码让人头痛，除了复杂的逻辑，改动会带来怎样的后果是一件让人心里没底的事，而测试的存在可以大幅度降低这种恐惧。但是，许多代码在开发时并不考虑测试，这样做的结果就是让测试几乎成为一件不可能完成的任务，一个常见的例子就是代码中访问数据库。即便写出测试代码，漫长的测试过程也会让它失去一部分应有的作用，我们希望得到的是快速的反馈。所以，对于<br>无测试而言，知道编写测试是一种境界的提升，写好单元测试则是一种更高的境界。如果能够让测试驱动开发，从开发之初便考虑测试，并懂得如何写好测试，开发者应该不会陷自己于一种难为的境地，这也应该成为专业程序员应该具备的基本技能。<br><br>至于这本书的具体内容，我的评价是实用。具体的手法，很难在这里一一列举，但是，以我的开发经验来看，<br>许多似曾相识的代码不断的出现在书中，而作者举重若轻的处理手法，正是让我有拍案惊奇的地方。实际上，回味起来，每个手法都不是什么很高超的技法，但正是因为见识过类似的代码，才能体会到这种手法的价值所在。所以，相对于程序新人，它更适合有经验的人。<br><br>之所以说这本书更适合有经验的人还因为，这本书中谈及的内容涵盖设计、测试、重构等诸多方面：通过重构，解开代码内的耦合，让其可测。这恰恰是前面提到的那三本书所讲的内容。也只有懂得了这些基本内容才能体会到那些具体手法的价值所在。依然记得当年读《重构》时，在提取和内联之间迷茫了好久，直到后来经过了许多开发实践才体会到这些做法的真正含义。<br><br>如果说不足，那么，这本书缺乏一个列表，就像Martin Fowler为《重构》所做的那样，出什么样的问题，应该采用怎样的手法进行处理。<br><br>关于中译本，总的来说，翻译得很流畅，读起来比较舒服。不过，制作上还是有一些不太让人满意的地方。<br>* 译注太多，而且有些是低估读者智商的译注。<br>* 页边标有页码，似乎是为了与英文版对照，但文中的参考页码又是以中文版为准，显得有些乱。<br>* 书的装订不是特别令人满意，我一直担心从中间断开。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200710121821",
    "date": "2007-10-12",
    "time": "18:21",
    "title": "一篇XRuby概述的文章",
    "tags": [
      "脚下的路"
    ],
    "body": "<a href=\"http://www.infoq.com/cn/articles/XRuby-JVM\">XRuby：享用JVM上的Ruby</a><br><br>在InfoQ China发了一篇介绍XRuby的文章。其实，对于之前听过我介绍XRuby的人来说，这篇文章的内容并不新鲜，因为基本上，这篇文章的内容脱胎于之前介绍XRuby的讲稿。虽然讲了几次，但还是应该把这篇文章写出来。一来，到场听介绍的人毕竟是少数，写出来看到的人应该可以更多，也让更多的人有机会了解XRuby，再有，内容写成文章需要比演讲时有更多的思考。所以，整体来说，内容叙述应该会更加准确。<br><br>这是一篇早就该写的文章，至少最初答应<a href=\"http://blog.csdn.net/futurelight/\">霍泰稳</a>写这篇文章还是5月份的时候，7月份录我<a href=\"http://www.infoq.com/cn/interviews/zhengye-ruby-on-jvm-xruby\">InfoQ访问</a>的时候，又答应了Floyd完成这篇文章，可真正发布已经是十月份了。不过，这样一拖再拖也不是完全价值。在这段时间里，<a href=\"http://dreamhead.blogbus.com/logs/6746046.html\">我在Agile Day讲了一次Ruby on JVM</a>，让我对这个方面有了些新的思考，特别是把Ruby放在 JVM上的价值，这一点已经体现在这篇文章里了。另外，XRuby自身在这段时间中也发生了很大的变化，特别是<a href=\"http://dreamhead.blogbus.com/logs/7548397.html\">Annotation的加入</a>，让代码在表现形式上得到很大的进步。至少在我看来，最终体现在文章中的示例代码是可以接受的。<br><br>我希望，这篇文章可以成为一个起点。一方面，它可以作为让更多人了解XRuby的起点；另一方面，XRuby团队把它作为一个起点，向其它人展示XRuby中非常优秀的一面。当然，XRuby现在已经有了不少不错的文档。<br><br>已经有朋友给我建议，写一些更深入的东西，这也是我所希望的，只探讨一些比较浅的东西不过瘾。在XRuby开发过程中，有很多有趣的思考，我很愿意与人分享那种开发中的快乐。再有，写东西会促使人思考，随之而来的往往是发现不足，这也是有益于XRuby进一步改进的。<br><br>如果你希望了解或参与XRuby，不妨告诉我们，你想了解什么，也许，我们之后的文章会满足你！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200710101455",
    "date": "2007-10-10",
    "time": "14:55",
    "title": "编译与解释",
    "tags": [
      "向下走"
    ],
    "body": "如果我们想将程序设计语言编写的源代码运行起来，通常情况下，我们有两条路可以走：解释和编译。<br><br>计算机能够认识的只是01串，所以，我们编写的源代码要想真正启到应有的作用，必须经过转换，转换成一种可执行的格式，然后，由专门的执行引擎将它运行。<br><br>解释，通常是将源代码解析为一个中间形式（比如抽象语法树，AST），然后，经由一个软件的执行引擎执行这个中间形式，产生对应的结果。这种做法的好处就是可以把执行逻辑独立处理，无须为每个平台编写不同的代码，所以，这种做法的可移植性很好，于是，它成了不少程序设计语言最初的选择。不过，随之而来的问题就是这会降低执行速度，毕竟，这个软件执行引擎的性能无法与硬件相比。所以，以硬件作为执行引擎的“编译”会让程序拥有更佳的性能。<br><br>采用编译的方式，我们可以将代码编译成可以由硬件直接执行的二进制代码。因为不同硬件和不同操作系统的二进制格式是不同的，所以，如果希望语言得到广泛应用，那便需要针对不同平台实现平台相关的编译器后端，理论上说，这不是一件不能完成的任务，但这意味着巨大的工作量。虽然编译语言的数量不在少数，但事实上，真正能够跨越各种软硬平台的编译语言似乎只有C。<br><br>虚拟机的出现让人们找到了在软硬件执行引擎之间的一个折衷。一方面，编译器只要生成针对虚拟机的代码，而不必为各种各样的软硬件平台费心，另一方面，虚拟机不断的优化可以让程序在不受编译器的影响下越跑越快。所以，许多程序设计语言走上了这条路，比如Java，比如Python。这些语言大多采用的是自行设计的虚拟机，但这个做法虽然可以充分的将语言特性与虚拟机结合起来，但无疑也意味着大量的重复工作。Parrot希望成为一个集大成者，为众多动态语言搭建一个共同的平台，只是不知何年何月才能实现它宏大的目标。<br><br>Java虚拟机（JVM）的普及为这个问题提供了另外一种选择。因为主流软硬件平台上基本都有自己的JVM实现，所以，只要生成针对JVM的代码——字节码，便意味着可以运行在大多数平台上。当然，虚拟机也是一种软件实现，所以，性能上也会有一些损失。不过，从Java平台的广泛应用也证明了，这样的损失在实践中是可以接受的。随着JVM技术上的不断进步，性能损失越来越小。再者，作为一种为静态语言设计的平台，目前，JVM自身并不支持动态语言特性，所以，要想让动态语言语言运行在上面，需要额外做一些工作，搭建一套支撑动态语言的结构。不过，随着一些动态语言逐渐被移植到JVM上，人们也意识到了这个问题上，开始考虑在JVM中增加动态语言的支持。<br><br>除了执行性能之外，编译带来的好处还在于保护源代码。因为解释方式通常不会保留的其中间形式，所以，产品发布意味着将源代码也发布出去。对于需要保护知识产权的公司和个人而言，这是他们所不愿意看到的。通过编译的方式，我们将源代码转成了二进制，这样，源代码可以得到有效保护。当然，破解二进制也是有可能的，不过，那就是另外的故事了。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200709241938",
    "date": "2007-09-24",
    "time": "19:38",
    "title": "XRuby 0.3.1和Ruby Hacking Guide中文版",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>今天是一个发布的日子，XRuby发布了0.3.1，Ruby Hacking Guide中文版发布了第一部分。</p><p><a href=\"http://xruby.googlecode.com/files/xruby-0.3.1-src.zip\">XRuby 0.3.1</a><br><br>相比于前一个版本，XRuby 0.3.1最大的进步在于完成标准库的预编译。预编译意味着什么？标准库代码无需在每次运行时编译，这意味着今后使用XRuby的标准库性能会得到一定的提升。<br><br>有一个与编译相关的话题。之前，Jon Tirsen曾经谈到JRuby的一个问题，运行在AppServer中会有占用太多内存。经过分析得知，为了提高程序的并发性，程序运行会启动多个JRuby。每个JRuby解析Ruby脚本都会建立一棵完整的语法树，这就意味着，由于这种解析模式本身的限制，对于同样的内容，内存中需要保存多份相同的语法树，这种做法意味着无谓的耗用了大量的内存。采用编译的做法，则可以很好的避免这个问题。因为在运行时，相同的是字节码，而JVM很好的帮我们解决字节码共享问题，无需耗用大量的内存。</p><p><a href=\"http://rhgchs.googlecode.com/files/rhgchs-20070924.zip\">Ruby Hacking Guide中文版第一部分</a></p><p>RHG终于完成了第一次发布。已经发布的第一部分介绍的是Ruby的对象模型。我正是从这个部分开始了解Ruby实现的，进而完成了XRuby的<a href=\"http://dreamhead.blogbus.com/logs/5006019.html\">Runtime的重写</a>。所以，我一直觉得这部分是了解Ruby实现非常好的一个起点。<br><br>从翻译Ruby Hacking Guide到现在已经超过了一年，从<a href=\"http://dreamhead.blogbus.com/logs/3971837.html\">第一次发布消息</a>算起也超过了9个月。相比XRuby，这个项目的进展可以用异常缓慢形容。这是一本日文书，也是一本技术书，而且是一本讲语言实现的书。任何一个点都会增加翻译的难度。几个懂日语的朋友先进行一遍初译，然后，我对再对译稿进行一遍校验，并根据自己的理解修改译稿，这样的过程无疑延长了处理的时间。这是一个业余时间的项目，而我更多的业余时间在XRuby上，没有太多精力投入上面。种种的因素造成了这个项目的一托再托。<br><br>目前，我手头已经有了第二部分全部和第三部分几章的初译稿，不过，按照之前的进度来看，这几章的发布可能要等到许久之后了。如果你有兴趣，可以加入到这个项目中来，这样，有助于加快这个项目的进度。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200709190933",
    "date": "2007-09-19",
    "time": "09:33",
    "title": "管窥Ruby——类的变量（更新版）",
    "tags": [
      "向下走"
    ],
    "body": "<p>\n《<a href=\"http://dreamhead.blogbus.com/logs/3603225.html\">管窥Ruby——类的变量</a>》写在去年，写成之后便更新了一次，因为最初的描述存在一些偏差。即便如此，jxb8901依然指出了其中的一些不足。最近，<a href=\"http://dennis-zane.javaeye.com/\">dennis-zane</a>再次提出了这个问题。回过头来仔细品味，确实有些地方写得不是很到位，索性把它重新写过。\n</p>\n<p>\n<font size=\"5\"><strong>管窥Ruby——类的变量</strong></font><br>\n<br>\n变量和方法是面向对象难以割舍的两个重要组成部分。在《<a href=\"http://dreamhead.blogbus.com/logs/2006/09/3350630.html\">管窥Ruby——类的方法</a>》中，我们谈到方法，沿着这条路继续，我们再来看看类中的变量。<br>\n<br>\n开始之前，我们还是要再次回顾RClass的定义：<br>\nstruct RClass {<br>\n&nbsp;&nbsp;&nbsp; struct RBasic basic;<br>\n&nbsp;&nbsp;&nbsp; struct st_table *iv_tbl;<br>\n&nbsp;&nbsp;&nbsp; struct st_table *m_tbl;<br>\n&nbsp;&nbsp;&nbsp; VALUE super;<br>\n};<br>\n(ruby.h)<br>\n<br>\n如果你看过《<a href=\"http://dreamhead.blogbus.com/logs/2006/09/3350630.html\">管窥Ruby——类的方法</a>》，了解了方法存储方式，变量的存储方式便也一目了然了，同样的st_table，意味着同样的处理方式。<br>\n<br>\n不得不承认的一点是，在讨论类的方法时，我故意忽略了一个事实：方法分为类的方法和实例的方法两种。如果对其它语言实现有些许了解，我们知道，这两种方法差别仅仅是this（C++或Java的说法），到了底层时，这个差别可以视为无物，可以统一存放。关于这点，有兴趣可以参考一下《深入Java虚拟机》，它的第五章讲解了虚拟机内方法的表现形式。在Ruby中，类的方法和实例的方法并不是存放在一起的，这里定义的实际上是实例方法，而类的方法是定义在类的Singleton类中。<br>\n<br>\n遇到变量时，我们会碰到同样的问题：类的变量和实例变量是无法统一管理的。因为类的变量只有唯一的一份，而实例变量则是每个实例都有一份。所以，RClass存放的并不是真正实例变量。代码是说明问题的最好方式，下面这段代码说明了如何设置实例变量：<br>\n<br>\nVALUE<br>\nrb_ivar_set(obj, id, val)<br>\n&nbsp;&nbsp;&nbsp; VALUE obj;<br>\n&nbsp;&nbsp;&nbsp; ID id;<br>\n&nbsp;&nbsp;&nbsp; VALUE val;<br>\n{<br>\n&nbsp;&nbsp;&nbsp; if (!OBJ_TAINTED(obj) &amp;&amp; rb_safe_level() &gt;= 4)<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rb_raise(rb_eSecurityError, \"Insecure: can't modify instance variable\");<br>\n&nbsp;&nbsp;&nbsp; if (OBJ_FROZEN(obj)) rb_error_frozen(\"object\");<br>\n&nbsp;&nbsp;&nbsp; switch (TYPE(obj)) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case T_OBJECT:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case T_CLASS:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case T_MODULE:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!ROBJECT(obj)-&gt;iv_tbl) ROBJECT(obj)-&gt;iv_tbl = st_init_numtable();<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st_insert(ROBJECT(obj)-&gt;iv_tbl, id, val);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generic_ivar_set(obj, id, val);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp; return val;<br>\n}，<br>\n(variable.c)<br>\n<br>\n抛开前面那些复杂的东西，直接来看switch语句后面的内容。这里存在两种情况，对于存在T_OBJECT、T_CLASS和T_MODULE标记的，变量会写入iv_tbl，而其余的情况则转交 generic_ivar_set处理。iv_tbl是“实例变量表（instance value table）”的缩写，不过，如果当前对象是个类对象，这个“实例”变量实际上就是类变量，所以，这个名字多少有些名不符实。<br>\n<br>\n除此之外，还有一个generic_ivar_set。下面是generic_ivar_set的实现：<br>\n<br>\nstatic void<br>\ngeneric_ivar_set(obj, id, val)<br>\n&nbsp;&nbsp;&nbsp; VALUE obj;<br>\n&nbsp;&nbsp;&nbsp; ID id;<br>\n&nbsp;&nbsp;&nbsp; VALUE val;<br>\n{<br>\n&nbsp;&nbsp;&nbsp; st_table *tbl;<br>\n<br>\n&nbsp;&nbsp;&nbsp; if (rb_special_const_p(obj)) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; special_generic_ivar = 1;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp; if (!generic_iv_tbl) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; generic_iv_tbl = st_init_numtable();<br>\n&nbsp;&nbsp;&nbsp; }<br>\n<br>\n&nbsp;&nbsp;&nbsp; if (!st_lookup(generic_iv_tbl, obj, (st_data_t *)&amp;tbl)) {<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FL_SET(obj, FL_EXIVAR);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbl = st_init_numtable();<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st_add_direct(generic_iv_tbl, obj, (st_data_t)tbl);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st_add_direct(tbl, id, val);<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>\n&nbsp;&nbsp;&nbsp; }<br>\n&nbsp;&nbsp;&nbsp; st_insert(tbl, id, val);<br>\n}<br>\n(variable.c)<br>\n<br>\n同样忽略一些非主干的部分，我们看到，这段代码先在一个generic_iv_tbl中进行查找，用作查找键值的是对象实例（obj），而目标同样是一个st_table。得到这个表之后，利用变量名做键值将值插入到表中。我们便不难分析在这种做法中实例变量的存储方式。存在一个全局的实例变量表，走到这里的实例都在其中拥有一席之地，而实例变量存储在实例对应的表中。Ruby通过这样一个二级结构，解决了这些实例变量存储的问题。<br>\n<br>\n了解过基本的做法之后，随之而来的一个问题就是，这些代码都会在什么情况下起作用。<br>\n<br>\n代码已经说得很明白了，只有在有那几个标记的情况下，才会直接调用iv_tbl。T_CLASS和T_MODULE都很好理解，那什么情况下会有T_OBJECT呢？在C Ruby中，在Ruby层次上定义的类，生成的实例都是会标有T_OBJECT（参见《<a href=\"http://dreamhead.blogbus.com/logs/2006/11/3751564.html\">管窥Ruby——Allocator</a>》）。所以，所有由Ruby层次上生成的对象都会走到这里来。<br>\n<br>\n那generic_ivar_set呢？除了那几个标志外的其他部分都会走到这里。除此之外的标志表示什么呢？读一下代码我们便不难发现，几乎就是builtin的几个类，比如数组、字符串、正则表达式等等。那为什么这些builtin类没有一个iv_tbl。对于这些builtin而言，它们真正的实例变量都是以C的形式给出，所以，额外存在一个iv_tbl实际上是一种空间上的浪费。\n</p>\n<p>\n虽然不是常态，但我们依然可以为这些builtin类添加自己的实例成员。为了保持Ruby的动态特性，这才有了generic_ivar_set的存在。\n</p>\n\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200709171748",
    "date": "2007-09-17",
    "time": "17:48",
    "title": "闲聊C++单元测试框架",
    "tags": [
      "C++"
    ],
    "body": "今天下午，和Darwin聊了一下C++单元测试框架，主要参考对象是CppUnit和CxxTest。<br>\n<br>\n<strong>表现形式</strong><br>\n因为C++不支持reflection，所以，必须要做一些额外的工作，让框架知道相关内容的存在。CppUnit的做法是用宏进行注册。这种做法要求我们每添加一个测试，就要考虑用相应的宏进行注册，这种做法很繁琐，最大的问题在于由于疏忽而遗漏，这种靠人工保证的东西不可靠。在这点上，CxxTest做得要好一些，有一个专门的脚本做这件事。通过这个脚本扫描这个自己编写的文件，生成一些新的文件，完成这个工作。从代码的表现力和可靠度来说，要好得多。唯一的问题是引入了一个脚本，而且这个脚本一般是由某些动态语言写成的（目前的CxxTest有Perl和Python的脚本），从而引入了对这种语言的依赖。不过，由于C++语言本身的限制，从接口的角度来看，这种做法已经很不错了。<br>\n<br>\n<strong>语法</strong><br>\n有一种C++的单元测试框架叫TUT，Template Unit Test的缩写。顾名思义，它是用模板完成的（其实，CppUnit和CxxTest都有模板的部分）。随着C++编译器的进步，在大多数情况下，模板都是可以顺利通过编译的。但是，不要忘了，还有一种环境叫嵌入式，那里的编译器基本上还是很原始的，模板并不见得能够顺利的通过编译。<br>\n<br>\n此外，模板还会带来另外一个问题，编译时间的增长，相信有过模板编程经验的人都会对此深有体会。编译时间增长意味着什么？我们接下来讨论。<br>\n<br>\n<strong>编译时间</strong><br>\n有一种敏捷实践叫做测试驱动开发（Test Driven Development）。测试驱动开发的基础是单元测试。测试驱动开发希望达成的一个目标是快速反馈，所以，站在C++语言的角度，如果执行时间受限于代码本身无法缩短，那么我们希望编译时间尽可能短，这样，才不会把生命都浪费在等待代码编译上。<br>\n<br>\n除了刚才提到的模板问题之外，CppUnit会把所有测试编译生成一个可执行文件，这意味着什么？几乎修改任何一个文件都会造成这个文件的重新生成。随着目标文件的增加，这个过程时间就会增长。相对于修改范围（可能只是某一个文件），还是显得有些长了。为什么Java语言不会存在这种现象？因为Java是动态连接的，所以，Java生成.class就结束了。对应到C++上，这只是完成了目标文件的生成，而在C++我们不得不再进一步生成可执行文件。从道理上，CxxTest可以为不同的测试文件生成不同的可执行文件，不过这么做又少了总体的过程，统计起来又显得心有余力不足了，而且通常不会这么做。<br>\n<br>\n个人而言，对这几个单元测试框架都不是非常了解，如果前面的讨论存在谬误，欢迎有识之士指出。\n\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200709101525",
    "date": "2007-09-10",
    "time": "15:25",
    "title": "XRuby一岁了！",
    "tags": [
      "XRuby"
    ],
    "body": "<p>\n一年前，yawl将自己用业余时间做了一年的项目开源了，这就是XRuby。<br>\n<a href=\"http://seclib.blogspot.com/2006/09/xruby-project-is-now-hosted-on-google.html\">XRuby project is now hosted on Google Code</a><br>\n<a href=\"http://www.railscn.com/viewthread.php?tid=2006\">有人愿意做Ruby Compiler么？</a><br>\n<br>\n我就是那时加入XRuby的，依然记得最初见到这个项目时的兴奋，转眼，一年过去了。从2007年1月29日0.1.0发布至今，我们一共发布了7个版本。XRuby正逐渐变得越来越有样子：代码越来越干净，功能越来越强大。<br>\n<br>\nXRuby是我第一次真正全身心投入参与的一个开源项目：常常为自己漂亮的解决了一个问题而自豪，也时常为解决方案不够优雅而寝食难安。依然记得有几次，为了实现一个功能而熬夜；也有本来已经躺在床上，却难以抑制兴奋爬起来继续编码。这一年里，XRuby在成长，我也随着这个项目在成长，对Ruby语言的实现理解越来越深，从最开始的照搬C实现，到现在逐渐有了一些自己的想法在里面。在与大家合作的过程中，从其它人身上学到了许多足以让我受用终身的东西，尤其是yawl。相信其他深入参与XRuby的人与我有着类似的经历和感受吧！<br>\n<br>\n其实，在这一年里，我也并非始终如一的对XRuby付出着。从项目最初开源到发布0.1.0之间有大约4个多月时间，完成了那个新runtime之后，很长一段时间，我并没有写太多代码。那段时间，应该是我参与XRuby过程，感觉最为黑暗的一段时间，因为确实看不到这个项目的方向，没有版本发布，漫无边际的代码等待着编写，而我写的新runtime又很难集成到XRuby里面。这个状态一直持续到0.1.0的发布，我似乎一下子看到了光明，尽管XRuby看起来那么不成熟，但我们的努力终于得到了一丝回报，于是，我兴奋的写下了《<a href=\"http://dreamhead.blogbus.com/logs/4412649.html\">XRuby发布了！</a>》 。<br>\n<br>\n在我找回动力之后，XRuby也逐渐开始得到了越来越多的关注，项目成员也逐渐增多，XRuby也逐渐步入开发的正轨。每隔一个多月，我们就会发布新版本，每次新版本的发布，都增强着我们对XRuby的信心。XRuby的成员也通过各种途径向大家介绍着XRuby，也有人开始讨论XRuby。<br>\n<br>\n做开源，最艰难的是什么？技术吗？似乎是，尤其像XRuby，仅仅一个“编译器”的名头，就足以让许多人望而却步了。其实不然，技术这东西，只有不愿意学的，少有难以学会的。参与XRuby并不需要一开始就掌握复杂的编译器技术，因为XRuby包括了许多部分，编译器只是其中的一个部分。时至今日，XRuby中的某些部分对我来说，依然是陌生的，但这并不影响我为XRuby编写代码。从个人的经历来看，builtin是一个很好的入手点，而那里并不多数情况下并不需要了解编译器，甚至几乎不需要了解Ruby内部实现。<br>\n<br>\n在我看来，最难的是坚持。用业余时间，无偿为一个项目付出着。回报？除了知识和技能上的提升，其他都是不可预期的。在这种情况下，坚持着实是一件困难的事情。其实大家可以很清楚的看出来，这个世界上，开源项目不计其数，但真正能让人知道的少之又少，许多开源项目在开始后没多长时间便死去了。在国内论坛中，很多开源项目的发起者都在抱怨，开源环境很差，没有人参与他们的项目。当然，这其中也有项目本身吸引力的因素。其实，做开源是需要一些理想主义的，这样，才能在一条未知的路上前行。XRuby中也存在类似的问题，许多参与者一开始总是兴致勃勃的要求加入，好一些的，贡献了一些代码之后，便很长时间没有声音，有的则在加入之后，一行代码都没有写，便无声无息了。从加入开始一直比较稳定的贡献代码的人，屈指可数。不过，从另一个角度，这也说明了，当一个开源项目具备了一定的生命力之后，并不会因为某个人的不作为而死去。\n</p>\n<p>\n不管一路上有多少阳光和风雨，XRuby走过了它的第一个生日，步入了第二个年头，大家已经开始尝试着进行Rails的支持，我们会努力让它走得更好。<a href=\"http://dreamhead.blogbus.com/logs/8031770.html\">在班加罗尔讲XRuby</a>时，有人问过我，现在XRuby面临的主要问题是什么，我说，我们没有足够的资源。其实，现在可以看到的很多问题对我们来说，并不是非常困难，但却需要投入大量时间来完成。这也是我们始终如一的欢迎有兴趣的人加入我们的原因。如果你愿意和XRuby一起成长，欢迎加入我们！\n</p>\n\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200708312256",
    "date": "2007-08-31",
    "time": "22:56",
    "title": "班加罗尔的Geek Night",
    "tags": [
      "脚下的路"
    ],
    "body": "做了一件让自己觉得不可思议的事情，在班加罗尔的Geek Night用英文讲XRuby。<br>\n<br>\n这周早些时候，在办公室遇到了<a href=\"http://blog.sidu.in/\">Sidu</a>——我在西安办公室见过他。周五有个班加罗尔Ruby User Group的活动，叫<a href=\"http://blog.sidu.in/2007/08/thoughtworks-geeknight-meet-ola-bini-of.html\">Geek Night</a>，Sidu是活动的组织者。之前，他知道<a href=\"http://ola-bini.blogspot.com/\">Ola</a>会来，于是安排Ola介绍JRuby。当他看到我的时候，才知道我也来了班加罗尔，于是邀请我也一起参加活动。我问他，我是否需要准备什么，他建议我做一个XRuby的介绍。Ola会有一个45分钟左右JRuby方面的介绍，所以，我需要做的只是一个简单的XRuby介绍。很合我意，因为要用英文讲，所以，如果讲多了，我恐怕自己不成。我很快就准备好了一个很短的介绍。<br>\n<br>\nThoughtWorks做事总是要敏捷的。今天，我发现Ola没来，后来才知道Ola病了。所以，Ola的部分就取消了。Sidu问我怎么办，我只好硬着头皮答应由我讲一个长一点的，一个比较完整的XRuby介绍。晚上六点的活动，商量好这些的时候，已经是四点多了。所幸之前讲过XRuby的介绍，我把讲稿翻出来修改了一番，更新了一些状态，准备用在活动中。XRuby介绍这个稿子居然得到了反复应用，第一次在<a href=\"http://dreamhead.blogbus.com/logs/4858144.html\">北京Java User Group</a>，第二次在<a href=\"http://agilexa.thoughtworkers.org/articles/2007/05/19/event-2007-may-19th\">敏捷西安</a>，据说，XRuby的其他成员也用过。无论如何，我没想到，我个人的第三次居然是在班加罗尔，而且是英文。<br>\n<br>\n其实，最让我头疼的绝对不是介绍XRuby，而是用英文。这周在班加罗尔上课，对我来说，简直就是一周的英文课。所有课程所有讨论都是英文，我的英文水平让我经常就不知道大家在说什么。不过，自我感觉，经过一些锻炼之后，还是略有提高的。<br>\n<br>\n活动开始，我开始了第一次用英文在比较公开的场合讲东西。我的开场白是，这是我第一次用英文讲。起初，活动在一个小会议室进行，在我讲的过程中，进来的人越来越多，所以，我们又换到了一个比较大的会议室。因为用英文，我只能说，我尽量把我要表达的意思说出来，至于是否大家听懂了，我不好说。好在有讲稿，即便我讲得不够清楚，讲稿也会帮助大家多一些理解的。当翻到讲稿最后一页的时候，我长出了一口气。如果是用中文的话，我可以说得更多，至少我可以胡扯一些东西。对我来说，更大的挑战是Q&amp;A。我的听力本来就不是太好，印度口音更是经常让我犯晕。开始之前，我找了几个同事，如果我听不懂的话，他们可以为我解释一下。在提问者的宽容和几位同事的帮助之下，我成功的度过了Q&amp;A。问题倒不算太难，唯一让我不敢确认的是，我说的是否真的是我要表达的意思，希望没有大错。<br>\n<br>\n不管怎样，我用英文讲了一次XRuby，一次很有趣的经历。\n\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200708280049",
    "date": "2007-08-28",
    "time": "00:49",
    "title": "交流技巧",
    "tags": [
      "交流"
    ],
    "body": "<p>\n在ThoughtWorks里，交流是工作中非常重要的一个部分，在这里工作时间越长，这一点感觉得越加明显。今天，和我们团队中的一个人聊天，他教了我一些交流上的技巧，这里做一个简单的备忘。事实上，他教给我的远不止这些。<br>\n<br>\n交流中，最大的障碍就是双方是否真的理解了对方的意思。造成误解的原因可能有很多：<br>\n* 双方都认为自己理解了问题，但这种理解可能并不一致。<br>\n* 因为背景不同，所以，双方对达成一致所基于的假设是不同的。<br>\n* 语言之间的障碍，这点我最近颇有体会<br>\n* 双方对问题理解的深度不一致<br>\n<br>\n同事交给我的解决方案就是不断问问题，不断解释自己对问题的理解，对方接收到反馈就会判断与他的理解是否一致，然后再给出他的看法，这样几个来回下来，双方基本上就可以达成一致。有些人可能认为反复的问问题，反复澄清自己的理解似乎会让自己的看上去很傻，所以，听得差不多就不愿意问了。我们的根本目的是完成工作，如果因为前面不愿意看上去丢人，后面可能就要真正的丢人了。其实，没有人会认为把问题搞清楚是丢人的。<br>\n<br>\n再有一点，交流之后要尝试总结，通过总结：<br>\n* 确定真正理解问题所在<br>\n* 确定双方对问题有一个共同的接收标准<br>\n* 确定双方能够在进度上达成一致<br>\n<br>\n学到了，争取用起来！\n</p>\n\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200708241417",
    "date": "2007-08-24",
    "time": "14:17",
    "title": "写在迪拜机场",
    "tags": null,
    "body": "写下这篇blog时，我在迪拜机场。没错，阿联酋迪拜。<br>\n<br>\n起因是要到印度参加培训。ThoughtWorks通常会对入司的新员工进行一些培训，使其更加了解公司的文化和做事的风格，其中很著名的是TWU。不过，TWU是给毕业生预备的，所以，我没有机会参加。我去参加的是另外一个课程。不同于TWU固定在印度，这个课程的培训地点是变化的，这次刚好在印度的班加罗尔。<br>\n<br>\n要去印度，我却出现在阿联酋，是的，我是来转机的。只要有些地理常识都会发现这条路线极其诡异。据<a href=\"http://jessie2730.spaces.live.com/Blog/cns!2F7C6E350899952B!520.entry\">Jessie的blog</a>记载，她是这条诡异路线的始作俑者。早几天去TWU的几位同事是通过新加坡转机，至少从常识和心理上来说，更容易接受一些。<br>\n<br>\n这次坐飞机让我见识了一些新鲜的东西。我乘坐的是A340-300，很大的飞机，一排有八个人。每个面前都有一个小电视，配有一个遥控器，居然这个遥控器还是个游戏手柄，所以，在路上，我还自行娱乐了一下。一上飞机，就可以发现，每个人的座位上，都预备好了一些东西，比如小枕头，毯子和一些小东西。我以为大夏天的可以不用毯子，结果充足的空调还是让我决定把自己盖上，以免感冒。这次旅行是我第一次在飞机上过夜，因为起飞的时间就是23:55。个人而言，我不是特别喜欢长途旅行，尤其需要过夜的，身体会很疲劳。飞机会比火车舒服一些，但要在飞机上过夜，还真的不如火车的卧铺，无论我怎样调整姿势，总是不如躺着的感觉舒服。当然，比火车硬座要好得多。同机的有一群要到塞浦路斯去表演的小朋友，有他们在，飞机上热闹了许多。人家航空公司想得还真周全，每个人送了一个小玩具，孩子们很高兴的给周围的人展示着自己的玩具。<br>\n<br>\n到迪拜的时候是当地时间早上五点多，一下飞机却让我感到了桑拿天气，长期生活在这里的人真的要有很好的耐热能力才成。从我下飞机到再次上飞机，之间的间隔有六个小时。所以，我和同行的同事在机场可以活动的区间里转了一大圈，了解周边的环境。在一个免税的店里，他拿起一个Sony的耳机，我居然看到了中文，仔细一看，Made in China。在这里，中国人（至少是中国人面孔的）很多，让人误以为只是在国内的机场，经常可以听见有人在用中文聊天。当我们在一个地方喝水聊天的时候，竟然还有人用中文来向我们问路。就在写这篇blog的时候，后边过去的两个人在议论大连如何如何。迪拜的机场地上铺有地毯，这让我想起了我们公司的办公室。在办公室时，我时不时的就会坐在地上办公。在这里，可以看到很多人席地而卧，悠然入梦。<br>\n<br>\n就在刚刚，同事奇迹般的发现，居然有无线网可用，于是，赶紧打开机器，在迪拜机场发一篇blog，作为纪念。<br>\n<br>\n还有一段时间我才能再度起飞，若干小时之后，我会出现在印度。\n\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200708122031",
    "date": "2007-08-12",
    "time": "20:31",
    "title": "我要努力",
    "tags": [
      "脚下的路"
    ],
    "body": "在ThoughtWorks工作已经有三个月了，快乐的事情在blog上体现了不少。找点让我头疼的话题聊聊吧！<br><br>ThoughtWorks是个外企，所以，必然要大量的使用外语，而外语偏偏是我的弱项。当然，我没有不堪到一点英语不懂的份上。我的英语对付日常的读写没有什么问题，主要就是在听说上。我就是那种传统英语教导出来的哑巴英语，要不是之前和两个朋友曾经专门学过一段时间，我的英语恐怕到现在还是完全张不开嘴的水平，也就不可能能通过TW的面试。现在在北京的办公室里有不少来自其他办公室的同事，所以，不得不与他们进行交流。平时，有时还会有电话会议，原本听力就不那么好的我，再加电话里有些杂音，经常不知道对方在说什么。不过，自我感觉，这几个月下来英语还是有提高的，但为了如果想更好的与外国同事交流，英语还要进一步提高，这样的话，才可能讨论一些相对深入的话题。<br><br>前两天，和老大聊天，他提到了中国人同其他国家人的一个差别。我们比较含蓄，通常会在深思熟虑之后，才提出自己的问题，他们通常会把自己想到的都摆在台面上。所以，这就造成了一些沟通上的障碍，有些时候，我们本来已经发现了问题，但常常会考虑该不该把问题提出来，把问题提出来会带来什么样的影响。结果，往往是在思前想后的阶段，就耽误了一些事。当然，完全展现自己的想法也并不一定就是好事，有一些明显错误的东西还是有些浪费大家时间。和一个在微软的同学聊天，他也提到，他们公司也是鼓励大家想法说出来。只有把想法说出来了，它才是存在的，否则，最后的结果可能就是消亡在自己的大脑中。<br><br>现在在做的其实是一个产品方向，这就需要人有更加全面的能力。因为做项目的时候，我们往往只要关注特定的平台（OS、数据库、浏览器……），但是做产品要兼顾的内容就要广泛得多，有不少问题只有在特定的平台上才会显现出来，比如MySQL的数据库表名在Ubuntu下需要区分大小写，而在Windows上则不区分。这就暴露出我在这个方面的不足，我做过开发的平台其实并不多，所以，有些时候，我经常需要找同事来帮忙，还好，大家通常是只要自己知道，就会不遗余力的帮助你。<br><br>现在我实际上是在一个分布式的团队中工作。说实话，我并不太喜欢这种工作方式，因为可能一个和你工作了很长时间的人，甚至都不知道长成什么模样。道理上没什么，但总不如直接在一起工作，那样的话，交流成本更低。我现在更容易理解为什么我们公司要让大家围坐在一起，这样，有话就说了，即便是一些无聊的话。再有，不熟悉的人总不如熟悉的人交流起来得自然，公司经常会有一些team building的活动，而且通常会鼓励不熟悉的人坐在一起，其目的就是为了大家增进了解，这样的话，在工作中就可以更好的进行沟通。而对于一个分布式团队来说，这一点就很难实现。<br><br>之前做项目的时候，大多数时间都是拿到一个比较明确的任务，然后进行开发。而现在有些时候，某些任务并不是那么明确，虽然大的方向一直在那。仅仅拿远景说事，是不能完成任务的。这样的时候，是需要一些主管能动性让那些大目标变成一个个具体可行的目标。由于适应了之前那种工作方式，我经常会在那里等待。这在无形中就是一种浪费，对公司来说，也是一种损失。<br><br>这样那样的问题，只能说明一点，对于我现在所从事的工作而言，我在某些方面还存在一些不足。发现不足是进步的基础，努力让自己成为一个更加合格的ThoughtWorker。\n\t\n\t\n\t\n\t\n\t\n\t\n\t<!--\n\t\t@page { size: 21cm 29.7cm; margin: 2cm }\n\t\tP { margin-bottom: 0.21cm }\n\t-->\n\t\n\n\n\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200708081924",
    "date": "2007-08-08",
    "time": "19:24",
    "title": "XRuby0.3.0——奥运倒计时一周年纪念版",
    "tags": [
      "XRuby"
    ],
    "body": "XRuby0.3.0发布了！恰好今天是奥运倒计时一周年，所以，这个版本顺理成章的成了纪念版。<br><br>在这个版本中，除了让更多单元测试通过之外，最大的变化是在Annotation的应用上。关于Annotation的工作，我已经在自己的blog上讨论过一些，这里再整理一下。<br><br>Ruby的方法总要有一个对应的底层语言实现。在C Ruby中，这个对应就是一个C的函数，而定义的时候，直接使用函数指针去做这个关联。而在Java中，因为没有函数指针，作为替代方案，我们可以使用一个对象。在XRuby的实现中，RubyMethod的存在就是为了这个目的。所以，在XRuby中对应到Ruby的方法都源自RubyMethod，比如下面这段代码：<br><br>public class String_to_f extends RubyNoArgMethod {<br>&nbsp;&nbsp; protected RubyValue run(RubyValue receiver, RubyBlock block) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((RubyString)receiver).to_f();<br>&nbsp;&nbsp; }<br>}<br><br>从上面展示的代码中，我们可以看到，为了实现这段方法，最终需要访问receiver的内容，而且，在事实的开发中，我们经常发现一个两难的抉择：究竟把方法的具体实现放在RubyMethod中还是放在Java的方法中。<br><br>有了对应的实现，我们还需要将它注册到系统中：<br>StringClass.defineMethod(“to_f”, new String_to_f());<br><br>这段虽然不复杂，重复编写也不是一件让人愉快的事情。<br><br>通过Annotation，我们可以更好的解决这个问题，下面便是对应于上面实现的代码：<br><br>@RubyLevelClass(name=\"String\")<br>public class RubyString {<br>&nbsp;&nbsp;&nbsp; @RubyLevelMethod(name=\"to_f\")<br>&nbsp;&nbsp;&nbsp; public RubyFloat to_f() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>在这里，我们使用RubyLevelMethod将一个Java的方法和Ruby的方法绑定在一起，这个Annotation表示，一方面会生成一个对应于这个方法的RubyMethod实现满足调用规则，另一方面会在Ruby的类中定义出这个方法，减少了一些重复编码的工作量。使用Annotaion避免了前面提及的那种两难，所有的方法都实现在Java方法中即可，这样，便可以有效的减少设计上的迷惑。再有，这个Annotation可以让Java方法和Ruby方法的关联一目了然。<br><br>一如既往的欢迎对XRuby有兴趣的人加入到XRuby的开发中来，在这里，总是有一些有趣的问题可以解决。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200708071706",
    "date": "2007-08-07",
    "time": "17:06",
    "title": "与Annotation打交道",
    "tags": [
      "我眼看世界"
    ],
    "body": "因为给XRuby做代码标记的原因，最近一直在Annotation和打交道。在我看来，Annotation是Java 5所有新语言特性中，唯一很难一下子看清楚的特性。其它的特性只要用JAD反编译一下生成的字节码，就一目了然了。我手头的JAD只能处理1.4的字节码，所以，Annotation的某些特性并不能直接反编译出来，比如缺省值。从现实的情况来看，Annotation已经开始有一些不错的应用，比如EJB 3.0，比如JUnit 4。<br><br>从为XRuby写代码的经验来看，Annotation真的是一个不错的东西，应用了Annotation之后，代码变得更加干净，XRuby的代码因此就变得清爽了不少。XRuby通过Annotation做了许多代码生成的工作，如果采用手工编码的方式，这些代码没有难度，只有复杂度。重复的代码写起来，只会让人感到繁琐。<br><br>XRuby中运用Annotation的方式本质上相当于在做编译器的工作。对Annotation的解析，相当于parser解析源代码，当然，相对于parser来说，解析Annotation要简单得多。之后的过程就是类似的过程，根据前面解析的结果对应着进行代码生成。<br><br>在实现XRuby Annotation的过程中，还有一些有趣的工作。比如如何设计Annotation。最初的设计中，RubyLevelMethod有一个type属性，用以标识方法的类型，主要是为了满足XRuby一些优化手段，比如对于无参数和一个参数的方法调用，会做一些特殊处理提高性能。不过，这样的方法通常会有一些特别的签名，这样的签名完全是可以检测出的，所以，实际上这个type属性并不需要，而且，偶尔的误操作（比如无参数方法的type写成了一个参数），还会抛出异常。所以，最终type这个属性被去掉了，当然，这么做需要额外付出一些努力，不过，相对而言，这种努力是值得的。这个问题实际上类似于语言设计一样，哪些东西设计到语言里，哪些部分是隐含可以得到的。<br><br>Annotation可以给我们一些提示，通过诸如代码生成等工作，从而把一些操作从原来的硬编码的方式中转移出去，比如事务，AOP等等。我相信，这样会带来一些设计思路的转变，从而更好的进行设计上的划分。更进一步，设计中完全可以加入更多的业务特性，也就会让代码更有DSL的味道。<br><br>对比于Java中常见的XML方式，我更喜欢Annotation。首先，它和代码结合的更紧密，这样，在阅读的时候，可以更直观的去理解一些东西，而XML的方式中，秘密都在另外的地方。其次，IDE工具可以很好的联系源码，做一些查找引用某些类的情况就会简单得多。当然，有个问题，每次修改可能都需要重新编译代码，这个问题在开发XRuby Annotation的过程中经常遇到。<br><br>InfoQ的Floyd前不久在BEA User Group的活动中谈及企业级Java前景时，提到了他认为几个重要的趋势，包括POJO、IoC（DI），再有就是Annotation。在对Annotation有了更多的了解之后，我认为Annotation是个好东西，只是不知道它的出现是不是有些晚。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707302045",
    "date": "2007-07-30",
    "time": "20:45",
    "title": "用Annotation标记Ruby方法",
    "tags": [
      "向下走"
    ],
    "body": "JRuby最近在讨论是否要支持Java 5。<br><br>JRuby邮件列表的讨论<br><a href=\"http://www.nabble.com/Moving-to-Java-5--tf4131923.html\" target=\"_blank\">http://www.nabble.com/Moving-to-Java-5--tf4131923.html</a><br><br>InfoQ报道<br><a href=\"http://www.infoq.com/news/2007/07/jruby-java5-move\" target=\"_blank\">http://www.infoq.com/news/2007/07/jruby-java5-move</a><br><a href=\"http://www.infoq.com/cn/news/2007/07/jruby-java5-move\" target=\"_blank\">http://www.infoq.com/cn/news/2007/07/jruby-java5-move</a><br><br>XRuby起步就是从Java 5开始的，所以，不存在这个问题。在他们还在为此争论的时候，受到Charles Nutter最开始那封邮件的启发，我已经完成了Annotation标记Java代码和Ruby代码绑定的第一个版本。<br><br>下面是一个例子：<br>@RubyLevelClass(name=\"ClassFactory\")<br>public class ClassFactoryValue extends RubyValue {<br>&nbsp;&nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; @RubyLevelMethod(name=\"test\", type=MethodType.NO_ARG)<br>&nbsp;&nbsp;&nbsp; public RubyValue test() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return RubyConstant.QNIL;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>首先，用@RubyLevelClass标记出这个Java类对应着一个Ruby层次上的类，其名称为ClassFactory。然后，用@RubyLevelMethod标记出一个Java方法是对应着Ruby的方法，它的Ruby名称为test，而且它是无参数的。<br><br>我们可以这样利用这段代码：<br>RubyClass klass = RubyTypeFactory.getClass(ClassFactoryValue.class);<br><br>通过RubyTypeFactory，我们可以生成ClassFactoryValue将Java层次和Ruby层次对应起来的代码，生成代码大致如下：<br>public class ClassFactoryValue$ClassBuilder implements RubyClassBuilder {<br>&nbsp;&nbsp;&nbsp; public RubyClass createRubyClass() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RubyClass rubyclass = RubyAPI.defineClass(\"ClassFactory\", RubyRuntime.ObjectClass);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodFactory methodfactory = MethodFactory.createMethodFactory(ClassFactoryValue.class);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rubyclass.defineMethod(\"test\", methodfactory.getMethod(\"test\", MethodType.NO_ARG));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return rubyclass;<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>这里用之前介绍过的<a href=\"http://dreamhead.blogbus.com/logs/6520681.html\" target=\"_blank\">生成方法Wrapper的MethodFactory</a>去辅助代码生成，简化了编写。<br><br>XRuby本身为了生成bytecode已经做了大量的代码生成，这里只是把代码生成更多的用在了其他的部分。把这里的Annotation更广泛的用在XRuby中，会让代码看上去更干净。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707292344",
    "date": "2007-07-29",
    "time": "23:44",
    "title": "精神的胜利",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p>2007年，亚洲杯冠军，伊拉克足球队。<br><br>谁都知道，现在的伊拉克是个什么样子。来自这个国家的球队，能够出现在亚洲杯决赛圈已经不易，更何况一步一步登上了亚洲之巅。在决赛场上，我们看到的内容已经远远超出足球的技战术范围。困境中的伊拉克爆发出惊人的战斗力，让对面的对手完全失去了自己的方向。战至最后阶段，伊拉克的队员几乎完全体力透支，但他们依然不断拼搏，将胜利拿下。<br><br>伊拉克太需要胜利了，这个遍体疮痍的国家需要胜利，这种胜利会给这个民族注入他们目前最需要的信心。信心，对个人，对民族都至关重要，尤其当几乎一切都在一种最糟糕的状态下，这是一针强心剂。<br><br>我不想讨论比赛，毕竟这只是一场亚洲的比赛，但我喜欢这样结果。在极大的压力下，人们往往会发挥超出自身实力的能力，会让观者得到极大的鼓舞，这就是竞技体育一个重要魅力。<br><br>精神胜利的典范应该是意大利的足球。<br>1982年，意大利在假球丑闻中成为了世界杯冠军。<br>24年后，2006年世界杯，电话门丑闻，意大利队又一次坚强的笑到了最后。<br>电话门丑闻使得AC米兰新赛季从一开始就不被人看好，但正是在这样的不利中，他们成为了2007年欧洲冠军联赛的冠军。</p><p>我喜欢这样的足球，精神的胜利带给人们的享受远远大于竞技的内容，虽然那是一种迫不得已的无奈。</p><p>恭喜，亚洲足球的新科状元，伊拉克足球队。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707221653",
    "date": "2007-07-22",
    "time": "16:53",
    "title": "你的心情还好吗？",
    "tags": [
      "脚下的路"
    ],
    "body": "<p>周末，跨越了大半个北京城和几个老朋友聚到了一起，由于有一段时间没有见到，自然一个个都变成了话痨。一个朋友的精神状态对比于之前见到的他来说，明显好了许多，生活显然也丰富多彩了一些。聊到原因，他从之前一个很糟糕的情况逐渐摆脱了出来，心情好了，自然而然人的状态也随之好转了。当然，朋友们也看到了我类似的变化。加入到ThoughtWorks后，我整个人的状态变得明显不同了，更活泼了。按照一个朋友的说法，明显是被释放的结果。</p><p>曾经和老妈聊天，我说找工作的标准是“钱多和心情好” 至少有一样。其实，虽然我也知道金钱的重要性，但我一直没有树立了一个良好的追逐金钱的观念，所以，我真正看重的是心情。工作最初的部门给我留下了一些很美好的回忆，其中一个重要的原因就是那里给了我一个良好的心情，周围的环境让我感到很舒服，所以，在那里我的表现也得到了大家的认可。虽然后来<a href=\"http://dreamhead.blogbus.com/logs/1103236.html\" target=\"_blank\">我离开了那里</a>，但原因也与环境无关。反而，每次我回到沈阳，都会回到那个部门与一些老朋友叙旧。在我正式离职之前，我还曾经到那个部门与大家分享了一些Ruby的东西。</p><p>之后工作的那个部门，虽然我从中也学到了不少的东西，但自己整体评价我那两年的表现，很糟糕。自我分析的结果是，我一直没有找一个让自己心情愉快的理由。虽然大家也经常在一起玩，但那个部门的整体氛围一直不是我很喜欢的，人和人之间表现得也不是那么友善。正所谓祸不单行，有一段时间，我觉得自己很“背”，把该倒的霉在那一段时间都倒了。所以，在这种氛围中工作了一段时间之后，我感觉很压抑。我知道自己肯定会离开，只是不知道什么时候，下一个落脚点会在哪里，直到我找到了ThoughtWorks。</p><p>一个朋友看到我写的那篇《<a href=\"http://dreamhead.blogbus.com/logs/5771770.html\" target=\"_blank\">一月思想工作者</a>》给出的评价是如鱼得水。经过长时间的压抑之后，我感觉自己一下子解脱了。我很快就融入了这样的环境中，以至于一些新来的同事误以为我已经在这里工作了很长的时间。ThoughtWorks给了我一个我喜欢的环境。我不会为了那些没有意义的东西，消磨自己锐气。 </p><p>在ThoughtWorks的招聘流程中，有一条原则，如果应聘者让你感觉不舒服，你就完全有理由拒绝这个应聘者。这是一条看似不合理的原则，但对于维护一个良好的企业文化却至关重要。因为招进来的人是要和我们一起工作的。如果这个人在应聘过程中让人不舒服，那么在日后的工作过程中，他可能也同样会表现得让不舒服，让人不舒服的结果就会是影响工作效率，精力被浪费在一些无谓的地方。事实上，正是有这样一条原则，所以，几乎与所有ThoughtWorker在一起都会让人感觉很舒服。不管这个人来自哪里，即便是刚刚认识，也会很快就会熟悉起来。</p><p>你的工作环境给了你怎样的心情呢？ </p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707152238",
    "date": "2007-07-15",
    "time": "22:38",
    "title": "在Agile Day讲Ruby on JVM",
    "tags": [
      "脚下的路"
    ],
    "body": "去年Agile Day的时候，我还在沈阳，没有近距离感受ThoughtWorks带来的敏捷盛宴。今年的Agile Day，我已经成为了一名ThoughtWorker。我不仅仅有机会到了现场，更是成为了一个演讲者。演讲的题目自然是我现在的工作重点：Ruby on JVM。公司对Ruby的关注从这次Agile Day的日程安排中可见一斑，在技术/工具分会场的四场演讲中，就有两场与Ruby相关：第一场我现在的老板Chad讲企业级Ruby和我的Ruby on JVM。<br><br>虽然讲的是自己熟悉的东西，但准备这次演讲的材料还是花了很大的力气。面对的观众不同，讲的内容就应该有所差别。从众多相关的内容选择出让观众有兴趣的内容，而且深浅适度，这是个问题。所以，每次有讲演的机会，我都对仔细考虑讲的内容。好在在ThoughtWorks总是可以找到人一起讨论，一旦确定了演讲的基调，就拥有了骨架，剩下的问题就是血肉丰满起来。在准备这次演讲的内容过程中，yawl和Ola Bini都给了我不少建议。<br><br>这次Agile Day的活动，公司允许任何人在中国的ThoughtWorker参加。本来周六的活动，人在西安的ThoughtWorker周五晚上出发。为了更好的准备这次的演讲，我提前一天到北京。对于自己所讲的内容，因为经过了自己的思考，我觉得还好，我最主要的担心就是怕自己会紧张。在北京办公室准备的过程中，我才发现，原来大家都一样，每个演讲者都是怕自己会紧张，所以，为了能在大会时有个良好的表现，大家都在一遍遍回顾着自己的所讲的内容，偶尔还要拉几个观众实战一下。我就给人当了演习观众。当然，我也会拉着别人来当观众。第一次讲的时候，我能清楚的感觉到自己在开始的时候，声音有一些微微的颤抖，语言的表达上有些凌乱，好在这是练习。Mingle产品经理Adam看我的讲稿之后，第一反应就是问我Mingle是否可以运行在XRuby上，这也增强了我对讲稿的信心，不过，我的答案还是令人遗憾的“暂时不行“。<br><br>Agile Day当天，ThoughtWorker们都会充当杂役，所以，早早就去现场干活。稍微得到一些清闲的时候，脑子里就一次次回顾着要讲的内容。确实这次大会人来了好多，要在这么多人面前讲东西，无论事先我做了多少准备，我还是会觉得紧张，尽管表面上还和同事们开着玩笑。其实，原本我希望在Agile Day多听几场演讲，但事实上，在别人演讲的时候，我都在休息室准备自己的演讲，根本没有心情去听。Chad结束演讲之后跟我说，我还在演讲中提到你了，我只能很抱歉的说，我没有听到。真正到自己站在台上开始演讲，我发现自己的声音没有了练习时的颤抖，这也给了自己不少信心。随着演讲的进行，我也就自己渐渐进入了状态，也就不太顾忌那些无关的东西了。至于表现得到底如何，我不知道，别人评价去吧！gigix之后就告诉我，我经常出现背向观众的情况。之后，精神一下子松懈下来，感觉好累，在外面的沙发上，躺了好长时间，所以，我后面一场的演讲也没怎么听。对我而言，当我是演讲者时，其实往往意味着失去一次很好的学习机会。<br><br>虽然大家都愿意去听各种各样的演讲，但实际上，一个演讲真正能让人记住的只有非常有限的内容，所以，我所希望的只是通过这次演讲，让更多的人知道我们在Ruby on JVM上的努力是有价值的。如果能够吸引更多的人加入到这个过程中来，那就是太完美了。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707082322",
    "date": "2007-07-08",
    "time": "23:22",
    "title": "生成方法的Wrapper",
    "tags": [
      "XRuby"
    ],
    "body": "<p>在《<a href=\"http://dreamhead.blogbus.com/logs/3776107.html\" target=\"_blank\">管窥Ruby——方法定义</a>》中，我们曾经讨论过在Java中实现方法定义时，因为Java语言的限制，我们不得不为方法加上了一个Wrapper，让它可以满足接口定义的需要。事实上，XRuby一直就是这么做的，通常Wrapper放在com.xruby.runtime.builtin这个包中，而诸如Array、Hash、String之类的具体实现放在com.xruby.runtime.value这个包中。初涉XRuby的人，常常会被这两个包搞得晕头转向。到底方法的具体实现应该放在哪里，大多是根据感觉来定义的。<br><br>在那篇blog中，我还讨论了JRuby的实现，不过，那里面的讨论并不是特别的完善。事实上，除了利用reflection，其中还有一种方式，通过代码生成动态产生这个Wrapper。我将这个实现借鉴到了XRuby中。通过采用这种生成Wrapper的方式，我们就可以在实际编写的代码中，忽略掉Wrapper部分的实现，而将原来令人混淆的builtin和value包统一起来。<br><br>下面是Array的clear方法原来的实现：<br>class Array_clear extends RubyNoArgMethod {<br>&nbsp;&nbsp;&nbsp; protected RubyValue run(RubyValue receiver, RubyBlock block) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RubyArray value = (RubyArray) receiver;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value.clear();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>在这里，其实只要将receiver转型，然后调用它的方法就好。实际上，生成的代码只是做这样简单的工作就好，当然，根据具体的方法还会略有些差别。关于如何使用ASM进行代码生成，我在几篇blog中都进行了介绍，这里就不介绍生成代码的实现了。下面是在代码中如何使用这个方法。<br>MethodFactory factory = MethodFactory.createMethodFactory(RubyArray.class);<br>c.defineMethod(\"clear\", factory.getMethod(\"clear\", 0));<br><br>在这个方法的实现过程中，还有一些比较有趣的点。首先，并不是每次都需要调用getMethod都要动态生成一个类，因为一个类一旦已经加载，就没有必要再次进行加载，即便强行加载，class loader也是会抱怨的。所以，在创建类之前，我们需要尝试加载一下这个，如果加载成功，便省去了再次生成的麻烦。</p><p>再有，每次都去创建这个Wapper实际上也没有什么必要，一次生成之后，保存起来就可以了。如果我们把它放在class path中，那么我们尝试加载就会成功，所以，刚才提到的尝试加载还有这样一层含义。</p><p>作为builtin实现，我们还是希望这些生成类是可以放在我们最终发布的jar文件中，所以，我们通常的做法，是在打包之前，先用XRuby做一次最简单的执行，让所有的Wrapper生成出来，这样，打包的时候就可以将它们都加入其中。<br><br>具体的做法可以参考XRuby中MethodFactory和build.xml。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707082322",
    "date": "2007-07-08",
    "time": "23:22",
    "title": "生成方法的Wrapper",
    "tags": [
      "XRuby"
    ],
    "body": "<p>在《<a href=\"http://dreamhead.blogbus.com/logs/3776107.html\" target=\"_blank\">管窥Ruby——方法定义</a>》中，我们曾经讨论过在Java中实现方法定义时，因为Java语言的限制，我们不得不为方法加上了一个Wrapper，让它可以满足接口定义的需要。事实上，XRuby一直就是这么做的，通常Wrapper放在com.xruby.runtime.builtin这个包中，而诸如Array、Hash、String之类的具体实现放在com.xruby.runtime.value这个包中。初涉XRuby的人，常常会被这两个包搞得晕头转向。到底方法的具体实现应该放在哪里，大多是根据感觉来定义的。<br><br>在那篇blog中，我还讨论了JRuby的实现，不过，那里面的讨论并不是特别的完善。事实上，除了利用reflection，其中还有一种方式，通过代码生成动态产生这个Wrapper。我将这个实现借鉴到了XRuby中。通过采用这种生成Wrapper的方式，我们就可以在实际编写的代码中，忽略掉Wrapper部分的实现，而将原来令人混淆的builtin和value包统一起来。<br><br>下面是Array的clear方法原来的实现：<br>class Array_clear extends RubyNoArgMethod {<br>&nbsp;&nbsp;&nbsp; protected RubyValue run(RubyValue receiver, RubyBlock block) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RubyArray value = (RubyArray) receiver;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value.clear();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>在这里，其实只要将receiver转型，然后调用它的方法就好。实际上，生成的代码只是做这样简单的工作就好，当然，根据具体的方法还会略有些差别。关于如何使用ASM进行代码生成，我在几篇blog中都进行了介绍，这里就不介绍生成代码的实现了。下面是在代码中如何使用这个方法。<br>MethodFactory factory = MethodFactory.createMethodFactory(RubyArray.class);<br>c.defineMethod(\"clear\", factory.getMethod(\"clear\", 0));<br><br>在这个方法的实现过程中，还有一些比较有趣的点。首先，并不是每次都需要调用getMethod都要动态生成一个类，因为一个类一旦已经加载，就没有必要再次进行加载，即便强行加载，class loader也是会抱怨的。所以，在创建类之前，我们需要尝试加载一下这个，如果加载成功，便省去了再次生成的麻烦。</p><p>再有，每次都去创建这个Wapper实际上也没有什么必要，一次生成之后，保存起来就可以了。如果我们把它放在class path中，那么我们尝试加载就会成功，所以，刚才提到的尝试加载还有这样一层含义。</p><p>作为builtin实现，我们还是希望这些生成类是可以放在我们最终发布的jar文件中，所以，我们通常的做法，是在打包之前，先用XRuby做一次最简单的执行，让所有的Wrapper生成出来，这样，打包的时候就可以将它们都加入其中。<br><br>具体的做法可以参考XRuby中MethodFactory和build.xml。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707042118",
    "date": "2007-07-04",
    "time": "21:18",
    "title": "消除浪费的敏捷",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p><a href=\"http://www.infoq.com/cn/news/2007/07/agile-and-lean\" target=\"_blank\">敏捷的核心：消除浪费，走向精益</a><br><br>谈到敏捷，你会想起什么呢？测试驱动开发？结对编程？我刚到ThoughtWorks不久，gigix就和我提到过，关于敏捷消除浪费的观点，说实话，我一直不太理解这个观点。不过，随着在ThoughtWorks体会的点滴逐渐增多，我慢慢的体会到这句话的含义。<br><br>举个简单的例子，为什么要做测试驱动开发呢？从字面上看，将“测试”放在前面，提高了测试的重要性，告诉人们应该注意这一重要但经常被忽略的事实，这一点对于保证软件质量来说，确实是应该的，再有单元测试的存在让自动化回归测试变得容易了许多，还有写测试的价值会让人从不同的角度考虑设计，也许会让设计的耦合性大大降低。人们通常想不通的一点是，为什么要先写测试。如果只是单纯的交换编码和测试的位置，实际上并不会带来太多的好处。那该从怎样的角度理解测试驱动开发呢？测试代表着什么呢？需求。软件开发的目的就是为了满足需求，如果能够把需求确定了，编写代码满足它就相对容易多了。从需求出发，按照需求编写满足需求的最简单代码，而不去做许多额外的工作，这就是测试驱动开发不同于传统编写方式的地方。按照传统的方式先写代码，后写测试的话，我们的测试代码需要做的工作尽可能覆盖代码的路径，而为了覆盖面尽可能大，我们就需要花费许多额外的努力，这就是浪费。<br><br>敏捷的思想不仅仅体现在测试上，在这两个月左右的时间里，我对设计的理解也开始发生了一些转变。曾经我对设计的理解是设计一个能够应对未来变化的美好结构，但事实上，这种竭尽全力设计出来的“好”设计总是轻而易举的被现实问题打败。为什么呢？因为这个设计是想出来的，并不是基于实际的需求逐步演化出来的。在ThoughtWorks的招聘流程中，会有一个编写程序的过程。在这个过程中，我们总会听到应聘者说他的设计是为了应对将来的变化。但事实上，这样的变化是否存在呢？不一定，多半是没有的。所以，许多看起来比较华丽的设计完全经不起推敲。其中的一个例子是，为了面向接口编程，设计一个接口，却只有一个对应的实现类，本应枝繁叶茂的继承树显得十分单薄。当然，这里并不是说面向接口编程就不好，但当只有一种情况时，就做这种抽象显然是一种过度设计，过度设计就意味着浪费，在这个例子里面，至少需要多付出编写一个接口的代价。也许你会说，未来如果真的出现第二种或者更多的情况，那该怎么办。很简单，等真正出现了再做也来得及。<br><br>当然，问题并不绝对。一个例子是在数据库的设计通常我们会提前做出。基于前面的讨论，也许有人会认为这么做不太敏捷，恰恰相反，因为随着项目的进行，数据库修改的成本会越来越大，所以，我们宁肯在项目的前期多做些功课，以保证后面尽可能不去或少去修改它，以便减少浪费，所以，这种选择也是敏捷指导下的选择。<br><br>也许，这种讨论会给人一种人嘴两张皮的印象，其实，这和做许多事一样，就是一个度的把握。所以，很多人都看了一些敏捷的书，但用到实际中，却总觉得不是那么回事。</p><p>如果开头的那篇文章是写给各种各样的管理者的，那我这篇算是写给程序员的吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200707042118",
    "date": "2007-07-04",
    "time": "21:18",
    "title": "消除浪费的敏捷",
    "tags": [
      "我眼看世界"
    ],
    "body": "<p><a href=\"http://www.infoq.com/cn/news/2007/07/agile-and-lean\" target=\"_blank\">敏捷的核心：消除浪费，走向精益</a><br><br>谈到敏捷，你会想起什么呢？测试驱动开发？结对编程？我刚到ThoughtWorks不久，gigix就和我提到过，关于敏捷消除浪费的观点，说实话，我一直不太理解这个观点。不过，随着在ThoughtWorks体会的点滴逐渐增多，我慢慢的体会到这句话的含义。<br><br>举个简单的例子，为什么要做测试驱动开发呢？从字面上看，将“测试”放在前面，提高了测试的重要性，告诉人们应该注意这一重要但经常被忽略的事实，这一点对于保证软件质量来说，确实是应该的，再有单元测试的存在让自动化回归测试变得容易了许多，还有写测试的价值会让人从不同的角度考虑设计，也许会让设计的耦合性大大降低。人们通常想不通的一点是，为什么要先写测试。如果只是单纯的交换编码和测试的位置，实际上并不会带来太多的好处。那该从怎样的角度理解测试驱动开发呢？测试代表着什么呢？需求。软件开发的目的就是为了满足需求，如果能够把需求确定了，编写代码满足它就相对容易多了。从需求出发，按照需求编写满足需求的最简单代码，而不去做许多额外的工作，这就是测试驱动开发不同于传统编写方式的地方。按照传统的方式先写代码，后写测试的话，我们的测试代码需要做的工作尽可能覆盖代码的路径，而为了覆盖面尽可能大，我们就需要花费许多额外的努力，这就是浪费。<br><br>敏捷的思想不仅仅体现在测试上，在这两个月左右的时间里，我对设计的理解也开始发生了一些转变。曾经我对设计的理解是设计一个能够应对未来变化的美好结构，但事实上，这种竭尽全力设计出来的“好”设计总是轻而易举的被现实问题打败。为什么呢？因为这个设计是想出来的，并不是基于实际的需求逐步演化出来的。在ThoughtWorks的招聘流程中，会有一个编写程序的过程。在这个过程中，我们总会听到应聘者说他的设计是为了应对将来的变化。但事实上，这样的变化是否存在呢？不一定，多半是没有的。所以，许多看起来比较华丽的设计完全经不起推敲。其中的一个例子是，为了面向接口编程，设计一个接口，却只有一个对应的实现类，本应枝繁叶茂的继承树显得十分单薄。当然，这里并不是说面向接口编程就不好，但当只有一种情况时，就做这种抽象显然是一种过度设计，过度设计就意味着浪费，在这个例子里面，至少需要多付出编写一个接口的代价。也许你会说，未来如果真的出现第二种或者更多的情况，那该怎么办。很简单，等真正出现了再做也来得及。<br><br>当然，问题并不绝对。一个例子是在数据库的设计通常我们会提前做出。基于前面的讨论，也许有人会认为这么做不太敏捷，恰恰相反，因为随着项目的进行，数据库修改的成本会越来越大，所以，我们宁肯在项目的前期多做些功课，以保证后面尽可能不去或少去修改它，以便减少浪费，所以，这种选择也是敏捷指导下的选择。<br><br>也许，这种讨论会给人一种人嘴两张皮的印象，其实，这和做许多事一样，就是一个度的把握。所以，很多人都看了一些敏捷的书，但用到实际中，却总觉得不是那么回事。</p><p>如果开头的那篇文章是写给各种各样的管理者的，那我这篇算是写给程序员的吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200706301750",
    "date": "2007-06-30",
    "time": "17:50",
    "title": "Javac背后的故事——创建对象",
    "tags": [
      "Java"
    ],
    "body": "要让Java这个面向“对象”的世界正常运作，创建对象就是一项不可或缺的操作。<br><br>public class NewMain {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Object();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>用javap反编译上面的代码，我们可以得到下面的指令，这里省去了javac暗中创建的构造函数。<br><br>public class NewMain extends java.lang.Object{<br>&nbsp;&nbsp;&nbsp; ...<br>public static void main(java.lang.String[]);<br>&nbsp; Code:<br>&nbsp;&nbsp; 0:&nbsp;&nbsp; new&nbsp;&nbsp;&nbsp;&nbsp; #3; //class java/lang/Object<br>&nbsp;&nbsp; 3:&nbsp;&nbsp; invokespecial&nbsp;&nbsp; #8; //Method java/lang/Object.\"&lt;init&gt;\":()V<br>&nbsp;&nbsp; 6:&nbsp;&nbsp; return<br>}<br><br>从这段代码中，我们可以清晰的看出创建对象（new）和调用构造函数（invokespecial）两个过程。关于这个问题，我在《<a href=\"http://dreamhead.blogbus.com/logs/456837.html\" target=\"_blank\">对象的生命</a>》中曾经进行过讨论。<br><br>既然javac将一个new的动作被解释为两条指令，那在JVM的层面上，我们当然就可以将它们分开。下面是一段没什么实际用途的代码，只是证明这个观点可行性。<br><br>public class NewGenerator {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String className = \"New\";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cw.visit(Opcodes.V1_2, Opcodes.ACC_PUBLIC, className, null, \"java/lang/Object\", null);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method m = Method.getMethod(\"void main (String[])\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, m, null, null, cw);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.newInstance(Type.getType(Object.class));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Label label = mg.newLabel();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.ifNonNull(label);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.mark(label);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.getStatic(Type.getType(System.class), \"out\", Type.getType(PrintStream.class));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.push(\"new object is not null\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.invokeVirtual(Type.getType(PrintStream.class), Method.getMethod(\"void println(java.lang.String)\"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.returnValue();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.endMethod();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cw.visitEnd();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputStream os = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os = new FileOutputStream(className + \".class\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.write(cw.toByteArray());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (os != null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>这段代码生成的类是能够运行的，有兴趣的可以自己试一下。这段代码的作用是new出一个对象之后，如果这个对象非空的话，就会产生一个输出：<br>&nbsp;&nbsp;&nbsp; new object is not null<br><br>当然，如果尝试用这个对象做一些其它的操作，会有错误等待着我们，因为这个对象并不是一个完整的对象。在<a href=\"http://java.sun.com/docs/books/jvms/\" target=\"_blank\">JVM规范</a>中有相关的解释：<a href=\"http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc10.html\" target=\"_blank\">new指令</a>并不能完整创建出一个新的对象，直到对未初始化的对象调用了实例初始化方法才会完成实例的创建。这段代码也正好符合《<a href=\"http://dreamhead.blogbus.com/logs/456837.html\" target=\"_blank\">对象的生命</a>》中的解释，它只是负责做出申请内存。当然，在JVM中，它的实际工作要略多一些，如果这个对象的类没有加载，就会加载相应的类。<br>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200706301750",
    "date": "2007-06-30",
    "time": "17:50",
    "title": "Javac背后的故事——创建对象",
    "tags": [
      "Java"
    ],
    "body": "要让Java这个面向“对象”的世界正常运作，创建对象就是一项不可或缺的操作。<br><br>public class NewMain {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Object();<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>用javap反编译上面的代码，我们可以得到下面的指令，这里省去了javac暗中创建的构造函数。<br><br>public class NewMain extends java.lang.Object{<br>&nbsp;&nbsp;&nbsp; ...<br>public static void main(java.lang.String[]);<br>&nbsp; Code:<br>&nbsp;&nbsp; 0:&nbsp;&nbsp; new&nbsp;&nbsp;&nbsp;&nbsp; #3; //class java/lang/Object<br>&nbsp;&nbsp; 3:&nbsp;&nbsp; invokespecial&nbsp;&nbsp; #8; //Method java/lang/Object.\"&lt;init&gt;\":()V<br>&nbsp;&nbsp; 6:&nbsp;&nbsp; return<br>}<br><br>从这段代码中，我们可以清晰的看出创建对象（new）和调用构造函数（invokespecial）两个过程。关于这个问题，我在《<a href=\"http://dreamhead.blogbus.com/logs/456837.html\" target=\"_blank\">对象的生命</a>》中曾经进行过讨论。<br><br>既然javac将一个new的动作被解释为两条指令，那在JVM的层面上，我们当然就可以将它们分开。下面是一段没什么实际用途的代码，只是证明这个观点可行性。<br><br>public class NewGenerator {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String className = \"New\";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cw.visit(Opcodes.V1_2, Opcodes.ACC_PUBLIC, className, null, \"java/lang/Object\", null);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method m = Method.getMethod(\"void main (String[])\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GeneratorAdapter mg = new GeneratorAdapter(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, m, null, null, cw);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.newInstance(Type.getType(Object.class));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Label label = mg.newLabel();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.ifNonNull(label);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.mark(label);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.getStatic(Type.getType(System.class), \"out\", Type.getType(PrintStream.class));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.push(\"new object is not null\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.invokeVirtual(Type.getType(PrintStream.class), Method.getMethod(\"void println(java.lang.String)\"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.pop();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.returnValue();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mg.endMethod();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cw.visitEnd();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputStream os = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os = new FileOutputStream(className + \".class\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.write(cw.toByteArray());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } finally {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (os != null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.close();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>这段代码生成的类是能够运行的，有兴趣的可以自己试一下。这段代码的作用是new出一个对象之后，如果这个对象非空的话，就会产生一个输出：<br>&nbsp;&nbsp;&nbsp; new object is not null<br><br>当然，如果尝试用这个对象做一些其它的操作，会有错误等待着我们，因为这个对象并不是一个完整的对象。在<a href=\"http://java.sun.com/docs/books/jvms/\" target=\"_blank\">JVM规范</a>中有相关的解释：<a href=\"http://java.sun.com/docs/books/jvms/second_edition/html/Instructions2.doc10.html\" target=\"_blank\">new指令</a>并不能完整创建出一个新的对象，直到对未初始化的对象调用了实例初始化方法才会完成实例的创建。这段代码也正好符合《<a href=\"http://dreamhead.blogbus.com/logs/456837.html\" target=\"_blank\">对象的生命</a>》中的解释，它只是负责做出申请内存。当然，在JVM中，它的实际工作要略多一些，如果这个对象的类没有加载，就会加载相应的类。<br>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200706231019",
    "date": "2007-06-23",
    "time": "10:19",
    "title": "CSDN的专访",
    "tags": [
      "我眼看世界"
    ],
    "body": "CSDN的专访（<a href=\"http://news.csdn.net/n/20070619/105467.html\" target=\"_blank\">上</a>）（<a href=\"http://news.csdn.net/n/20070620/105515.html\" target=\"_blank\">下</a>）<br><br>被CSDN的人抓住完成了一个采访，大有一种被揭老底的感觉。不过，还是很高兴能和别人分享一下自己对一些问题的理解。出于媒体的需要，我的回答在某些部分被修改，稍微有些不同于我的原意，比如这么煽情的标题就是从我的原文中截取出来的，而意思就是因为少了几个字而变得有些不同，不过，对比于<a href=\"http://news.csdn.net/n/20070621/105573.html\" target=\"_blank\">徐X那篇</a>（不过现在已经不是最开始那个极其吸引眼球的标题了），我还是觉得访问我的那个编辑还是不错的。下面是当时的问题和我的回答，有兴趣的朋友可以读一下。因为这里的修改权在我手里，我也把问题修改到让我可以接受的程度。:)<br><br>C：CSDN，D：dreamhead<br><br>C： 用精辟的语言做一个自我介绍<br>D： 我，一个热爱编程的程序员。<br><br>C：您的软件开发生涯分了哪几个部分？<br>D：我的程序员之路迄今为止经历了三个阶段：<br>* 大学毕业之前，初学阶段：大学之前，我对计算机的了解几乎是0。经过四年的学习，我找到了自己真正喜欢的事情：编程，因为用程序解决问题让我很有成就感。于是毕业的时候，我放弃了继续读书的想法，我知道我需要的是更多的实践。<br>* 大学毕业后的前三年，实践阶段：投身到实际的项目中，我对软件开发有了真实的体验。起步的时候，我遇到了几个良师益友，让我走上我认为的正确道路。我曾做过一个长达两年的项目，这让我对软件开发的生命周期有了一个相对完整的认识，个人能力也在这个过程中得到了极大的提升：从最开始的负责某个模块的编写，到后来负责整个系统的设计，直到最后基于此设计出一个框架，拿了公司Java大赛的冠军。经过这段时间的实践，我逐渐开始对软件开发有了一些自己的看法，也终于可以写出自己满意的代码。此外，我的blog之路也始于这段时间，并一直坚持下来，不断进行自我总结的同时，也结交了许多朋友。<br>* 随后两年时间，提高阶段：我在公司内部做了一次调转，工作内容的转换，让我有机会接触到更多的东西：从图像识别到并行计算，再到多核程序优化，我的技术视野不断开阔，同时，利用业余时间完善着自己的知识体系，将原本零散的知识串在了一起。实际上，我认为自己这段时间做得并不出色，不过，恰恰是这段时间，我开始反思一些东西，逐渐的掌握了一些做事的基本原则，懂得了“踏踏实实做事，也不忘抬头看路“的道理。也正是在这个阶段，我接触到了XRuby，找到了自己的乐趣所在。<br>我希望自己在加入ThoughtWorks之后，进入到第四个阶段，贡献阶段，用自己所学为别人带来更大的价值。软件开发不应该仅仅是自娱自乐，更应该是做一些真正对别人有价值的事情。<br><br>C：你的经历对你加入这个项目有怎样的影响？您成长的环境对这个项目又有怎样的影响呢？<br>D：我之前的经历对我参与XRuby这个项目并没有什么直接的影响，但正是多年的积累，让我有了足够的知识和能力参与到XRuby中：对编程的热爱，对新技术的关注、软件开发的功底和对计算机技术的理解等等。<br><br>C：平时除了写程序之外还有怎样的爱好？这些爱好对你在软件方面的造诣有何影响？<br>D：我的个人爱好是“读书、写字、编代码”。读书，让我学到知识，开阔视野；写字，也就是写一些东西，让我可以不停下思考的步伐；编代码，是我的工作，也是我的爱好，对我而言，分不清，也不需要分清。<br><br>C：现在一起合作的伙伴都是对软件开发有热情的程序员，觉得哪些宝贵的经验可以与大家分享？<br>D：我相信，每个人都希望自己能够同高水平的人一起工作，我也一样。能同一些高水平的人一起合作，我感到很兴奋，因为有机会和他们一起合作，才有机会近距离观察他们思考问题，处理问题的方式。代码可以轻松复制，但是代码背后隐藏的思想却不像代码本身那么显而易见。如果不是同这些高水平的人一起工作，很难发现背后隐藏的点点滴滴，而正是这些点点滴滴才让这些人与众不同。<br>我接触到的这些许多人眼中的高手，其实都是一些普通人，只是他们对自己所做的事情都很有激情，也能脚踏实地的把事情一点一点地做好。他们通常十分谦虚，不会过分强调个人的工作，这使得大家的交流变得容易了许多，也有益于让事情向着最恰当的方式发展。这些人做事通常都有一定的美感，我很喜欢编程是一种艺术的说法，好的程序员不会允许自己做的事情向着丑陋的方向发展，这是他们做事质量的一个重要保证，这种美感是在日常学习工作生活中不断的思考逐渐养成的。这些人通常思路会比较开放，他们会非常包容的看待一些问题，吸纳别人的优点，不会将一些非技术的界限看得非常清楚。我曾经看到过不少拿“国内“、”国人“来说事的项目，其实，这种提法本身就是对项目没有信心的表现，我自己作为技术人员很清楚，促使我们做出选择的更多是因为技术上的原因。开源项目是没有国界的，它的生命力是由它自身的优点和其参与者的热情决定的。<br><br>C：XRuby现在进行到什么阶段了？对于XRuby的发展规划和目标是怎样的？现在XRuby发展的最大问题是什么？<br>D：XRuby目前最新的发布版本是0.2.0，这个版本是我们的一个里程碑版本，已经可以运行Ruby的单元测试框架。有了单元测试框架作为基础，我们就可以大大提高开发效率，我们下一个里程碑版本0.3.0的目标就是通过所有Ruby自带的单元测试，而XRuby 1.0的目标是运行Ruby on Rails。XRuby所做的事情是整合Ruby和Java平台，这样，我们便可以将Ruby的开发效率和Java的丰富资源结合起来。从这个角度来说，我们和JRuby团队拥有着共同的目标，所以，许多人认为两个团队是互相竞争的。事实上，两个团队是在互相帮助。我们会给JRuby团队一些建议，甚至贡献一些代码让JRuby更好的运行，而JRuby团队也会的与我们进行讨论，把他们的一些经验分享给我们。当然，这点在我和Ola Bini之间体现得尤为明显，因为我们都是ThoughtWorker，经常在一起交流。XRuby现在遇到的最大的问题就是就是资源有限：团队规模有限，而且大多数人没有很多时间可以投入，所以，很难快速发展。<br><br>C：当时刚刚加入XRuby时是在一个什么样的背景下？当时这个项目最吸引你的是什么？<br>D：加入XRuby时，我刚好在业余时间完成了《Ruby Hacking Guide》几个章节的翻译，对Ruby的内部实现有了一些了解。看到XRuby这个项目时，我感到特别兴奋：自己熟悉的Java、自己喜欢的Ruby、自己想要了解编译器技术。所以，我毫不犹豫的加入了这个项目。<br><br>这些年的工作中，我见到过很多的开源项目，只有XRuby是一个让我真正动心，并投入大量时间去参与其中的项目。抛开个人喜好，我依然觉得XRuby是一个非常不错的项目。首先，当时看来，Ruby on Rails已经让Ruby赢得了更多的关注，只要有足够的关注，多半会有一个不错的发展，现在诸多公司的动作再次证实大家对Ruby的看好。再有，整合 Ruby和Java是一个非常棒的主意，因为程序设计语言的发展历程中，优秀的后来者都提供了比较好的方式利用原有者的优势，而不是直接推翻重来，比如 C/C++提供了整合汇编的方式，Java提供了JNI的方式去整合C/C++的资源，所以，Ruby已经有了整合C的方式，再有一个整合Java的方式就更完美了。当然，这两点并不足以让XRuby与JRuby区别开来，真正让XRuby具有优势的是它的编译方式。谈到编译和解释，人们通常会想到性能上的差异，也就是说采用编译的方式会让程序跑得更快。事实上，JRuby让很多诟病的主要原因就是性能。面对许多新技术，人们首先会质疑的就是性能，当年的 C/C++和Java都曾经历过这样的过程，但是事实证明，只要性能差异在一个可接受的范围之内，就可以消除人们对于性能的质疑。编译会成什么样子呢？这是我感兴趣的，也是XRuby主要的价值所在，事实证明，XRuby可以让Ruby代码在JVM平台上跑得像C Ruby一样快，甚至更快。当然，C Ruby还有很多可以提升的空间。比起当时的JRuby，这就是一个巨大的进步。所以，我相信，作为第一个做JVM上Ruby编译器的项目，XRuby这个项目对整个软件开发社区的发展是有好处的，这也是我愿意参与其中的重要原因。<br><br>很多人对于参与开源项目，尤其是像XRuby这样的编译器项目，第一个反应是我不行，因为我不会这个，不懂那个。实事求是的说，参与XRuby之初，我也只是对语言的实现有兴趣，对编译器的了解也仅限于大学所学过的那点编译原理的知识，没有什么实战的经验。但我还是加入到XRuby中，因为我相信我可以在这个过程中学会这个项目所需要的知识。直到现在，我也不敢说自己精通编译器。随着项目发展，我不断补充着自己的知识，对编译器实现的理解也是越来越深：从最开始的只是贡献一些builtin的代码，到后来重写了这个runtime的实现，再到后来修改编译器的实现。希望我走过的这条路可以那些希望进入 XRuby项目或是其他开源项目的人借鉴。<br><br>C：您觉得开发编译器最大的乐趣是什么？要开发一个编译器应该从什么地方开始？最需要注意的是哪些问题？<br>D：从大学时代开始，软件开发中有三个领域一直我所希望有机会从事的，分别是操作系统、编译器和游戏。想把任何一个做好，都需要对计算机有着深刻的理解，而我从小就特别愿意弄清楚事情的来龙去脉。作为一个程序员，像操作系统和编译器的这些知识虽然很少能够直接应用到工作中，但懂得了它们的基本原理，可以让人写起程序来如虎添翼。我对编译器尤其有好感，作为一个程序员，理解程序设计语言背后的东西，有助于我们写出更好的程序，避免因为无知造成的损失。<br><br>说到编译器，大家会想到词法分析、语法分析、代码生成等等这些令人望而却步的词汇。其实，做一个简单的编译器并不难，很多人熟知的龙书的第二章实现一个简单的计算器，涉及到了这本书介绍的几个大的方面。不过，从参与XRuby的经验来看，编译器只是整个开发中的一环，后面的Runtime和数量庞大的 builtin占了相当大的比重，它们是让语言更具生命力的部分。<br><br>同普通的软件一样，编译器的开发首先要弄清楚需求。很多人谈到编译器，就会想到设计一种新的程序设计语言，其实，这个世界最不需要的就是一种新的程序设计语言，当然，这并不能阻挡很多人去设计新的语言。我看到过一些号称很有热情的软件开发者，设计了一些声称全新的语言，实际上，却没有很强的针对性，所以，这些语言注定没有很强的生命力。从需求的角度来说，XRuby既不是第一个在做JVM上做编译器的动态语言，也不是第一个在JVM上做Ruby的，但它做了JVM上的Ruby编译器，这是之前没有人做过的，独一无二的，也是它的价值所在。<br><br>C：现在XRuby的开发团队是怎样的情况？团队是否还会继续扩大？准备达到一个什么样的规模？<br>D：XRuby团队现在有大约十几个人的规模，经常性提交代码的只有五六个人。开源项目不同于公司的项目，我们无法预测团队规模如何发展，加入到这个团队完全是依赖于个人对于开源的热情和对技术的热爱。我们希望有更多的人加入这个项目中来，在这个过程中，可以体会到乐趣，还会有许多收获。这个团队欢迎任何贡献，鼓励任何尝试。我们一向欢迎任何对XRuby有兴趣的人加入其中，和我们一起体会开发的乐趣。<br><br>C：Ruby语言最吸引您的地方在哪里？将来的发展趋势又如何呢？<br>D：Ruby语言最吸引我的地方是它的优美。对于很多用惯了像C/C++、Java这种静态语言的人来说，初涉Ruby会有一种震撼的感觉，它会让那些我们习以为常的繁琐操作变得异常简单，这也是开发效率大幅度提升的根本，这是许多动态语言的共同特征。随着计算机硬件的不断进步，机器的价值越来越低，人的价值则越来越高，所以，提高开发效率对于从事软件开发的人来或组织来说，显得更加重要。再有，我们知道，程序设计语言是架设在问题领域和解领域之间的桥梁，主流程序设计语言的进步就体现在越来越靠近问题领域，从汇编语言到C，再到C++，再到Java，无不如此。相比于很多静态语言，Ruby更接近问题领域，所以，我们可以更多把自己的精力放在要解决的问题上。UML也是一种向问题领域靠近的方式，不过，在我看来，相对于这种使用于模型的方式，Ruby之类动态语言更容易为程序员们所接受。还有很重要的一点，Ruby语言具有很强的元编程能力，这也是越来越多人关注的DSL（Domain Specific Language）的基础，通过适当的定制，可以让语言更加靠近问题领域，提升抽象层次。从实现角度来说，相对我所了解到其它动态语言来说，Ruby有一个设计良好的对象模型，只要理解了这个对象模型，就很容易对Ruby语言进行整体上的把握。<br><br>从最近一段时间一些公司的动作来看，大家都特别看好Ruby的未来。我相信，Ruby不仅仅可以用在日常脚本或是Web应用上，它会得到越来越广泛的应用，会在越来越多程序员的日常开发中扮演越来越重要的角色。事实上，ThoughtWorks正尝试着让Ruby运用于企业开发，并且取得了不错的效果。另外，公司的重头产品Mingle——一个敏捷项目管理工具——也是用Ruby开发的。我期待着，在Ruby社区和众多软件公司的共同努力下，Ruby会得到更好的发展。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200706182348",
    "date": "2007-06-18",
    "time": "23:48",
    "title": "Javac背后的故事——空类",
    "tags": [
      "Java"
    ],
    "body": "<p>程序员最熟悉的是源代码，但是要让程序真正的发挥功效，少不了编译器的帮助。javac的作用就是将Java代码编译为JVM指令。由于Java语言和JVM同出一门，所以，稍微熟悉一下，我们便不难发现，二者几乎是直接对应的。当然，为了简化代码的编写，javac除了直接翻译之外，还暗地里帮我们做了不少工作，我们从最简单的情况看起。<br><br>public class Test {<br>}<br><br>我们用javac编译这段代码，javap可以帮助我们反编译生成的类文件。<br>&nbsp;&nbsp;&nbsp; javap -c Test<br><br>下面就是反编译的结果。<br>public class Test extends java.lang.Object{<br>public Test();<br>&nbsp; Code:<br>&nbsp;&nbsp; 0:&nbsp;&nbsp; aload_0<br>&nbsp;&nbsp; 1:&nbsp;&nbsp; invokespecial&nbsp;&nbsp; #1; //Method java/lang/Object.\"&lt;init&gt;\":()V<br>&nbsp;&nbsp; 4:&nbsp;&nbsp; return<br>}<br><br>抛开指令具体的内容，上面反编译的结果清清楚楚的告诉我们，我们编写的这个空类一点都不空，因为其中还有一个构造函数。这就是javac替我们做的工作。没错，这是javac做的，但未必是JVM要求的。其实，JVM上运行的类，完全可以没有构造函数。不过，前面的例子已经明明白白的告诉我们，因为javac的作用，直接用Java语言是无法构造出真正的空类。那我们就不妨直接从字节码入手，借助ObjectWeb ASM构造真正的“空“类。<br><br>public class NoCtorGenerator {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String className = \"NoCtor\";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cw.visit(Opcodes.V1_2, Opcodes.ACC_PUBLIC, className, null, \"java/lang/Object\", null);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cw.visitEnd();<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; os = new FileOutputStream(className + \".class\");<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; os.write(cw.toByteArray());<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } finally {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (os != null) {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; os.close();<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>借助javap，我们可以看到生成的结果，确实没有构造函数。<br>public class NoCtor extends java.lang.Object{<br>}<br><br>不过，因为没有构造函数存在，我们并不能用这个类创建对象，但是，下面的代码证明了这个类生成的类确实可用。<br>public class NoCtorMain {<br>&nbsp;&nbsp;&nbsp; public static void main(String[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(NoCtor.class);<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>运行这段代码，我们可以得到下面的输出：<br>class NoCtor<br><br>关于Java虚拟机的指令，可以参考《<a href=\"http://www.china-pub.com/computers/common/info.asp?id=14719\" target=\"_blank\">深入Java虚拟机</a>》，而ObjectWeb ASM的入门，可以参考我的《<a href=\"http://dreamhead.blogbus.com/logs/4007513.html\" target=\"_blank\">Hello, ASM——代码生成</a>》。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200705221826",
    "date": "2007-05-22",
    "time": "18:26",
    "title": "ID和Symbol（二）",
    "tags": [
      "向下走"
    ],
    "body": "从抽象的角度来说，C和Java相比有很多不尽如人意的地方，它的数据和方法不能像Java那样封装在一起。但是，某些地方它的抽象可以做得比Java更好，比如typedef。如果我们要面对的是一个复杂类型，Java的优势尽显无疑，但是如果我们面对的是一个简单的类型呢？比如，只是一个long类型。我们这里要讨论的ID和Symbol就面临着这种问题。<br><br>之前，我们已经见过了Ruby中对应ID的定义：<br>typedef unsigned long ID;<br>(ruby.h)<br><br>因为typedef这种方法的存在，让我们拥有一个不同的名称，可以很好的完成抽象，又不必像普通的对象那样在生成对象上付出很多，一举两得。《<a href=\"http://dreamhead.blogbus.com/logs/2006/11/3925729.html\" target=\"_blank\">整数对象</a>》实际上就是讨论了这样一个问题。<br><br>如何对应到Java中呢？除非我们想放弃抽象，否则，我们多半是有一个类承担这样的工作。在XRuby的实现中，ID对应着RubyID。<br>package com.xruby.runtime.lang;<br><br>public class RubyID {<br>&nbsp;&nbsp;&nbsp; private long id;<br>&nbsp;&nbsp;&nbsp; ...<br>}<br>(RubyID.java)<br><br>说到这里问题来了！在前面的讨论中，我们知道ID是一个整数，Symbol实际上也是一个整数。那么我们是不是应该按照同样的方法设计一个RubySymbol呢？不妨顺着这个思路想下去，看看这种设计会带来什么。<br><br>我们已经知道了Ruby中ID和Symbol是一一对应的，那么在这里，我们也应该让ID和Symbol一一对应，这一点很容易做到，只要让它们的整数成员存在某种对应关系便可。另外，我们也知道，ID和Symbol的存在就是为了提高字符串比较的性能，所以，我们也希望在ID和Symbol的实现中，比较的性能也尽可能高。在Java中来得最快的比较莫过于直接比较引用了，所以，如果ID能够做到在系统内唯一，我们就可以用直接比较ID来代替比较其中成员，而且这种实现还可以省去每次都创建对象的成本，一举两得。显然，既然提出了这个问题，那么Symbol也应该有对应的实现。但是，如果这样做的话，怎样保证ID和Symbol之间的一一对应呢？换句话说，怎么实现ID和Symbol之间的转换呢？<br><br>有了字符串到ID的映射，很自然的会联想到用hash表实现这个功能。但问题也随之而来，我们用ID和Symbol本来是为了提升性能的，但它们之间的转换却加入了hash表的操作，于是Symbol转换为Ruby字符串的操作成本将大为提升，而且，我们还要在为增加的双向转换的两个Hash表负责。虽然这样可以实现，但这种方法会让人如鲠在喉。<br><br>当然，我们可以放弃ID和Symbol在系统内的唯一性来做到这一点，让每次转换生成一个新的ID或是Symbol，基于我们前面讨论的内容，这样做会动摇它们存在的根基。<br><br>其实，解决办法很简单，既然二者之间是个一一对应的关系，不妨就利用这种关系：<br>package com.xruby.runtime.lang;<br><br>public class RubyID {<br>&nbsp;&nbsp;&nbsp; private long id;<br>&nbsp;&nbsp;&nbsp; private RubySymbol symbol;<br>&nbsp;&nbsp;&nbsp; ...<br>}<br>(RubyID.java)<br><br>package com.xruby.runtime.lang;<br><br>public class RubySymbol extends RubyValue {<br>&nbsp;&nbsp;&nbsp; private RubyID id;<br>&nbsp;&nbsp;&nbsp; ...<br>｝<br>(RubySymbol.java)<br><br>这样，二者之间的转换也很容易完成：<br>public RubySymbol toSymbol() {<br>&nbsp;&nbsp;&nbsp; if (this.symbol == null) {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.symbol = new RubySymbol(this);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp; return this.symbol;<br>}<br>(RubyID.java)<br><br>public RubyID toID() {<br>&nbsp;&nbsp;&nbsp; return this.id;<br>}<br>(RubySymbol.java)<br><br>至于Symbol中的整数，很容易通过RubyID中的成员转换出来。<br><br>其实，做到这里，可以在进一步考虑一下，原来的long是否可以省略呢？毕竟RubyID拥有两个成员，不是一件令人愉快的事情。而且，在RubyID和RubySymbol的直接对应中，这个long成员并没有起到什么作用。而在RubyID与字符串的对应中，也没有用到那个long成员。在C Ruby的实现中，在它生成的过程中，加入了一些相关信息，比如全局变量、实例变量等等。为了保持兼容，暂时还是保留了这个成员。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200705212141",
    "date": "2007-05-21",
    "time": "21:41",
    "title": "ID和Symbol（一）",
    "tags": [
      "向下走"
    ],
    "body": "ID和Symbol是Ruby中同字符串相关的两个东西，他们的存在是为了一个共同的目的：替代字符串。因为字符串的比较通常代价不菲，以ID和Symbol代替字符串可以提高字符串比较的性能，所以，用到字符串比较的地方都可以选择用ID或是Symbol作为替代品，比如，做Hash表的键值。不同的是，ID用在C层次，而Symbol用在Ruby层次。<br><br>下面是ID的定义：<br>typedef unsigned long ID;<br>(ruby.h)<br><br>至于Symbol，我在《<a href=\"http://dreamhead.blogbus.com/logs/2006/09/3299713.html\" target=\"_blank\">管窥Ruby——对象基础</a>》说过，在Ruby实现中，VALUE是所有Ruby对象的根基，Symbol也不例外。不同于字符串等类型，我们可能并不会在Ruby实现的源码中看到Symbol类型的定义，它走了与整数类似的一条路，也就是说，它是内嵌在VALUE中的。下面是判断一个VALUE是否为SYMBOL的方法。<br><br>#define SYMBOL_FLAG 0x0e<br>#define SYMBOL_P(x) (((VALUE)(x)&amp;0xff)==SYMBOL_FLAG)<br>(ruby.h)<br><br>从上面的两段代码，我们不难发现，ID和Symbol实际上都是一个整数。它们都唯一对应着一个字符串，不同的是，ID对应着C的字符串，Symbol对应着Ruby的字符串。既然它们都对应着字符串，那么，它们之间便也顺理成章的存在着一些对应关系。事实上，它们之间的距离比我们想象的还要近，在Ruby的实现中，它们之间是可以直接转换的。<br><br>#define ID2SYM(x) ((VALUE)(((long)(x))&lt;&lt;8|SYMBOL_FLAG))<br>#define SYM2ID(x) RSHIFT((unsigned long)x,8)<br><br>这里，RSHIFT是一个平台相关的右移实现。从这里我们不难发现，ID和Symbol之间就是一一对应的。<br><br>那它们是如何对应到字符串的呢？ID和C字符串之间的对应是由下面两个函数完成的：<br>ID rb_intern(const char *name);<br>char* rb_id2name(ID id);<br>(parse.c)<br><br>其中，rb_inern完成C字符串到ID的映射，rb_id2name完成ID到C字符串的映射。其实现很简单，基本上就是一个在hash表中查找，如果没有，便创建一个。<br><br>那么Symbol和Ruby字符串是如何对应的呢？看一下Symbol的to_s方法就知道了。这个方法是这样定义出来的。<br>rb_define_method(rb_cSymbol, \"to_s\", sym_to_s, 0);<br>(object.c)<br><br>它实现于sym_to_s方法中。<br><br>static VALUE<br>sym_to_s(sym)<br>&nbsp;&nbsp;&nbsp; VALUE sym;<br>{<br>&nbsp;&nbsp;&nbsp; return rb_str_new2(rb_id2name(SYM2ID(sym)));<br>}<br>(object.c)<br><br>看到了吧！先由Symbol转成ID，再由ID对应到C字符串，最后由C字符串生成Ruby的字符串。绕了好大的一个圈子，所以，Symbol与其对应的Ruby字符串距离还真的是不近。所以，我前面会说，ID和Symbol之间的距离比想象得要近。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200705142241",
    "date": "2007-05-14",
    "time": "22:41",
    "title": "添加方法的小魔术",
    "tags": [
      "向下走"
    ],
    "body": "Ruby中有很多钩子，可以用来监控系统中的各种事件，比如，添加一个新的方法时，会调用类的method_added方法，下面是一段示例代码：<br>class A<br>&nbsp;&nbsp;&nbsp; def A.method_added symbol<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p symbol<br>&nbsp;&nbsp;&nbsp; end<br><br>&nbsp;&nbsp;&nbsp; def m<br>&nbsp;&nbsp;&nbsp; end<br>end<br><br>可以看到，因为这个方法定义了一个method_added的钩子，随后定义的方法时就会调用它，因此，虽然看上去没有什么具体的执行代码，这段代码依然就会产生输出。<br><br>在Ruby的实现中，定义方法是由rb_define_method实现的，这个方法最终会调用rb_add_method，而添加方法的钩子就是在这个方法中实现的。<br>void<br>rb_add_method(klass, mid, node, noex)<br>&nbsp;&nbsp;&nbsp; VALUE klass;<br>&nbsp;&nbsp;&nbsp; ID mid;<br>&nbsp;&nbsp;&nbsp; NODE *node;<br>&nbsp;&nbsp;&nbsp; int noex;<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; rb_funcall(klass, added, 1, ID2SYM(mid));<br>&nbsp;&nbsp;&nbsp; ...<br>}<br>(eval.c)<br><br>这里的added实际上就是“method_added“这个字符串对应的ID，在之前的blog中提到过，Ruby的实现ID和字符串是一一对应的。所以，这段代码就相当于调用类的method_added方法。Module类实现了一个缺省的method_added方法（什么都不做），Class类继承自Module类，所以，它也拥有了method_added方法。<br><br>不过，仔细查看Ruby的源码，我们会发现，method_added并不是我们定义的第一个方法，这样就带来一个问题，那就是在没有这个方法定义未完成之前，那个调用会不会出错。事实上，即便它是我们定义的第一个方法，也会有同样的问题，因为在定义method_added方法时，method_added方法并没有完成定义，有些绕，但情况就是这样。事实会告诉我们，Ruby活得不错，没有在初始化的时候就告诉我们method_added方法未定义。<br><br>代码是说明问题的最好办法，其实，我们之前拿出来的代码漏掉了一些东西，那段代码前后的部分大概是这样：<br>&nbsp;&nbsp;&nbsp; if (node &amp;&amp; mid != ID_ALLOCATOR &amp;&amp; ruby_running) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FL_TEST(klass, FL_SINGLETON)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rb_funcall(rb_iv_get(klass, \"__attached__\"), singleton_added, 1, ID2SYM(mid));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rb_funcall(klass, added, 1, ID2SYM(mid));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>(eval.c)<br><br>问题就在ruby_running，这是一个Ruby是否正在运行的标识。它的初值是0，<br>static int ruby_running = 0;<br>(eval.c)<br><br>把它赋值为1的地方是在ruby_init中，<br>void<br>ruby_init()<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; ruby_running = 1&nbsp;&nbsp; &nbsp;<br>}<br>(eval.c)<br><br>看到了吧！只有当初始化完成之后，它才会设置ruby_running，而一些builtin方法的定义是在初始化过程中完成的，所以，它们是可以正常完成定义的，当然，这也依赖于method_added缺省实现的无所作为。<br><br>其实，稍微查看一下，我们不难发现除了用于方法添加过程之外，ruby_running这个变量还在方法缓存中起作用，比如包含一个模块的时候，会清空cache，<br>void<br>rb_include_module(klass, module)<br>&nbsp;&nbsp;&nbsp; VALUE klass, module;<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; if (changed) rb_clear_cache();<br>}<br>(class.c)<br><br>而我们知道，方法缓存只有在有方法调用之后，才会有内容，在初始化的过程中，这个操作显然有些浪费，所以，在清理缓存之前，稍微检查一下，就可以省去每次都做的苦恼，对于提高初始化的性能，很有帮助。<br>void<br>rb_clear_cache()<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; if (!ruby_running) return;<br>&nbsp;&nbsp;&nbsp; ...<br>}<br>(eval.c)<br><br>其实，ruby_running只是一个简单标识，这是编程中很常用的一种方法，表示一件事情的完成，没有什么难度。只是理解添加方法这个问题时，可能会一不小心走到误区里面，正如我前面提到的那个有些绕的说法。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200705082122",
    "date": "2007-05-08",
    "time": "21:22",
    "title": "踏上新征程",
    "tags": [
      "脚下的路"
    ],
    "body": "当我登上去往西安的飞机时，20多天的“长假”结束了。这是我工作以来休息最长的一次，之所以用了引号，因为这段时间，我是一个无工作的人，谈不上放假。<br><br>这个“假”休得比上班还累。因为办理离职的原因，我的大多数时间是在跑来跑去的，而且难得回到公司，朋友很多，忙活了一白天，晚上还要和朋友们一起聚聚。好些次都累到躺在床上一点都不想动。和人事的人聊天时，大家一致认定办理入职手续的时候，从来没有如此麻烦过，由此推断，公司是不鼓励离职的。:)<br><br>曾经在西安读书，这次到西安，被许多朋友戏称为回到老巢。迈出机舱的那一刻，呼吸着西安水气十足的空气，可怜一早从沈阳出发的我穿了一件外套，汗一下子就冒了出来，突然有一种桑拿的感觉，这是典型的夏天西安的天气。西安，我又回来了！<br><br>我不喜欢西安夏天的热，当年因为数学建模培训的原因，曾经在西安体会过夏天最热的时候，真的是让我饱受折磨，常有同学睡到半夜热得起来冲凉。我非常喜欢西安的小吃，好吃又便宜，而且种类繁多，念书的时候，学校周围的小吃几乎吃了个遍，那时候还不觉得，毕业离开西安之后，我才觉得，还是西安的小吃好，这也是我这次回到西安的一件主要的编外任务。<br><br>不同于上次到西安面试的匆匆忙忙，这次要在西安待上一段时间。同样不同于上次到西安面试，这次 ThoughtWorks搬了一个新的大厅，至少比之前的的大厅多放上一张大桌子，显然人更多了。至于其它空间——比如会议室——的增加，我倒并不是太在意，只是注意到厨房已经单独独立了出来，游戏机也在里面，适合边吃边打。<br><br>我到的时候，正好的是下午刚开始上班的工作，趁着大家还没进入到工作状态之中，和大家打了招呼。说实话，人太多，有些记不住，好在墙上贴满了大家的照片，闲暇时可以看看，尽快熟悉同事。有一件很有趣的事，一个同事的名字和我的名字的读音刚好反过来，在英文的交流环境下，有人把名放在前面，有人把姓放在前面，我们俩的名字足以给大家带来相当的麻烦，据说，我还没入职，已经有人开始混淆了。<br><br>下午领了机器，一台Dell的双核笔记本，稍微值得吹毛求疵的地方是，宽屏，按我的说法，适合看电影，对于开发的好处，我还没有体会到。给自己装了个双系统，终于可以用Ubuntu了，之前就是因为宽带的原因，我一直没法使用Ubuntu，现在有机会了，争取让 Ubuntu成为自己的日常开发环境，显然周围的Ubuntu Fans不少。我一直没搞清楚，在大厅里随便坐，那网络的问题如何解决，到自己装机的时候才知道，原来用的都是无线网络。今天我蹲着装机器曾引起了别人的同情，有了这样的网络环境，哪天可以尝试一下趴在地上，呵呵，这可是我在自己的住处经常使用的一种开发造型啊！<br><br>新环境，新征程，起步了！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200704252328",
    "date": "2007-04-25",
    "time": "23:28",
    "title": "加入ThoughtWorks",
    "tags": [
      "脚下的路"
    ],
    "body": "又是一个<a href=\"http://dreamhead.blogbus.com/logs/1103236.html\" target=\"_blank\" title=\"别在花开时\">春暖花开的季节</a>，我离开了东软，即将成为一名ThoughtWorker。<br><br>我在东软工作了五年，不算短的时间。其实，我也想过一直留在在东软，因为这里有我成长的足迹，有许多美好的回忆，但几年的工作经验告诉我，这里无法给我我所需要的东西。我早就知道自己会离开，甚至是在进入东软之前，因为这里是“人才的摇篮”。之所以在东软一待就是五年，因为我一直不知道自己要到怎样的地方去做什么。我只知道，我需要一个能够让自己快乐的地方，去做一件让自己兴奋的事情。<br><br>如今，之所以选择离开，因为我认为我终于有机会得到了我想要的：一个能够让自己快乐的地方——<a href=\"www.thoughtworks.com\" target=\"_blank\" title=\"ThoughtWorks\">ThoughtWorks</a>，一件让自己兴奋的事情——Ruby。<br><br>很早就知道ThoughtWorks，因为《重构》的作者<a href=\"http://www.martinfowler.com/\" target=\"_blank\" title=\"Martin Fowler\">Martin Fowler</a>是它的首席科学家，因为我有很多朋友在里面。但对ThoughtWorks真正的了解却很少。这次找工作让我有机会相对深入的了解了ThoughtWorks，尤其是面试过程中有一项是到西安的office去面试。<br><br>ThoughtWorks的工作环境很特别，给我留下最深印象的就是，除了少数几个做行政的人外，其他人一律围坐在圆桌旁，没有那种常见的格子，所谓的领导也不例外，不像其它的公司，领导要有专门的房间。塞满食品的冰箱并不让我觉得特别，办公司的游戏机也是有所耳闻的，我倒是对一副太极拳的挂图产生了浓厚的兴趣，到处打听谁是练家子。<br><br>前前后后接触了好些ThoughtWorker，他们给我留下了非常好的印象。ThoughtWorker们谈到自己的公司，都会有一种油然而生的自豪感，在这个愤青横行的年代是多么不容易啊！ThoughtWorker们都非常能说，或许这和公司的咨询背景不无关系，随便拉来一个都可以说上半天。ThoughtWorker们给人的感觉亲切，这让我整个的应聘过程中都感觉非常放松。<br><br>随着参与对XRuby参与的深入，我越来越喜欢Ruby。虽然在国内，大多数人对Ruby只是持观望的态度，但国外Ruby已经越来越红火，ThoughtWorks本身已经有不少的项目在用Ruby做。ThoughtWorks很看好Ruby的未来，希望它在软件开发的世界中，扮演更加重要的角色，除了目前的Web应用之外，也可以进军到<a href=\"http://www.ruby-forum.com/topic/102776\" target=\"_blank\" title=\"On Enterprise Ruby\">企业级开发</a>之中。在这种背景下，<a href=\"http://ola-bini.blogspot.com/2007/03/thoughtworks.html\" target=\"_blank\" title=\"ThoughtWorks\">JRuby的开发者Ola Bini也加入了ThoughtWorks</a>。当然，ThoughtWorks内部有不少人也很看好XRuby，这也就是说，进入ThoughtWorks之后，我也有机会继续在XRuby上的工作。能在Ruby的尚处于上升期加入到这个过程中，而且有机会与一些世界级的程序员合作，想起来就是一件让人兴奋的事情。<br><br>我期待着在ThoughtWorks开始我的新工作！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200704112154",
    "date": "2007-04-11",
    "time": "21:54",
    "title": "有趣的属性赋值",
    "tags": [
      "向下走"
    ],
    "body": "<p>beanworms问了一个有趣的问题，下面这段Ruby代码的输出是什么？为什么？<br><br>class A<br>&nbsp;&nbsp;&nbsp; def m=(value)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @m = value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3<br>&nbsp;&nbsp;&nbsp; end<br>end<br><br>a = A.new<br>puts a.m = 5<br><br>按照常规的理解，“a.m = 5”会转换为一个函数调用，最终调用到“m=”。我们都知道在Ruby中，方法中如果没有显式的“return”，那么最后一个表达式的值将作为这个方法的值返回。根据这个推理过程，那么这段代码的输出应该是“3”，因为“m=”这个方法的最后一个表达式是3。<br><br>很遗憾，不是。那真正的结果是什么呢？运行一下就知道了，是5。<br><br>怎么会这样？没什么大不了的，理想和现实之间总是存在些许的差别。有怨天尤人的工夫，我们不如把问题的原因找出来。<br><br>我们说过，“a.m = 5”会被转换为函数调用，而这个转换工作是由Ruby替我们来做的。通常Ruby程序的执行过程是，将程序解析成一个内部的语法树，然后执行这棵语法树。所谓执行这棵语法树，就是根据节点的不同类型，采用不同的方法进行处理，差异便在这里。通常的方法调用会被解析成一个类型为NODE_CALL的节点，其处理过程简化后如下：<br><br>case NODE_CALL:<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; result = rb_call(CLASS_OF(recv),recv,node-&gt;nd_mid,argc,argv,0,self);<br>}<br>break;<br>(eval.c)<br><br>我们可以看到这里的最终的返回结果就是方法调用的返回值。但是对于属性赋值，则会解析为一个类型NODE_ATTRASGN的节点，它的处理过程和NODE_CALL类型略有差别，其简化后如下：<br><br>case NODE_ATTRASGN:<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; rb_call(CLASS_OF(recv),recv,node-&gt;nd_mid,argc,argv,scope,self);<br>&nbsp;&nbsp;&nbsp; result = argv[argc-1];<br>}<br>break;<br>(eval.c)<br><br>从这段代码中，我们发现在这个过程中，确实是调用了函数，但是函数的返回值被丢弃了，而这个表达式的结果直接取自参数。想来也对，通常我们赋值表达式的值都是等号右边的部分。<br><br>看过了代码，我们就很容易解释前面那段的代码了。这里的关键就是“a.m = 5”会解析为一个属性赋值的表达式，而非通常的方法调用，这个表达式的值就是右边的参数，而不是方法的返回值。“m=”作为一个方法，它的返回值确实是3，下面这句代码就可以验证这一点：<br>a.send(:m=,&nbsp; 5) =&gt; 3</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200704102120",
    "date": "2007-04-10",
    "time": "21:20",
    "title": "合并Runtime",
    "tags": [
      "脚下的路"
    ],
    "body": "终于将New Runtime的代码合并到XRuby的trunk中了。<br><br>从开始写New Runtime到现在快有半年了，时至今日，才把它的主体结构合并到trunk中。主要原因是New Runtime和原有的Runtime差异太大。虽然二者起到的作用是类似，但结构和接口上的巨大差异使得合并成了一件很困难的事情。<br><br>如果我没有记错的话，这是第三次进行合并的尝试。yawl在我写好了New Runtime之后，就进行了第一次尝试，试图将编译器移植到New Runtime上，结果很长时间代码都不能运行。虽然这次尝试没能成功，但是从New Runtime得到的继承结构应用到了trunk中。第二次尝试是在0.1.0发布之前，我亲自操刀合并。思路同上次类似，我直接把New Runtime的主要结构合并进来，之后，修改编译器。当时的代码已经可以运行很大一部分的代码，但依然是问题多多，最终没能赶在0.1.0发布之前完成。不过，这次的尝试倒是让我对代码生成部分有了一个比较清晰的认识。<br><br>在0.1.3发布之后，我开始了第三次尝试。谈到New Runtime，yawl给了我个建议，一点一点来，不要试图一下子就把所有内容加进来。从善如流，我没有沿袭前两次那种大刀阔斧的修改方式，而是采用了小规模重构的方法。首先是对执行性能影响较大的Method Cache。说起来很简单，就是加一个简单的缓存，但因为已经存在了大量的测试用例，所以，让所有测试都通过是一个考验。这次修改基本上只改动Runtime的内部实现，几乎不动编译器端，所以，相对来说，影响还比较小。当所有测试用例通过的时候，我长出了一口气，至少成功的迈出了第一步。这次修改同时还加入了ID替换String的实现，所有测试用例通过之后，为了能够更充分的利用ID带来的优势，我又修改了编译器，让它直接生成利用ID的代码，相对来说，这步要简单得多。<br><br>接下来的是更为复杂的类结构，同样，我依然采用的是小规模重构的方式。在开始之前，我划分了一下需要做的几件事，大体说来，分为三个部分singleton类的支持（用于支持为对象定义方法和meta类）、include类的支持（用于支持包含模块），整体结构的支持。<br><br>按照顺序，我开始加入singleton类的支持时，我发现如果想让singleton类很好的运作，必须有对整体结构的支持，这两个工作关联性很大。为了不让自己陷入长时间的一无所获，我放弃了正在进行的singleton类的支持，转向include类的支持。果然，include类的支持相对来说，影响要小一些，编译器部分几乎没有任何修改，所以，很快通过了测试，这样，New Runtime已经有一部分进入到trunk之中。<br><br>再回到singleton类支持时，有一少部分代码因为include类的原因，已经进入到trunk之中。其实，单纯支持singleton其实很容易，而且也几乎不要修改编译器，但正如前面提到的，如果让singleton类能够运行起来，必须要有整体的结构与之配合，所以，在有测试未通过的情况下，我就把整个的类结构全部合并进来了。之所以会很复杂，因为除了类结构本身，还要有编译器部分与之配合。这样，在应对Runtime修改的同时，还要考虑编译器生成代码的正确性。好在二者的表现通常是截然不同，在执行时出现的各种各样错误一定属于Runtime，而编译器的错误是代码根本不能正确执行，加载时就会出校验错，所以，一般很容易知道是哪里出了问题。无论如何，长时间的测试不能通过是一件很痛苦的事情，稍感欣慰的是，总有一点点的进步。<br><br>惊喜总是不期而至，当我还在等待下一个错误的时候，突然所有测试用例通过了，那是一种很奇妙的感觉。虽然现在的Runtime还有不少要调整的地方，但是主要的结构已经进来了。回顾前两次的合并，之所以没能成功，主要是因为目标太大，一次要完成所有任务，很难很好的把握其复杂度。失败中也有收获，如果没有前两次的尝试打下的基础，这次的合并可能会更加复杂。<br><br>合并New Runtime可是我在0.2.0要实现的一个重要目标，实现之后，便可以继续前进了。现在New Runtime不复存在，只有XRuby Runtime。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200704042045",
    "date": "2007-04-04",
    "time": "20:45",
    "title": "一个多核程序的优化方法小结",
    "tags": [
      "向下走"
    ],
    "body": "<p>最近一个月时间，周围的所有人在做的是一件事，优化。让一个物理模拟的程序尽可能快的运行在多核平台上。一个月前，知道要做什么，但心里完全没有底，一个月后，坐在计算机前看着程序运行的录像时，心里还是挺有成就感的。当然，优化是一条无止境的路，即便程序做到目前的状态依然有很大的提升空间，这里只是简单总结一下之前用到的一些方法。<br><br><font size=\"4\"><strong>硬件</strong></font><br><strong>CPU</strong><br>说过这是一个多核平台的优化，所以，多核CPU是肯定的了。身边这台机器是两个4核CPU，也就相当于有8个核。但是，多核CPU显然不会像单核CPU提升频率那样可以坐享其成。不做修改的结果只能是看着一个核累死，其它的核闲得无聊。所以，有了多核CPU，还要有软件配合。<br><br><strong>显卡</strong><br>另外一个提升的是显卡，因为程序本身有显示的部分，而且是一个3D的图像。后来证明，计算的部分很快，显示的部分成了瓶颈，原来的显卡程序只能运行在简单的模式下，为了能够在更复杂的模式下让程序流畅的运行，换了一块五大三粗的显卡。回忆了一下，为了这个程序而在换的显卡就有四块之多。</p><p><font size=\"4\"><strong>程序</strong></font><br>程序的部分才是我们真正着力去做的事情。<strong><br><br>分离计算和显示</strong><br>这是在通常的桌面程序最容易想到的方案，即便不是为了优化。分离二者之后，就不会出现因为计算而造成的界面失去响应的情况。这里用到的技术，主要是双缓冲，计算线程将算的结果放置到写缓冲中，然后翻转。用这种方式将二者分开，避免原来因为同步造成的其中一个的缓慢影响到另外一个。<br><br><strong>计算部分</strong><br>程序的核心是计算部分，它真正决定程序的效果。<br><br>多线程<br>如果软件不修改，只有多核的CPU本质上不会带来什么提升。现阶段，利用多核最好的方式就是多线程。原本打算自己来写线程管理的部分，考虑到复杂度，最终用的是OpenMP，只要几条编译指令，程序便拥有了多线程的本事。<br><br>数据结构<br>很多数据结构在单核的情况下，表现良好，而在多核的情况下就稍显不足了，比如链表。如果需要对链表所有元素进行处理，在单核情况下，遍历就好了，而在多核的情况下，简单的遍历是不能充分发挥多核的优势，而且往往需要用锁保证并发访问的正确性。如果用数组的话，只要能够进行正确的划分，比如，每个线程处理一段，那多核的优势便会发挥出来。所以，有些时候，为了发挥多核的威力，需要适当的调整一下数据结构。<br><br><strong>显示部分</strong><br>本质上来说，显示部分的调整并不能让程序算得更快，但它却可以给人们觉得“程序算得更快”。<br><br>局部视图<br>当程序只显示一个局部的时候，把所有视图都画出来其实没有什么意义，而且还要浪费大量的计算资源，所以，只绘制可以显示的一小部分即可。<br><br>远端视图<br>程序中的物体是一个3D模型，但是，我们都知道近大远小的道理，当它看上去离我们很远的时候，根本看不出来到底是个什么东西。所以，在这种情况下，我们可以用简单的模型替代复杂模型，提高处理性能。<br><br><font size=\"4\"><strong>软件</strong></font><br><strong>编译器</strong><br>为了压榨程序的性能，一个好的编译器自然是不可或缺的。所以，我们选择了号称能生成Intel平台最好性能代码的ICC。除了编译器本身的优异，它对OpenMP的支持也让我们可以放心这个方案，另外，它还提供对SSE系列的支持，可以省去思考汇编的烦恼。</p><p><strong>Profiler</strong><br>当大的方面已经就绪，剩下的细节就是Profiler展现本事的地方了。VTune是个不错的选择，可以让把程序运行的状况清晰的展现出来。通过对VTune捕获事件的定制，我们可以要求它给出我们希望了解的内容，比如缓存命中的状态，不看不知道，原来因为Cache Missing造成的损失还是不少的。于是，它为我们进一步调整提供了一个方向。 </p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200704032023",
    "date": "2007-04-03",
    "time": "20:23",
    "title": "读《Programming Ruby》",
    "tags": [
      "我眼看世界"
    ],
    "body": "我喜欢Ruby，因为它在我心中是一种优美的程序设计语言；我喜欢读纸版书，因为捧在手里很有感觉；我喜欢读中文版，毕竟中文是我的母语。所以，当《<a href=\"http://www.china-pub.com/computers/common/info.asp?id=30059\" target=\"_blank\" title=\"Programming Ruby中文版\">Programming Ruby中文版</a>》面市的时候，我迫不及待的在网上下了订单。<br><br>这本书给我的第一印象是“厚”，有如字典一般的外观对于捧在手中的阅读不会是一种非常好的阅读体验，不过，几百页的图书想薄也难啊！不过，整体来说，这本书的制作质量还是相当不错的，让人感觉很舒服，事实上，这本书读起来感觉确实不错，也不枉为它等待如此之长的时间了。<br><br>因为已经对Ruby有了一定了解，所以，我读这本书更多的是对知识上的查缺补漏，这样的读书，速度自然也快了许多。所以，很快就把正文中我感兴趣的部分读了一遍。至于后面库的部分，用到的时候再说吧！<br><br>这本书几乎算得上Ruby的“圣经”了，无论是厚度还是内容。它几乎涵盖Ruby语言的各个方面。作者在写书方面是老手，所以，很会照顾不同层面的需要：想了解Ruby，第一部分提供的就是一个简单的教程；想深入语言的细节，第三部分把Ruby语言的方方面面展示了出来……<br><br>让我最有感觉的是第24章《类和对象》，之所以这么说，是因为其中把Ruby的对象模型明明白白的摆在了那里，刚好是近来一直在用功的方面，当然看得酣畅淋漓。相对于语法是形，背后的思想就是神了，而把Ruby的神很好的展现出来的是第23章《Duck Typing》，如果对象能够像鸭子一样走，像鸭子一样叫，那么就可以把它当作鸭子。更准确的说，这章是从静态语言迈入动态语言所需的真正转换。<br><br>如果非要要为这本书找些毛病，我能想到的就是它对Metaprogramming涉及很少，毕竟DSL（Domain Specific Language）已经越来越受到人们的关注，而Ruby在Metaprogramming上的能力恰好可以在DSL上大有作为，ROR已经为我们很好的展示了这一点。<br><br>对于有些人来说，Ruby就是ROR，但实际上，Ruby要比ROR更为广阔。所以，单纯从学习ROR的角度来读这本书，无疑是有些过了。据说有本《Ruby For Rails》很适合为了ROR而学Ruby的人，没读过，仅把把它作为信息列在这。像我们这样通过书来学习新知的人，很重要的就是找对书，因为上错了船而大骂船的人，真正该骂的是自己。<br><br>对于中文版的图书，翻译是一个无可避免的话题。这本书的翻译质量很高，很少出现因为拗口的字句打断阅读的现象。不过，还是有些细微之处存在瑕疵。比如，在346页上，谈及方法定义时，有这样一句话：<br>&nbsp;&nbsp;&nbsp; 方法定义可能不包含类或模块定义。<br>其原文是<br>&nbsp;&nbsp;&nbsp; Method definitions may not contain class or module definitions.<br>我对这句话的理解是<br>&nbsp;&nbsp;&nbsp; 方法定义不可以包含类或模块定义。<br>如果按照原译文来理解，显然既然方法定义“可能不”包含类或模块的定义，那当然也“可能”包含了。实际上，只要稍微试一下，Ruby就会告诉你这是不可以的。显然，译者对某些技术细节的把握还稍有欠缺。<br><br>喜欢吹毛求疵的我，在看书的同时，给书挑了<a href=\"http://www.china-pub.com/member/bookpinglun/viewpinglun.asp?id=30059\" target=\"_blank\">一些细小的毛病</a>。可喜的是，无论是译者还是编辑都能够对此积极的响应，这样的鼓励使得我有了“变本加厉”的动力。<br><br>《Programming Ruby》是一本不错的好书，但是我们不可能指望任何一本书告诉我们世上的所有事情，《Programming Ruby》也不能，它只是一条通往Ruby世界的桥梁，接下来更多的还是要依靠自己的努力。如果读了这本书发现Ruby还有些吸引自己的地方，那就进入Ruby的世界享受编程的乐趣吧！\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200703312110",
    "date": "2007-03-31",
    "time": "21:10",
    "title": "扰人的选择",
    "tags": [
      "我眼看世界"
    ],
    "body": "人这一辈子总会有许多选择，小到穿什么衣服、吃什么饭，大到未来的人生路。选择是一个令人头疼的问题，但凡有选择的机会，就意味着有一大堆要对比的东西，而且即便是同样的东西，不同时刻摆在面前，因为中间经历了许多的变化，其选择也会有所差异，比如不想吃昨天刚刚吃过的东西。<br><br>有时候，选择之前会有个预期，这个预期也许是基于之前种种考虑做出的最为顺应心灵的选择，但这个预期的根基往往只是“考虑”出来的，而非真实摆在面前的种种。一旦迈出一步，真实摆在了面前，突然会发现，这个世界总有很多超出预计的东西，前面用心良苦做出的选择，瞬间便面临着土崩瓦解。虽然漫无目的的行事绝非值得推荐的实践，但过度的思考也绝对是在浪费时间。<br><br>也许是饱汉子不知饿汉子饥，我突然觉得没有选择或是只有一条路是最好的选择。选择的滋味并不好受，尤其是面对着多个不忍放弃的目标，而事实让人只能选择其中一条路时。有时，真的希望自己有分身之术，这样，不必劳心费力的去做选择，每条路上一个分身就好。遗憾的是，这项技能不属于我等正常人类。<br><br>一个与选择有关的词最近经常有人在我耳边提起：平衡。有些选择，单从某个方面上看起来，是简直无懈可击，美好得让人容易迷失，让人容易义无反顾，但且慢，它真的是最合适的选择吗？有所得必然有所失，再美好的选择也一样，这个方面的得是不是意味着另一方面的失呢？一俊确实容易遮白丑。最合适的选择，应该是那些在各个方面达到了一个相对平衡的选择。<br><br>人在处于选择的十字路口时，总会有许多的声音从四面八方涌来。这些声音往往只能让大脑更加混乱，尤其是那些上升到仁义道德的声音，时常会让人觉得某个选择会愧对包括自己在内的所有人。这些声音有自己正确的部分，但事实未必那么可怕，真正让自己做出选择的应该是自己的心，至于那些声音，很好的参考。<br><br>选择了，就要走下去。这个世界没有一种叫做“后悔药”的东西，这也是某些选择更为痛苦的原因。后悔是没有用的，所以，既然选择了，唯有坚持的走下去，即便没有得到预期的东西，也会有一些额外的收获。<br><br>如果读这篇不着边际的blog有云里雾里的感觉，没有关系，只是说明没有类似的经历，不代表别的。仅以这篇blog献给和我一样与选择作战的人们。\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200604232034",
    "date": "2006-04-23",
    "time": "20:34",
    "title": "《Unix程序设计艺术》之身边的例子——可移植性",
    "tags": [

    ],
    "body": "《Unix程序设计艺术》的第十七章讨论的是可移植性，也就是我们常说的跨平台。这里的平台，包括硬件平台和软件平台。\n或许是初学编程时受一些书的影响，在相当长的一段时间内，可移植性在我心目中是一个相当神圣的词汇，甚至理所当然的认为一个好的程序就应该跨平台，所以，偶尔写程序用到一些判断平台特征的#ifdef，自己都会觉得很了不起。\n事实远没有理想那样美好。可移植性固然是一个很好的特征，但它并不像看上去那样美。\n首当其冲的问题便是，我们的程序有必要做到可移植性吗？我有一个朋友，他们项目的开发语言是VB，而且是诞生于上个世纪末的VB6。在这个Java和.NET抢占眼球的年代，一个新项目采用VB作为开发语言本身看上去就是一个大胆的决定。对此，这个朋友的解释是，一来他对于VB的熟悉程度，二来VB在快速开发上表现确实不错。朋友的公司是一个新公司，他们需要尽快的把产品做出来，因此，VB成了一个当仁不让的选择。因为他们的产品是一个面向普通用户的产品，于是，我想到了可移植性的问题，毕竟，Linux桌面的影响力是越来越大。朋友的答案是，先把Windows平台做好，公司的现状是把眼前的事做好，而不是把面铺开，再者，即便真的需要移植到Linux，作为一种选择，他可能会考虑Samba，至于后续的发展，那是以后需要考虑的事情。从他的身上，我感受到了一种强烈的实用主义气息。\n即便可移植性真的成了一种必须，跨平台也不像最初想像的那样简单。曾经写过一篇《小心翼翼跨平台》，讨论了我在使用Java时遇到的一个可移植性的问题。Java在跨平台上的表现已经不错了，但还会存在许多问题，遑论其它各家呢！\n部门原来分为两个组：算法和平台。其中平台组原本要做的工作之一就是保证我们算法的可移植性。按照原先单纯的想法，在平台组同志们辛苦的努力之下，算法组的同志们就可以在可爱的PC机上进行开发，到了具体的硬件平台，就是编译器的工作了。为此，同志们经过艰苦卓绝的努力，用C语言开发了OS Wrapper，屏蔽操作系统的差异。这一切发生在去年。今年年初，当我们拿到一块实验板子时，所有美丽的梦就此破灭了。虽然这块板子用到的也是C语言，但为了让程序可以获得更高的性能，它对C语言进行了扩展。如果不使用这些扩展，我们也就完全失去了使用这个板子的意义，而使用这些扩展意味着原先大量的代码需要重写，梦想中的可移植性也就荡然无存了。再有，这个板子有着特殊的运行程序的方式，根本没有操作系统，换句话说，我们辛辛苦苦编写的OS Wrapper至少在这个板子上完全没有用武之地。\n可移植性，是一个值得我们努力的美好目标。如果真的达不到，也没有必要一棵树上吊死。"
  },
  {
    "timestamp": "200604202146",
    "date": "2006-04-20",
    "time": "21:46",
    "title": "技术的价值",
    "tags": [

    ],
    "body": "CSDN：在中国搞技术只能混碗饭吃,没有太大希望\nJavaEye：来自csdn的一则新闻\n又是一个吵架的好话题，刚好最近一段时间脑子里也有同样的一个话题。\n有谁和钱过不去呢？于是，因为有一技之长，所以，很多和我们一样做技术的人都认为老板对不起自己，在我们度过许多“职业时间开发，业余时间学习”的日子之后，得到的只是仅仅能够维持生计的一点点薪水，毕竟薪水是一个人努力成果的最佳体现。可奇怪的是，与此同时，老板们也在抱怨，说我们干活如此不努力，却有着高人一等的要求。究竟问题出现在谁的身上呢？\n其实，谁都没有错。只是我们思考问题的时候，只选择了自己的角度。这个问题困扰过我很长时间：我总是认为自己的能力很强，领导为什么不能够让我的薪水再上一个台阶，而一些拿着让人羡慕薪水的人却不见得个人能力有多强，如果做同样的事情，我保证可以比他们做得更好。\n我们不妨问自己另外一个问题：我们挣的钱从何而来？表面上看来是老板们为我发饷，那就不妨在问一下，老板的钱从何而来？正常的情况下，这笔钱源自我们的客户。因为我们开发的软件恰如其分的满足了他们的要求，于是，他们掏出一笔银子，为我们的劳动买单。我们会把钱无偿奉献给一个陌生人吗？除了做慈善事业，这种情况发生的概率极低。问题就在这里了，客户愿意掏钱，原因就在于我们开发的软件能给他们带来一定的价值。同样的道理，老板给我们钱，其原因在于我们为公司创造了价值。\n对，创造价值，而不是我们的个人能力！\n对于完成工作来说，个人能力是一个很重要的砝码，它可以让我们“更快、更高、更强”的完成工作，但它并不能保证我们创造价值。有能力，不等于就一定能为公司创造出很大的价值。这其中有主观因素，比如对工作投入的态度，也有客观因素，比如项目或公司本身有限的盈利能力。有些人也许并不优秀，但他们的做的事为公司创造了更多的价值，或许我们会想，如果把我们放在他的位置上，我们会做得更好，也许，但是我们没有这个机会，正如好花不长开一样，好机会也不常有。\n程序员很容易就陷入一个自娱自乐的陷阱中。作为一个程序员，我从不否认技术的重要作用，但是，我们应该正确的认识自己技术的价值。我们常常因为掌握了某种技术而以为自己很优秀（也许是下意识的），殊不知，掌握了这项技术，并不能为我们带来价值，只有通过这项技术为别人带来了价值，我们的价值才得以体现。前不久的部门总结会上，领导提到了一个词“marketable skill”，也就是有市场价值的技能。我们应该有技术，更应该有那些能够创造价值的技术。闫辉前一阶段发表了一个系列的文章《程序员，建立你的商业意识》。在我看来，这一系列的文章就是在告诉我们真正的价值所在。当然，价值也不完全是通过金钱体现出来的，很多游弋于网络的高人享受的更多的是声誉。如果有幸遇到的是一个在创造了很大价值之后，依然让我们过着一穷二白日子的混蛋老板，那就只好走为上计了。\n换位思考是一种很重要的思考方法，既然我们不能强求老板来换位到我们这里，我们可以尝试一下换到老板的角度。其实，只要我们换个角度考虑我们遇到的问题就不难发现答案所在。顺便说一下，有些人愿意追随做过技术的老板，很重要的一点就是他们了解我们的辛苦。\n如果你在一个因为仅仅能力很强就给你高薪的老板手下工作，自己偷着乐去吧！"
  },
  {
    "timestamp": "200604132209",
    "date": "2006-04-13",
    "time": "22:09",
    "title": "《Unix程序设计艺术》之身边的例子——透明性",
    "tags": [

    ],
    "body": "《Unix程序设计艺术》的第六章讨论的是透明性，站在开发人员的角度，我愿意把它理解为将程序内部的信息暴露出来，便于外部观察。\n最初和暴露内部信息打交道是开发服务器端应用的那会儿。对于开发服务器端应用来说，很重要的一点就是要对程序的行为进行监控，所以，日志是个不二之选。在开发的最初阶段，程序极其不稳定，幸好我们有日志帮忙，把程序的运行状态一一记录下来。通过只要分析日志，我们基本上可以确定问题所在。后来即便程序上线运行，我们也没有把日志关掉，其目的当然是为了以防万一。事实也证明了这一点，每当客户向我们报告各种问题的时候，我们总是有据可查。\n不过，这个日志也存在一个适量输出的问题。由于在开发的初期，我们没有对日志的使用方式进行严格的规范，所以，很多时候，本应是不同级别的日志都浮现出来，这边说“某某处理完毕”，那边说“某个变量等于多少”，看上去，爷爷孙子齐上阵，热闹归热闹，它也乱。对比一下Apache之类的服务器，它们日志很有规矩，正常情况下，没有多少东西，一旦出错，察看日志一般就可以看出问题所在。输出过多也多多少少会影响一些性能。当时部门另外一个项目组，他们的应用对于性能要求很高。在开发过程中使用日志，而在发布之前，要做一次统一清理，去掉不必要的日志，以免影响性能。\n我现在的工作，暴露内部信息成了一种必须的选择。最初的研究过程，我们只是以简单识别率和误识别率来说事，当算法开发到一定程度，除了需要在宏观上进行分析，我们还需要对各个模块的表现进行分析，以防因为个别模块的问题造成整体指标下降。所以，在程序运行的过程中，我们需要将各个模块的输出结果也暴露出来，以便可以对各个模块进行评估。不过，由于最初的设计中，并没有将暴露内部信息的问题考虑进去，增加一个输出项就需要改一大片的代码，于是最近痛下决心，把代码清理了一下，至少现在增加输出的改动量要小了许多。\n暴露算法内部信息的一个额外好处在于，我们可以开发相应的工具对结果进行分析。一方面，工具可以提高工作效率（现在评估一次的时间对比最初可是大大缩短）。另一方面，工具可以为我们做下一步行动提供了参考指南（原有算法中存在很多阈值，很大一部分源自大家的感觉，而非数据）。这一切都是算法透明性的功劳。\n这个世界，透明点好！"
  },
  {
    "timestamp": "200604112207",
    "date": "2006-04-11",
    "time": "22:07",
    "title": "《Unix程序设计艺术》之身边的例子——文本化",
    "tags": [

    ],
    "body": "《Unix程序设计艺术》是一本讲解Unix文化的书。作者——开源运动的发起者Eric Raymond将多年沉浸于Unix经验一一道出，对于后来者理解程序设计中一些不变的东西大有裨益。该书的第二部分讲解Unix程序在设计上的一些考虑。在我看来，这里所讲的一些设计原则，更多是站在程序的外部进行观察，比如建议程序与外部接口文本化，比如将程序的内部信息以恰当的形式暴露出来以便外部观察等等。\n这本书的第五章讨论的是文本化，也就是以文本作为存储或传输的格式。\n在我的编程经历中，很早就开始同文本格式打交道。我参与的第一个Java应用，其协议采用了SOAP，也就是XML，也就是文本格式。在随后的几年中，我一直在与XML为伍，无论是配置文件，还是传输协议，所以，文本格式在我心中成了一种理所当然的选择。记得有段时间在一个实验室测试，当时的目的就是在测协议接口，大家经常干的一件事，就是把接收或发送的包打印在屏幕上，以便快速发现问题。幸运的就是我们的传输协议是文本格式，所以，我们省去了开发额外工具或是数字节的困扰。别以为这是开玩笑，那时候，部门的另外一个项目组在同一个楼和我们一同做着测试，他们的协议是二进制的。每次看到他们一个一个数字节，我心存恐惧的同时暗自窃喜着。\n那个系统分为业务系统和管理系统两个部分，为了让二者关联起来，我们需要开发了一个通信协议。就在我们几个人在外测试的阶段，我们一个很勤快的同事把这个部分开发出来，他采用了Java的序列化作为通信协议。当他离开部门之后，我们试图修改这个部分，发现这个部分已非我们能力所能控制。一方面，他的代码给人一种满天遍野的感觉，另一方面，任何对于服务器端的修改，必须要同时修改客户端，因为传输的是二进制，所以，如果不同时对两端进行修改，我们无法保证通信的正确。原本独立发展的两端不明不白的给连接到了一起。\n最近的一个关于文本化的例子来自于我现在开发的算法中的持久化部分。在最初的Matlab版本中，我采用了文本作为存储格式，到了C移植的时候，负责移植的同事原本的想法是偷了个懒，存成二进制格式，这样一条记录一下子就写进去了，读也是。事实证明，他懒惰的目的完全没有达到，一个小错误就够他忙活上半天，因为不直观，他又也要数字节才知道问题所在。一而再，再而三，他决定放弃了，对我说，看来选择文本方式存储是个好主意。\n选择文本格式，对开发人员来说，是一种享受。"
  },
  {
    "timestamp": "200604062154",
    "date": "2006-04-06",
    "time": "21:54",
    "title": "拿成果来",
    "tags": [

    ],
    "body": "相信许多程序员和我一样，对代码的感情远远胜过文档。因为除去编译器的自动化工作，代码就是我们的最终产品，而且代码中饱含着我们的智慧，文档？那只是用来浪费时间和应付差事的东西。至少有相当长的一段时间，我是这么想的，这可能与我原来所在部门对文档没有给予足够重视的结果吧！\n我很清楚文档的意义，写作可以帮助理清思路，给后来者一个参考等等，但是，文档给我的感觉更多的是一种不得不做的事情，所以，让人很难提起精神。\n现在和我一同工作的一个博士，他来自公司软件过程做得最好的部门。他做事的一个习惯就是一定要有成果物，而文档就是成果物一种很重要的形式。或许，他是同我一起工作过的人中最愿意写文档的一个。不论是做调研，还是做设计，到最后，他保证会拿出一个质量相当高的文档。每每说起这些文档时，他总是说，以后翻起来，一看自己写了这么多文档，那也是一种成就感。他对文档的态度潜移默化地影响着我。\n编写代码带给我们的是一种成就感，难道文档就不是吗？同样的工作，干嘛要有分个高低贵贱呢！人的惰性会驱使我们不去做一些事情，但我们却愿意享受成果，其实差别只在于一个态度。就像写blog，不愿意写文档的我却很愿意写blog，因为这个过程可以带给我一些愉悦，就这样，我不知不觉坚持两年有余，偶尔，我会翻看一下自己之前写的一些blog，享受一下已完成的快乐。如果是在重压之下完成这些blog，我保证坚持不了几天，就断了继续写下去的念头。对文档，何尝不是如此？最近正在做一个调研，读过一些资料顺手做了一些笔记，几天下来，一个文档便已初具雏形了，自我感觉良好。\n有时我做事往往会跟着感觉走，做过一些工作无疾而终。做事应该有个可以衡量的成果物，不仅仅是文档。当回首成果物时，既可以告诉别人自己已经做的工作，也可以为自己做一些精神上的安慰疗法。当然对于程序员来说，在开发过程中，源码是一种不可或缺的成果物，但我们可以做得更多。"
  },
  {
    "timestamp": "200602092153",
    "date": "2006-02-09",
    "time": "21:53",
    "title": "再见，心中的Borland！",
    "tags": [

    ],
    "body": "Tag: 我眼看世界 Borland\n\n还有什么比休息更让人愉悦的事情呢？尤其是在辛苦之后。休了两个星期，如果中间没有春节，也许就更完美了。要知道，大规模集中的“走亲访友”是一件很浪费时间的事情，所以，虽然休了两个星期，但感觉上，自己好像没怎么休着。没办法，尊重传统吧！\n年后上班的第一天，最让我吃惊的新闻来自Borland。Borland居然要卖掉其赖以成名的IDE产品线。这意味着，也许从今往后，我们耳熟能详的Delphi、JBuilder等产品便要与Borland无关了。从感情上来说，这是一件令人难以接受的事情。让我走入编程之门的是Borland的Turbo Pascal，而Turbo C是我很长一段时间的最爱。初学Java时，我的首选IDE是JBuilder。想必许多程序员朋友和我一样，可能现在手头上用的不再是Borland的工具，但对Borland却有着一份难以割舍的感情。几年前，李维先生写了一部《Borland传奇》，为我们揭开了Borland神秘的面纱，一个个传奇故事展现在我们面前，一个个软件英雄的形象在心中高大起来。那是我为数不多的短时间之内连读两遍的一本书。\n不得不承认的是，最近这些年，Borland的IDE给人一种江河日下的感觉，倒不是说它的产品质量如何如何，只是那个IDE商业大战的年代已经越走越远。在两大主流战场上，微软牢牢把持着.NET这块大饼，Eclipse凭借开源的优势占据了Java的山头，留给Borland的空间越来越小。我们看得出Borland在努力，努力扩展它的业务，将自己的势力范围扩展到整个软件开发周期中。作为一件商业公司，Borland也需要赢利，抛弃赢利能力不足的部分，在商业上无可厚非。\n许多程序员对于自己喜爱的语言或工具往往有着宗教信仰一般的追随，Borland用20多年的时间，打造出了一批忠实的追随者。Borland放弃IDE对于这些追随者来说，是一件痛苦的事情。心中的Borland，是那个开发IDE的Borland。也许从此，我们需要把原本一个的关注点一分为二，一部分追随Borland，一部分追随那些IDE明星。愿Borland能如其所愿，持续发展，愿IDE们在新的环境中继续茁壮成长！"
  },
  {
    "timestamp": "200601251346",
    "date": "2006-01-25",
    "time": "13:46",
    "title": "写在放假前",
    "tags": [

    ],
    "body": "Tag: 脚下的路\n\n做集成，最大的缺陷在于工作肯定是最后完成，即便代码编写得再完美。因为任何人出错了，最终都会在这里暴露出来。现在是算法移植工作，也就是把原来用Matlab编写的代码改成C语言实现。我编写的是算法部分集成的代码，谢天谢地，在我后面还有一个人负责将算法集成到应用中，所以，大多数时间，我是比较轻闲的，但无论如何，我的人得在，即便什么都不做，因为谁也无法保证不出任何错误。\n最初选择Matlab作为实验平台，看中的是它的便利，而现在用C，无它，性能。语言之间的差别不仅仅是在语法上。任何一种语言背后都是一个环境、一种文化。使用Matlab这样相对高级的语言开发，好处是让一些在编程方面的新手能够快速的进入角色，他们不必像编写C代码一样顾虑很多与问题本身无关的细节，比如内存管理。但坏处也就此浮出水面，因为他们对编程的理解很还处于刚刚起步的阶段，所以，对于一些内部质量相关的因素考虑甚少。当代码在自己手中维护的时候，这个问题还不是很明显，但到了移植阶段，尤其是别人移植他们代码的时候，一切问题就都暴露了出来。\n在我们的移植过程中，就有这样的模块，Matlab版本由一组人开发，而移植工作交给了另外的人。这两天许多让我们倍受折磨的问题基本上都源自这个模块。按照领导的本意，负责算法研究的，只关心算法研究就可以了，而移植工作交给负责程序开发的人，按照分工合作的策略，这本是不错的选择。遗憾的是，负责程序开发的人也是一个新手，对算法不甚了解不说，对程序设计也没有太多的感觉，所以，只能选择原样照搬。偏偏对应时存在一些偏差，不在逻辑而在语言本身，比如Matlab数组坐标从1开始，而C是从0开始，这样，问题就来了。\n这些天改程序越发体会到“高内聚、低耦合”的重要性。因为有全局变量，为了方便，就出现了许多访问全局变量的代码，这样，也就有大量代码依赖于全局变量，而实际上，其中的很多代码完全可以通过多传几个参数消除对全局变量的依赖。虽然全局变量在各处都可以访问，但依赖它们就意味着，陷入泥潭无法自拔，因为这些代码将暗中与其它使用这些全局变量的代码耦合。事实证明了这一点，常常是改了一个地方，其它地方会莫名奇妙的出错，原因就是因为随处可用的全局变量。虽然，在很多公司中，严格区分编码和设计的人，但在我看来，如果想编好代码，不真正理解设计原则——比如“高内聚、低耦合”——是不可能的。\n领导问我，改程序的感觉如何，我答，C++真好。这里我想说的是最简单的C++功能，封装。封装意味着提高抽象能力，隐藏细节。其实很多后来的语言都成功的运用了封装，比如Java封装了内存管理的细节，许多动态语言封装了一些标准的数据结构。我们使用Matlab的目的也是如此。C在语法层面上对封装支持得不够好，所以，我们不得不在面对具体问题的时候，还要考虑语言的细节。在Matlab中，每个数组都有自己的长度，而在C里面，我们单独维护一个数组长度的变量，就是这样简单的差异，就造成了无数次的崩溃，仅仅是因为变量没有正确的赋值。原因很简单，因为原来Matlab版本中根本没有维护长度变量的代码，所以，移植的人在这个问题上出错也就不足为奇了。\n虽然我们的程序存在这样那样的问题，但想想去年刚开始什么都没有的时候，已经不知道好了多少。经过大家一年多的努力，能形成现在这样一个看上去还可以接受的程序，不禁让人感叹人的潜力无限。很多问题看上去很困难，有时甚至让人绝望，但真正走过去之后，才发现“原来一切就是这么简单”。\n春节放假前的最后一天，原本今天已经放假了，结果还有些收尾的工作，领导决定，晚放一天，晚归一天。连续几天都加班到了很晚，终于要休息了。"
  },
  {
    "timestamp": "200601181054",
    "date": "2006-01-18",
    "time": "10:54",
    "title": "时间与质量",
    "tags": [

    ],
    "body": "Tag: 我眼看世界\n\n无论是流言蜚语还是亲身体验，时间总是与软件开发过不去，很少听说哪个项目拥有充足的时间，等待我们的似乎只有拼命的与之赛跑。有时，项目到我们这里时，最后期限便已经确定了下来，至于项目中究竟有多少内容，能否如期完成，没人真正关心过，而且通常是时间不够用，所以吃亏的肯定不是制订期限的人。\n曾经，我畅想做一个宽松的项目，但后来，我告诉自己，这是不太现实的。假设真有这样的机会，那在制订项目计划的时候，除了必需的工作时间之外，我们还应该将一些缓冲时间考虑进去，以应对难以预知的一切。拿到这样一个时间表，你会做何感想。由于站的角度不同，我们会下意识的忽略缓冲时间，于是，我们认为时间充足。既然时间尚早，我们便不会着急动手。等神游归来，时间不知不觉已经逝去许多，原本充裕的时间也变成了紧张。这种感觉很熟悉吗？我读小学的时候，我和许多同学在假期作业的问题上经常面临这样的尴尬。项目负责人们估计都很清楚这一点，于是，干脆取消了缓冲时间，甚至在时间表上压缩必要的工作时间，给人制造出一种压力，以防止心理上的懈怠。\n时间表上的时间是固定的，但实际的时间却是稍有富余的，因为正常的工作时间一周只是40个小时而已，于是，加班成了一种让时间表看上去很美的选择。为了早日脱离加班的苦海，程序员们必须尽快的完成自己的工作，正所谓“上有政策，下有对策”，时间的压力会使我们放弃一些东西，一种常见的选择便是质量。\n有过一些编程经验的人应该知道，实现同样功能的代码可能是千差万别，所以，才会有所谓高手的说法。《面向对象软件构造》教导我们说，软件质量分为内部质量和外部质量。站在用户角度，他们关注的只是外部质量，只要用起来感觉一样，他们不会介意内部质量的。既然外部质量容易为人察觉，那么时间压力让我们放弃的便是内部质量。对于软件开发人员来说，内部质量却是一个很关键的因素。除非你打算过河拆桥，做完项目便撒手不管，否则，差劲的内部质量会让未来的自己倍受折磨。但是，这种问题在短期内很少暴露出来，却是对项目的一个长期伤害。《程序员修炼之道》讨论过破窗户的问题，我也曾《体验破窗户》，而时间压力就是一个很好的产生破窗户的理由。\n我们是唯美的程序员，我们不愿意编写令人作呕的代码。时间啊！别逼我们！"
  },
  {
    "timestamp": "200601122315",
    "date": "2006-01-12",
    "time": "23:15",
    "title": "始业再教育",
    "tags": [

    ],
    "body": "Tag: 脚下的路\n\n我参加了几天始业教育，没错，是始业教育。领导为了让我们更好的了解公司，宁可让我们一帮人放下眼下的工作去受教育。对公司最为全面的介绍莫过于始业教育，于是我有机会接受了一次再教育。上次参加始业教育已经是四年前的事，按照同事们之间的说法，那时候，我们还年轻。\n与第一次参加始业教育更多的是在追随着讲师思路心潮澎湃不同，几年的工作经历让我能够很清楚知道讲师在说什么。在这种培训课程上，讲师更多的是在宣扬一些好的东西，也就是公司希望做到的，至于与实际之间的差别，他们是不会告诉你的，理想同现实之间的差距总会让人感觉残酷。所谓老员工的优势所在就是能够清楚的看到这一切。\n公司已经不是几年前的那个公司，始业教育也上了一个台阶，所有的讲义也更加系统化了。公司的目标是成为了一个“大”公司，这一点从始业教育中所宣扬的东西中可以清晰的看出来。从前，我不是很理解为什么公司并不是非常重视个人的作用，直到我读《Joel说软件》，其中第三十三篇《巨无霸麦当劳与天才厨师Jamie Oliver》讨论的就是这样一个话题。不同的公司有不同的发展方向，“大”公司通过过程让能力一般的人也可以制造出足够优秀的东西，而“小”公司则需要充分发挥个人的能力，其结果往往是制造出更为优秀的东西。所以，“大”公司强调过程，“小”公司重视人。我们无法简单评述孰是孰非，方式方法不同而已。\n最近看到的一些报道和一些招聘广告，现在许多“新”公司越来越强调人，为员工提供一个舒适的工作环境，自由的工作氛围，以便他们可以更好发挥自己的智慧，为公司创造更大的价值，这方面的典范是google。剥削的方式有许多种，让人心甘情愿被剥削是一种很高的境界。这个世界上真正重要的是人的智慧，人的智慧会让机器来做简单重复性的工作，到那时，等待做这些工作的人将会是什么呢？可想而知。"
  },
  {
    "timestamp": "200601082120",
    "date": "2006-01-08",
    "time": "21:20",
    "title": "张驰有道",
    "tags": [

    ],
    "body": "Tag: 脚下的路\n\n代码写得快也未见得是什么好事。周五下班前，我完成该写的代码，为即将到来的周末做好了充分的心理准备，这时，领导找到我。\n“你那部分写得怎么样了？”\n“完事了。”\n“XX的部分没人写，你就把它写了吧！”\n就这样，所有美好的周末幻想全部成为了泡影，可怜我的周末在公司编码中度过，。\n我不喜欢加班，去年那一段让我心情沮丧的加班之后，尤其如此。何况，只见加班，不见加班费。在从前的部门中，私下里有一种说法，“能者多劳，累死拉倒”。领导会根据你的能力给你安排工作，也就是说，表现得越好，越有机会承担更多的职责，这会直接导致能力的不断提升，不过，薪水的成长却是“老牛拉破车”，一步一个深深的脚印，扎实得很，不匹配的结果就是公司成为了著名的人才摇篮。\n熬过去年那段痛苦之后，这次还是我几个月来第一次周末在公司加班。干我们这行而没加过班的大概是稀有动物。其实，加班并不可怕，为了项目能够正常进行偶尔加一次也没什么大不了，可怕的是加班成为一种常态。\n大多数时间里，我的工作对我而言并不是压力非常大，因此，我总有些闲心去偷懒。我也经常为自己的这种状态不安。与老妈谈起这个话题，老妈告诉我，当自己的绝大多数工作让自己用尽全力，恐怕自己的能量也就到头了。老妈的话让我释然，偷懒是一种释放压力的方法。虽说有人琢磨出“软件蓝领”的说法，但我们毕竟需要用脑子完成工作。在经常处于高压之下，脑子容易僵硬，比如，我这两天写的代码整体质量要比我之前写的那些差了许多，质量往往与压力成反比。\n看过一些报道，虽然程序员每天上班八小时，但不可能真正的工作八小时，Joel的《Fire And Motion》（中文版《行进中开火》）很好的描绘了这种状态。Google懂得这一点，干脆给了员工20%的偷懒时间，于是，一批为人称道的产品出现在我们面前。\n一张一弛，文武之道。"
  },
  {
    "timestamp": "200511212232",
    "date": "2005-11-21",
    "time": "22:32",
    "title": "买书不读",
    "tags": [

    ],
    "body": "王垠："
  },
  {
    "timestamp": "200511161909",
    "date": "2005-11-16",
    "time": "19:09",
    "title": "乱弹设计",
    "tags": [

    ],
    "body": "Tony：tony说设计-实践后的体会\nTony的这篇blog让我想起了自己两年前第一次真正扛起一个项目架构设计的时候，意气风发，一门心思琢磨如何做一个漂亮的架构。不过，翻遍了整篇blog，我没有找到我心中的设计第一要素：正确性。是的，正确性！\n曾经的我就是一个为技术而技术的人，当一个项目启动的时候，我首先考虑的就是如何展现自己的功力，如何编写优雅的程序，而忽视了根本性的问题：需求。真正让一个软件产生价值的就是需求。少了需求，软件的意义也就荡然无存了。当一个人做事连自己的目标都搞不清楚的时候，不做错事，已经要感谢上天的眷顾了。没有正确的目标，其它的努力只是让自己在未卜之途上越走越远。有许多部影片为我们展示了邪恶科学家的威力，他们不是不努力，只是弄错了方向。\n在设计中，功能性需求的意义要远远超过非功能性需求。非功能性需求多半是为了让自己未来的日子好过一点，少了非功能性的需求，大不了是自己不爽，周遭的同事们不爽，有些糊涂的家伙说不定还会心甘情愿忍受这种折磨。少个功能性的试试，用户不掏钱，老板会给你好看。当然，让自己和用户都满意是我们的最高目标，我们犯不着只顾用户而忽视了自我，再者，功能性的东西可能不会追随我们一生，而非功能性的则可以在日后的日子里让我们不断受益。\n所谓设计，对个人而言，就是一个想明白怎么做的过程。如果只是在自娱自乐，想明白之后去做就是了。但是现在我们多半是与人合作，在这种情况下，设计是一个合同。既然要做一个设计师，我们必须考虑如何为别人（这个别人有时包括了自己）分配任务，这时候，我们就用合同——设计规定了双方的权力和义务，这样，在出错的时候，我们才能根据合同找到对应负责人。由此说来，契约式设计（Design by Contract）就是一件顺理成章的事了。设计就是分工，分工的目的就是为了各司其责，不明确的设计也就意味着责任不能对应到人身上。只要设计上存在盲点，我们就有机会遭遇互相推诿。Grady Booch曾经举过一个狗窝和大厦的例子，其实这就是没规矩和有章法的差异。我们通常所说的设计，多半是这种有规矩的设计，为了与人协作的设计。\n在我看来，谈到设计，最好的设计标准还是那条经典的“高内聚，低耦合”。了解了这么多的设计手法，体会那么多的设计原则，到最后，基本上都能归结到这条标准上来。设计的过程是一个分分合合的过程，先是把系统分拆，再把功能相近的东西合并，这样就形成了一个模块，有人叫服务、子系统、类、组件、函数、方面……，都是一回事。设计者需要考虑的就是让怎么去做这个游戏，以便让各人能够独立工作而不致于相互影响，这就需要请出“高内聚，低耦合”作为衡量标准。模块之间的合同就是我们常说的“接口”，它可能是函数调用，可能是参数传递，可能是共享数据，也可能是远程调用。总之，有了合同好办事，谁的问题谁负责。\n   \nTony有一点说得很好，设计是一种权衡的艺术，只有在不断学习实践中才能培养这种权衡的感觉。不要怕犯错误，只要实现了功能就是对的，设计是一种“只有更好，没有最好”的东西。大多数做设计的人是在为公司服务，这就决定了你想犯大错误都不现实，既然公司为我们提供了这么好的锻炼机会，我们不妨充分利用这些机会，让自己的设计水平不断提升，毕竟本事才是自己的。\n关于设计，胡扯了很多，到此为止吧！"
  },
  {
    "timestamp": "200511101600",
    "date": "2005-11-10",
    "time": "16:00",
    "title": "探索Antlr",
    "tags": [

    ],
    "body": "简介\nAntlr（ANother Tool for Language Recognition）是一个工具，它为我们构造自己的识别器（recognizers）、编译器（compiler）和转换器（translators）提供了一个基础。通过定义自己的语言规则，Antlr可以为我们生成相应的语言解析器，这样便可以省却了自己全手工打造的劳苦。\n目标\n如同程序设计语言入门大多采用“Hello World”一样，编译领域的入门往往选择计算器。而这里迈出的第一步更为简单：一个只能计算两个数相加的计算器，也就是说，它可以计算“1+1”。\n基础知识\n先来考虑一下如何下手，如果你曾经接受过编译原理的教育，权当忆苦思甜了。这个计算器工作的前提是有一个需要计算的东西，不管我们是以文件的形式提供，还是手工输入，至少我们可以让我们的计算器知道“1+1”的存在。\n有了输入之后，我们要先检查输入的正确性，只有对正确的输入进行计算才是有意义的。如同写文章有形式和内容之分，这里的检查也要细分一下，率先完成的检查当然是面子功夫——形式上的东西，看看是否有错别字的存在，我们要做的是数值相加，结果人家给出了一个字母，这肯定不是我们希望得到的，所以我们有权力拒绝这个不合法的东西。对于程序员来说，如果在自己的程序里写了一个语言不接受的标识符，比如在Java里用“123r”做标识符，那编译器肯定会罢工，拒绝让程序通过编译的。在编译原理里面，这个过程叫做词法分析。在我们的计算器中，我们只接受整数和加号，其它的一概不理。这里我们说的是“整数”，而非“1”、“2”……，对我们来说，它们代表着同一类的东西，编译原理教导我们把这这种东西叫做token，那些数字对我们来说，都是一样的token，不同的仅仅是它们的值而已。\n形式说得过去并不代表内容就可以接受，南北朝时期许多骈体文让我们看到了隐藏在华丽的外表下的空虚灵魂。你可以说“我吃饭”，如果说“饭吃我”，除非是在练习反正话的场合，否则没有人会认为它是有意义的。只有在闯过了词法分析的关口，才能到达这里，在编译原理里面，我们把这个阶段叫做语法分析。如果说词法分析阶段的输入是字符流的话，那么语法分析阶段的输入就是token流——词法分析的输出。我们这里接受的合法语法是“整数 加号 整数”。\n编写语法文件\n好了，制订好自己的语言规则之后，我们需要以Antlr的语言把它描述出来。\n下面便是以Antlr的语言描述的语法：\nclass CaculatorParser extends Parser;\nexpr:   INT PLUS INT;\nclass CaculatorLexer extends Lexer;\nPLUS  : '+' ;\nINT   : ('0'..'9')+ ;\nAntlr的语法文件通常会保存在一个“.g”的文件中，我们的语法文件叫做“caculator.g”。\n先来看看Lexer部分，它便是我们前面所说的词法分析器。首先声明自己的Lexer：\nclass CaculatorLexer extends Lexer;\n这句话有两个作用，其一，为生成代码中的词法分析器定义名字，其二，告诉Antlr，我要定义词法规则了。既然说到词法规则，紧接着我们就定义了两条词法规则：\nPLUS  : '+' ;\nINT   : ('0'..'9')+ ;\n这里的规则很容易看懂：\n* PLUS定义的token，就是一个单一的“+”\n* INT定义的token，由从'0'到'9'之间任意的数字组成，后面的加号表示它是可以重复一次到多次\n定义好Lexer之后，便轮到Parser了：\nclass CaculatorParser extends Parser;\n它的作用同Lexer的定义一样，之后是语法规则：\nexpr:   INT PLUS INT;\n有了词法分析的经验，这条语法规则也很容易看懂，不同于Lexer中规则使用字符定义，这里我们用Lexer中定义的token定义语法。这也符合前面所说的，词法分析的输入是字符，语法分析的输入是token。我们定义了一个表达式：\n* 一个INT，后面跟着一个PLUS，后面在接着一个INT。\n编译语法文件\n如同不编译的程序是无法发挥其威力一样，单单语法文件对我们来说，并没有很大的价值。我们的工作就是使用Antlr提供工具对我们的语法文件进行编译，不同于日常的编译器输出可执行文件，这里的输出是程序语言的源文件。Antlr缺省目标语言是Java语言，它也可以支持C++和C#语言，2.7.5之后，Python也走入这个家族。\n将antlr.jar加到classpath中，然后把语法文件的名称作为参数传给语法编译器：\njava antlr.Tool caculator.g\n在确保命令正确执行，且语法文件编写正确的情况下，Antlr为我们生成了几个文件：\nCaculatorLexer.java\nCaculatorLexerTokenTypes.java\nCaculatorLexerTokenTypes.txt\nCaculatorParser.java\nCaculatorParserTokenTypes.java\nCaculatorParserTokenTypes.txt\n这里我们主要关心的是CaculatorLexer.java和CaculatorParser.java，它们就是我们在语法文件中定义的Lexer和Parser。其它几个文件只是定义了一些常量，让我们暂时忽略它们的存在。\n运行程序\n生成代码之后，就是如何使用这些生成的代码。下面就是我们的主程序，它负责将Lexer和Parser驱动起来：\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CaculatorLexer lexer = new CaculatorLexer(System.in);\n        CaculatorParser parser = new CaculatorParser(lexer);\n        try {\n            parser.expr();\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n    }\n}\n从这段代码中可以清晰的看出，Lexer的输入是一个字符流，而Parser则需要Lexer的协助来完成工作。一切就绪，我们让它跑起来，尝试输入一些内容，看它是否能够通过验证。事实证明，我们的程序可以轻松识别“1+1”，而对于不合法的东西，它会产生一些抱怨。\n计算结果\n还记得我们的目标吗？我们的目标是计算出“1+1”的结果，而现在这个程序刚刚能够识别出“1+1”，我们还要继续前进。\n熟悉XML解析的朋友对于SAX和DOM一定不陌生，二者之间差别在于SAX属于边解析边处理，而DOM则是把所有的内容解析全部解析完（在内存中形成一棵树）之后，再统一处理。Antlr也有与之类似的两种处理方式，SAX的朋友是在Parser中加入处理动作（Action）处理将随着解析的过程进行，而DOM的伙伴则是解析形成一棵抽象语法树（Abstract Syntax Tree，AST），再对树进行处理。\n加入Action\n先来看看SAX的朋友。因为处理动作是加在Parser中的，所以，我们的Lexer保持不变，下面是修改过的Parser。\nclass CaculatorParser extends Parser;\nexpr returns [int value=0]\n      :  a : INT PLUS b : INT {\n          int aValue = Integer.parseInt(a.getText());\n          int bValue = Integer.parseInt(b.getText());\n          value = aValue + bValue;\n      };\n看到常用的字符串转整数的方法，熟悉Java的朋友想必已经露出了会心的微笑。没错，这里定义Action的方法采用就是Java语言，因为我们生成的目标是Java，如果你期待另辟蹊径，那这里的代码就要用你的目标语言来编写。\n仔细看一下不难发现，action完全是在原有的规则基础上改造的来。首先用returns定义了这个Action的返回值，它将返回value这个变量的值，其类型是int，我们还顺便定义这个变量的初始值——“0”。接下来，我们用a、b拿住了两个token的值，我们前面说过，在检查的过程中，我们并不关心每个token具体的内容，只要token的类型满足需要即可，但在action中，我们要计算结果，那必须使用token具体的内容，所以，我们用变量拿住了token。在生成的代码中，a的类型antlr.Token，因此，我们通过a.getText()来获得token的具体值。剩下的动作就很简单了，把文本转换为数字，进行加法运算。\n是不是对我们的计算器有些迫不及待了，那就挥动工具生成全新的Parser。不过，在新的体验之前，我们还要稍微修改一下主程序，以体现我们的劳动成果。\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        CaculatorLexer lexer = new CaculatorLexer(System.in);\n        CaculatorParser parser = new CaculatorParser(lexer);\n        try {\n            System.out.println(parser.expr());\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n    }\n}\n好了，让这个计算器来为我们求证“1+1”吧！\nAST\nSAX的朋友表演完了，下面就是DOM的伙伴登场了。\n建立AST的方式很简单，只要我们Antlr一个建立AST的选项即可，下面就是新的Parser：\nclass CaculatorParser extends Parser;\noptions {\n    buildAST=true;\n}\nexpr:   INT PLUS^ INT;\n稍微有些不同的地方在PLUS上面的“^”，这个符号用来告诉Antlr创建一个节点，以此作为当前树的根节点。\n你也许会有些疑问，怎么没看到计算的加法的地方？别急，大戏要压轴。下面登场的是Antlr整个故事最后一个大角，TreeParser：\nclass CaculatorTreeParser extends TreeParser;\nexpr returns [int value = 0;]\n      : #(PLUS a : INT b : INT) {\n          int aValue = Integer.parseInt(a.getText());\n          int bValue = Integer.parseInt(b.getText());\n          value = aValue + bValue;\n      };\nAntlr可以接受三种类型语法规范——Lexer、Parser和Tree-Parser。如果说Lexer处理的是字符流、Parser处理的是Token流，那么TreeParser处理的则是AST。前面Action的处理方式中，我们看到，规则同处理放到了一起，显得有些混乱，而采用了AST的处理方式，规则同处理就完全分离了：在Parser中定义规则，在TreeParser中定义处理，如果我们需要对同样的语法进行另外的处理，我们只要重新TreeParser，而不必在规则与Action混合的世界中苦苦挣扎。\n有了前面Action的基础，来看TreeParser如何编写也就简单许多，需要说明的就是：\n#(PLUS a : INT b : INT)\n除去变量的说明，简化一下这段代码\n#(PLUS INT INT)\n第一个符号PLUS对应了表示着根节点，两个INT则分别代表了两棵子树。\n再来看看重新打造的主程序\npublic class Main {\n    public static void main(String[] args) {\n        CaculatorLexer lexer = new CaculatorLexer(System.in);\n        CaculatorParser parser = new CaculatorParser(lexer);\n        try {\n            parser.expr();\n            AST t = parser.getAST();\n            CaculatorTreeParser treeParser = new CaculatorTreeParser();\n            System.out.println(treeParser.expr(t));\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n    }\n}\n结语\n体验过最简单的Antlr程序，我们就有了让它更为丰富的基础，接下来便是自己动手的时间了。\n参考资料\n《ANTLR入门》 2004年第三期《程序员》\n《ANTLR Reference Manual》"
  },
  {
    "timestamp": "200511092148",
    "date": "2005-11-09",
    "time": "21:48",
    "title": "读《做最好的自己》",
    "tags": [

    ],
    "body": "刚刚拜读了开复先生的《做最好的自己》，趁着脑中尚存余温，我写下了下面的文字。\n我是一个书虫，不愿意让任何好书与自己擦肩而过，加之开复先生在我心目中一贯的良师形象，使得《做最好的自己》成了我当然之选。在我看来，一本好书的价值并不仅仅在于阅读过程的片刻愉悦，更是为人打开一扇通往新世界的大门。在这一点上，《做最好的自己》没有辜负我的厚望。\n书中，开复先生提出了“成功同心圆”，即以正确的价值观为核心，辅以积极、同理心、自信、自省、勇气、胸怀六种重要的人生态度作为同心圆的第二层，再以追寻理想、发现兴趣、有效执行、努力学习、人际交流、合作沟六种行为方式通构成同心圆的最外一环。\n这本书大多的观点在开复老师先前的文章中已有阐述，对于拜读过那些文章的我来说，这本书并没有太多全新的观点。但这本书的价值就在于，将所有散落于各处的观点系统化，汇集成册，让人一次领略，就如同转瞬之间遍览名山大川一般，痛快！\n在阅读过程中，我总会情不自禁用自身与之对比，不经意间，便成就了一次心灵的洗礼。对我而言，这是一次很好的自省，让我对自己的优势与不足有了一个相对清醒的认识，也让我得以重视自己曾经忽略的一些东西。课前的预习可以让人更好的理解老师所讲的内容，同样，仅仅被动接受一本书带给你的内容并意味可以深刻的理解。一本好书，不同的人品味，感受差之甚远。工作的几年，我学会了思考，而这本书上的内容恰好是我近一年多时间里思考的问题，许多道理都是付出相当的代价才得以悟出，无意间的预习让我从阅读中得到了更多的震动。虽然感叹开复先生没有早点完成此书，但转念，即便那时我读到此书，没有一些刻骨铭心的东西，对于开复先生的箴言，我不可能有今天这样的体会。\n良师益友对一个人的成长大有助益，但良师益友却可遇不可求，良师尤为如此。可称之为良师的人，大多是在某一领域经验丰富且善于思考者，如此才能高屋建瓴为人指出明路。虽然不遇良师并不妨碍继续前行，但良师的催化作用，可以让人少走许多弯路，加速成长。开复先生便是一位良师，《做最好的自己》算得上这位良师悉心打造的一本好教材，通过它，虽不曾与开复先生谋面，却不妨碍与先生神交，听着先生将一些道理娓娓道来，辅以一个个真实的故事，乐在其中。\n尽信书不如无书，简单的照搬书中建议恐怕也不是开复先生希望看到的，毕竟，每个人都有自己的精彩。再好的一本书也不会让人读罢便脱胎换骨，成就一番大事业，它给人带来更多的是一些可以指导我们未来学习工作生活的原则，和一些对待问题的思考方法。\n作为一名读者，我感谢开复先生带来了《做最好的自己》。"
  },
  {
    "timestamp": "200510302346",
    "date": "2005-10-30",
    "time": "23:46",
    "title": "做自己的客户",
    "tags": [

    ],
    "body": "周末，和一个朋友聊天，谈到了现在有不少软件做得都差强人意，尤其是所谓企业级的产品。在我看来，首先是这些软件并不要求做得那么好，它们只是所谓的赢利工具，我们知道80/20原则，20%的精力就可以赚到80%的钱，何苦再去花剩余80%去争取20%的钱呢？而且，也许操作复杂，也许维护困难，那不正是所谓的“专业人士”一展身手的地方吗？在功利性不那么强的开源领域，通常产品质量要好出许多。我的朋友强调，他做东西目标在于“good enough”，而我做东西的态度则是“尽可能的好”，我不能因为观点不同就轻易否定了他，但我想他似乎忘记了，念书的时候，凡是以及格为目标的同学总是徘徊于补考/重修的边缘，而如果以满分为目标，尽管通常无法到达，但至少可以轻松跳过那条生命线，当然那需要更多的付出。\n再有很重要的一点是，自己通常不是自己的客户。我们只是开发者，写出来的程序是给别人用的。我们都听说过这样的说法，如果想做好一个领域的软件，那就要成为一个领域的行业专家。如果不了解这个行业，不在一个真实的环境下亲自使用自己的软件，我们怎么会知道自己写出来的软件是否真得满足人家的需要。回想一下自己的计算机历史吧！总会有那么几个软件让脏话有一种破口而出的冲动。由此我们可以推断，其作者要么干脆很少用这个软件，要么就是一个逆来顺受的家伙。如果不经常使用自己的软件，我们不可能知道那种真实的感受，我们可以拼命的站在别人的角度考虑问题，但那与成为那样的人毕竟有差别，饱汉子怎知饿汉子饥。\n孟岩写了一篇文章，探讨了国内公司技术创业的问题，主要是说，这些人选择的方向大多是技术的方向，比如架构、比如组件。且不以英雄论成败，很多时候，技术不是决定性因素。套到这个话题上，他们的选择还是不错的，因为他们本身是做技术的，选择业务作为自己的“行业”，当然，也就是让自己成为了自己的用户，因此，他们可以在自己的日常工作中，时时刻刻的与自己的产品打交道，细微之处，自然可以有深刻的体会。至于能否再上层楼，那是态度和能力的问题了。\n其实，程序员除了拥有程序员的身份之外，还有一个很重要的身份——计算机用户。对于我们来说，这可能是仅有的两个不需要我们学习额外“行业”知识的领域了。从这个角度来说，Microsoft、Google、Borland等公司的程序员相对许多程序员要幸福许多，因为他们不需要付出更多的努力就已经是“行业专家”了，这或许是这些公司比较吸引人的又一点原因吧！他们只需要扮演好自己的应该扮演的角色，并不断做得更好。\n《Joel说软件》中的第三十篇《在这个国家狗是干什么的》讨论一个类似的话题。当然，如果压根不想做得更好，那就领当别论了。"
  },
  {
    "timestamp": "200510232333",
    "date": "2005-10-23",
    "time": "23:33",
    "title": "EJB设计马后炮",
    "tags": [

    ],
    "body": "Tag: 向上走\n\n在without EJB之后，EJB在开明人士的眼中已经快成了人人喊打的过街老鼠。我不妨也干一回落井下石的事，从设计的角度，品评一下EJB。鉴于without EJB嘹亮的声音，这篇blog也算是一篇读后感，故称马后炮。\n谈到设计，最先在头脑中出现的Robert Martin的《敏捷软件开发》，这本Jolt大奖作品应该是给我冲击最大的几本书之一，它为我打开软件设计的大门，对我而言，它最有价值的部分并不在于设计模式，而在于设计原则。相对于设计模式而言，设计原则是一些meta的知识，掌握了设计原则，理解模式也就是很自然的事情了。\n提起EJB，人们首先会想到它叫得最凶的组件的概念。在经典的J2EE架构中，EJB往往是单独部署在一台应用服务器上，所以，谈及EJB，它的远程访问也是必不可少的。我就曾经设计过一个EJB，目的只是为了使用它的远程模型，省却自行开发通信协议的烦恼。既要承担业务组件的职责，又要扛起远程通信的大旗，EJB在这一点上很显然是一个部分承担了多个职责，这显然是违反单一职责原则的。或许你编写EJB只是作为一个业务组件，但你不能说我用它做远程通信就是错的，尽管这不是什么标准做法，谁让EJB这么能干呢！其实，为了讨论方便，我还少提了一点，EJB往往还有线程模型在其中，这只是让它能干的事更多，进一步违反单一职责的纪律而已。\n“声明性”为简化程序结构提供了一条金光大道，只要你做好自己该做的事情，一些额外的服务可以通过声明附加进去，让程序的威力得到加强。EJB在这方面做了一些事情，提供了包括事务管理、线程管理和安全性在内的一些常用服务。但是，这些服务远不足以满足人们日益增长的物质文化需要。当你冀望于按照自己的想法增加一些服务时，你才会发现，报国无门啊！EJB很好的做到不必修改，但其不能扩展的实际情况实在有愧于框架的美誉。这显然是违反了开放—封闭原则。\n在这个敏捷横行年代，如果做设计的时候不考虑测试的问题，那这个设计师一定会被视为老古董，因为他连测试优先都不知道。测试驱动开发的“开发”可不只是编码，那是要从软件开发的源头算起的“开发”，身在开发过程之中的设计自己也不能免俗了。如果你像我一样经历过在应用服务器上调试一个bug，你就知道我为什么心甘情愿地奔向测试驱动开发的怀抱，那是一段让人不堪回首的往事，本来三两分钟就可以搞定的问题，耗去了两个小时。而这一切的一切，起因就是EJB。\n考虑EJB问世时，敏捷尚未成风，我们还可以原谅它对于可测试性缺乏思考，那么违反单一职责原则和开放—封闭原则实在是制订标准的人对于这个问题思考不足，想来设计这些东西的人也并非等闲之辈，由此我只能得出一个结论：官僚主义害死人的。"
  },
  {
    "timestamp": "200510182359",
    "date": "2005-10-18",
    "time": "23:59",
    "title": "质疑思潮",
    "tags": [

    ],
    "body": "Tag: 我眼看世界\n\n2004年，Rod Johnson写了一本《Expert One-on-One J2EE Development without EJB》，掀起了一阵反思的浪潮，让软件开发开始从迷信的浮躁中回归。与朋友们戏言，Rod是优秀的一个愤青，他毫不留情指出EJB存在的种种问题，让深受其害的人们大呼过瘾，我之所以给他扣上一顶“优秀”的帽子，是因为他不仅挑毛病，更能有针对性给出解决方案，这就是Spring。在Spring 1.0发布之前，我便已经开始在项目中使用。初时，它在我眼中只是一个辅助软件构造的工具。随着Spring一路走来，实践让我对它越发了解。对我而言，Spring让我对软件开发的理解上了一个层次，也让我越发看清它背后那张宏伟的蓝图。所以，Without EJB中的种种论述，与我心有戚戚焉。\n现在看来，Rod带来的不仅仅是技术上的变革，更带来了一种置疑的思潮，那些希望再进一步的人们开始审视自己以往的心路历程，这不，Bruce Tate干脆开始置疑Java，喊出了“Beyond Java”。\nRuby on Rails的开发经历给了他一些思考。在他看来，在Java中，复杂的企业问题也许更容易解决，但是最简单的问题正变得难于解决，而且在Java之外出现了一些有趣的革新，所以，他冀望于让眼光超越Java。顺便说一下，这让我想起了Perl哲学中的一条，“易者易为，难者可为”。\n开始思考总是好的，不认识到问题何谈解决问题呢！不过，Bruce干得可没有Rod那样漂亮，他只是把问题提了出来，却没有给出一个完整的解决方案。不过，想来也是，Java庞大的根基可不是轻易可以动摇的，所以，Bruce用的是“beyond”，而不像Rod那样大胆的使用了“without”。\nTSS上的大讨论有一个观点很好，“IT进步是演化（evolution）而非革命（revolution）”。进步总是一点一滴积累起来的，认识到问题，改进它，这就是进步，由此看来，Bruce工作的意义并不在于喊出了一个新口号，而是开启了人们对Java现状反思的大门。\n仔细观察，我们不难发现，每个年代所谓的主流在带来革新思想之外，还能够提供很好向后兼容：C语言可以与汇编代码很好的融合，C++则完全兼容C语言，Java则通过native接口与C/C++有很好的结合。语言在语法方面的进步只是让编程更容易，真正让语言立足的是广泛存在的程序库，Java之所以可以迅速推广，JDK做了非常好的助推剂。与原主流语言的兼容则可以让新语言在自己尚未健全之前，可以很好借助于原主流起跑，吸引那些原主流语言的用户。从这一点上来看，Groovy是一个很好的承袭了这种模式，直接利用Java现有的库，让它拥有了一个相当不错的起点。\n不过，好的东西并不一定成功。很多时候，一些好东西带来的是思想的变革，结果常常是太过超前的思想让人们难于接受，人们最熟悉的例子应该算是虚拟机，Java只是在一个恰当的时候，把从前一个很好的思想拿了过来而已。\n普通程序员，与先行者之间还有相当的差距，而一些人总是不愿意让别人动自己的奶酪，结果我们就可以看到一场场精彩的论战，当然敢于置疑Java的Bruce也是难免一战的。\n关于技术的选择，我在之前的一篇blog中给出了我的标准，很简单，就是舒服。\nTheServerSide的评论\nhttp://www.theserverside.com/news/thread.tss?thread_id=37121\nIT Observer的评论\nhttp://www.ebcvg.com/press.php?id=1761\nBeyond Java书籍介绍\nhttp://www.oreilly.com/catalog/beyondjava/index.html"
  },
  {
    "timestamp": "200510172301",
    "date": "2005-10-17",
    "time": "23:01",
    "title": "拓展影响力",
    "tags": [

    ],
    "body": "Tag: 脚下的路\n\n各种各样的原因，让我近来的心情有些灰色。一路顺风可以让人飘飘然，而身处人生低谷则让人有了冷静思考的机会，正所谓“生于忧患，死于安乐”。这种情况下，更能凸现良师益友的价值。与Darwin就自己遇到的问题聊了很长时间，期间我思考了许多，给我触动最大的一点在于影响力。\n我从未怀疑过自己的能力：念书时，学习成绩和竞赛证书在踏入社会之前给了相当的自信；工作期间，优秀员工和Java大赛的冠军也算是一些硬指标。但是，我在工作这几年的进步并不能令我满意，最直接的表现就是物质方面进步与我的预期相去甚远。与朋友戏言，钱对我来说，只是一个数字，与那些富豪持有这种态度是因为多得算不过来不同，我是少得不值得一算。有朋友对我说，以公司的标准来论，你已经算是不错的了，只可惜，我的眼睛更多的看得是比我强的人们。也许对有些人来说，这种心态并不是很好，因为它会减少生活的快乐，但它也给了我不断进步的动力。\n实际上，排除一些乱七八糟的因素，银子的多少反映出了一个人在老板心目中的地位，而这间接的体现了他在工作中的表现。这就是一个让我困惑了许久的问题，因为工作时，我总会尽力做好：把代码写得精致，把文档写得易读易懂……\n与Darwin的对聊终于解开了我的困惑：不仅要做好工作，还要让别人知道你做好了工作。\n以我的性格，让我去告诉领导自己做的工作有多么重要，是我所不愿意的，因为工作完成的好坏是应该由领导来发现，而非自己表现。但事实是，对于领导来说，交给你的工作算是一个黑盒，只要不出bug，很少有人愿意去看盒里的东西是个什么样子，因此，问题出得越少，其结果就是领导并不关心你工作完成得如何，如果你不自己打开这个黑盒，那我们辛辛苦苦做出的努力与别人的工作并无丝毫的差异，这就是面向接口设计的特点。\n我并不能说完全没有打开自己的黑盒子，只是做得还远远不够，也许，如果不是在公司Java大赛中的表现，原有部门领导都不会知道我在那个项目中打造的框架里面蕴涵了多少的思考，只可惜，那是我的谢幕演出。\n穷则独善其身，达则兼济天下。我对这句话的理解是，能力不足的时候，努力提高自己，当能力达到一定程度之后，应该尝试着影响别人。这就是一种影响力。如果不用自己的影响力影响别人的话，别人又怎能了解你的价值呢？一个人的影响力越大，所能表现出来的价值也就越大。如果Linus只是在寝室中自己把玩Linux，恐怕也不会有今日的成就了。\n其实，每个人都对周围的人存在一定的影响，不同的是有些时候，那是一种潜移默化。主动是一种催化剂，只有主动才能让它更好的释放，让自己的价值得到尽快的体现。只要不断的挣钱，从理论上推断，每个人都有成为亿万富豪的可能，只不过，有些人通过自己的努力让这个梦想在有生之年成为了现实而已。\n影响别人远非一朝一夕的工作，也少有一路坦途，甚至可能是荆棘遍布。如果受到了一些挫折，便像刺猬一样蜷缩起来，恐怕自己的影响力永远无法释放出来。Darwin给我讲了他初到新公司的故事，起初，他经常告诉别人架构的重要性，但因为那里的人们从来没有用这种方式思考过问题，习惯使他们毫不犹豫的选择拒绝。那段时间里，Darwin的心情是灰色的。但他并没有放弃，经过几次在这个问题上的精彩表现，Darwin终于让大家知道架构的重要性，那些曾经拒绝他的人，现在也纷纷站到了他这边，老板也开始考虑给他加薪，现在的Darwin心情不再灰暗。\n我写过一篇blog，名为《酒香也怕巷子深》，这个标题基本上可以把这篇的内容涵盖其中，只是当时我尚未意识到而已。"
  },
  {
    "timestamp": "200510112207",
    "date": "2005-10-11",
    "time": "22:07",
    "title": "疲惫不堪",
    "tags": [

    ],
    "body": "Tag: 脚下的路\n\n连续几个月，工作的压力让我一直处于一种忙碌的状态之中，不断的加班已经成了生活中的常态，每天晚上加上周六，休息成了一种奢望。这种压力的最直接表现就是自己blog产量大幅度降低，一来每天加班到很晚，疲惫使得我没有太多心力去写写东西，再者，工作也压缩了思考的时间，没有静下心的思考，便也少了许多信口开河的话题。还有就是这几个月里，我过得一直非常不顺，接二连三不如人意的事情发生让我有了一种心力交瘁的感觉。写得少了，想得也少了，于是我感觉这段时间里，整个人的进步幅度非常小，小到几乎可以忽略。精神上的疲惫也让我头一次感觉到了加班的痛苦，我不小心进入了一个我不期望看到的恶性循环。\n我也曾几乎每天晚上到公司，写程序，写文章，不同的是，那是一种主动行为。我也曾有过加班的疯狂，为了让系统正常上线，连续N天疯狂编码完成了一个系统的主要部分，但之后便是一段正常的生活。对我来说，这样连续几个月的加班是第一次。\n连续的加班让我的身心疲惫不堪，工作效率大幅度降低，常常是人在曹营心在汉，很长时间不能进入到工作状态之中，任何与工作无关的事情都可以轻而易举把我注意力吸引到一旁。事实上，不仅仅我如此，整个团队大多处于这种状态之中，大家都已经厌倦了加班，但因为高悬在头上的指标让我们不得不加班，这样，最后即便没有功劳，总还有些苦劳。虽然我很不情愿成为反例，却绝不是不是特例。我知道公司内有一个以加班闻名的项目组，我一个朋友从入司到离职的两年时间里，没有过上一个完整的长假，无论何种情况下，他们的领导都会选择加班，即便没有什么可做，即便人只是傻傻的坐在那。从其它同事的反映来看，这种情况现在仍在继续。从常理来看，如此忙碌，他们一定是大把捞银子，这个我不太清楚，只知道去年年底公司总结的时候，别的部门领导都在大谈自己部门创造了多少价值，而他们的领导则在为部门继往开来。\n物理学中有一个公式，功=时间×功率。许多管理者一厢情愿的认为人们在任何情况下，功率都是一个恒定的值，于是选择加大时间，以期赢得更大的功。但人不同于机器，人有着七情六欲。加大时间短时间内是可以提高总功的，事实证明，不顾一切的加大时间却会导致功率的下降，而且下降幅度会随着时间的持续而增大，直到功率下降到零，所有时间都成为了浪费之源。\n我现在开始逐渐的认识到，为什么许多敏捷方法中反对经年累月的加班。这种加班实际上是一种对团队的伤害，而且是一种长期的伤害，毕竟伤害容易恢复难。这种状态将会在相当长的一段时间之内持续，结果可想而知。如果能够恢复，那还是一种幸福，“永久形变”才是真正的灾难。\n欲速则不达。"
  },
  {
    "timestamp": "200405281352",
    "date": "2004-05-28",
    "time": "13:52",
    "tags": [
      "向上走"
    ],
    "title": "恶斗EJB（五）",
    "body": "<p>从SUN工程师的回复中，我得到了另外一个有用的信息，在SUN ONE Application Server的安装目录下的samples\\rmi-iiop\\simple有一个完整的普通应用调用EJB的例子。<br>赶紧操练起来，按照文档一步一步走来，很是轻松愉悦，除了EJB Stub，还要用到应用服务器安装目录的lib目录下appserv-ext.jar。<br>走到“Local or remote RMI/IIOP-based client without ACC（Application Client Container）”的一节，同样的问题出现了，程序运行起来就僵死在那里，没有反应。<br>怎么又是这样？在我确定了我确实是按照文档一步一步走下来的，我有了一种束手无策的感觉。<br>穷极无聊之际，我扫了一眼Troubleshooting：<br>如果运行应用出现了任何问题，看一下server的日志。<br>嗯？是啊！我光顾着client端了，竟然根本没有想过server端。打开server的日志，一个异常让我眼前一亮：<br>com.iplanet.ias.cis.connection.ConnectException: com.iplanet.ias.cis.channel.tcp.TCPNativeException: -5973:EndPoint.JNI_getValidAddressNative: PR_GetHostByAddr() Failed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.Connection.&lt;init&gt;(Connection.java:205)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.ServerConnection.accept(ServerConnection.java:251)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.sun.corba.ee.internal.iiop.ListenerThread.run(ListenerThread.java:77)<br>Caused by: com.iplanet.ias.cis.channel.tcp.TCPNativeException: -5973:EndPoint.JNI_getValidAddressNative: PR_GetHostByAddr() Failed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.EndPoint.getValidAddressNative(NativeMethod)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.EndPoint.getValidAddress(EndPoint.java:239)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.EndPoint.&lt;init&gt;(EndPoint.java:101)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.EndPoint.getEndPoint(EndPoint.java:73)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.EndPoint.getEndPoint(EndPoint.java:78)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.channel.tcp.TCPChannel.getPeerEndPoint(TCPChannel.java:74)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.iplanet.ias.cis.connection.Connection.&lt;init&gt;(Connection.java:201)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... 2 more<br>虽然单凭这个异常，我无法得知问题所在，但这比漫无目的的搜寻显然好上许多。</p>\n<p>再次向SUN工程师请教。很快，我得到了回复。显然，这个问题对于SUN的工程师来说已经是轻车熟路了。<br>RMI通信的时候，需要主机地址解析，只要在两台机器互相把主机名和IP放到hosts配置文件中就可以了。<br>在WinXP上，这个文件是C:\\WINDOWS\\system32\\drivers\\etc的目录下hosts，在Solaris上，这个文件是/etc/hosts。<br>在文件中加入IP和主机名的映射<br>&nbsp;&nbsp;&nbsp; xxx.xxx.xxx.xxx hostname</p>\n<p>运行，bingo，成功！<br>SUN工程师的答案果然见效。只是我想不通，我用的是IP直连，这和主机名有什么关系。显然，这让人不爽，因为将来部署的时候，这肯定需要写在安装手册里，增加复杂度，牵扯得不仅仅是应用本身的部署了。</p>\n<p>再来试试自己的例子。显然我前面的思路多少有些偏差，没有加入EJB Stub确实是个问题，但并不是根本原因，地址解析才是我的代码僵死的元凶。<br>好了，加入EJB Stub和appserv-ext.jar，运行，我终于见到了期盼已久的问候。<br>在这个调用中，我并没有使用ORB的那两个参数，这大概也算是J2EE RI和SUN ONE Application Server的差异之一吧！不过后来的事实证明，这并非一个不可逾越的鸿沟。<br>原来的异常出现在server端，client端为什么也要加呢？于是，我去掉了client端IP和主机名的映射，使用IP调用没问题，使用主机名调用的时候，抛出了个无法连接ORB的异常。没问题，和我预想的一样。</p>\n<p>再接再厉，尝试在Servlet中调用。<br>因为Servlet最终要运行在应用服务器上，所以我省去了appserv-ext.jar，只加入了EJB Stub。写程序，</p>\n<p>配参数，部署……<br>又出问题了，它怎么提示我&lt;ejb-link&gt;的参数不对。这是一个用来在Servlet中指示欲使用的EJB名称的参数。难道它让我把EJB应用也加进去，那还是一个单纯的Web应用了吗？<br>瞎猫总能碰到死耗子。当我糊涂的把EJB Stub作为一个Module加入到Web应用中，居然部署成功了。<br>敲入URL，又是半天没响应，这次可有经验了，赶紧把那台机器的IP和主机名加到部署EJB的服务器上。<br>OK，成功！</p>\n<p>终于搞定了在SUN ONE Application Server上远程调用EJB的问题，最初设置的一个参数又引起了我的兴趣。前面的设置有这样一句：<br>&nbsp;&nbsp;&nbsp; env.put(\"java.naming.factory.initial\", \"com.sun.jndi.cosnaming.CNCtxFactory\"); <br>这个com.sun.jndi.cosnaming.CNCtxFactory并不是J2EE包特有的，而是存在于rt.jar中，换句话说，它是J2SE中的。那它是否可以用在J2EE RI上呢？<br>带着这个问题，我翻出之前的那个例子，改动了参数，去掉ORB的那两个参数。<br>运行，Hello来了。<br>原来可以这么调。早知如此，何必当初呢！</p>\n<p>总结一下，算是个经验和教训的集合吧！<br>J2EE RI和SUN ONE Application Server通用的调用远程EJB的参数是：<br>&nbsp;&nbsp;&nbsp; java.naming.factory.initial＝com.sun.jndi.cosnaming.CNCtxFactory<br>&nbsp;&nbsp;&nbsp; java.naming.provider.url＝iiop://host:port</p>\n<p>如果使用的是SUN ONE Application Server，调用远程EJB需要在部署EJB的机器上hosts配置文件中加入调用端IP和主机名的映射。<br>如果调用端在IIOP参数中使用的是主机名，则需要在其hosts配置文件中加入部署EJB的机器的IP和主机名的映射。<br>在WinXP上，hosts配置文件是C:\\WINDOWS\\system32\\drivers\\etc的目录下hosts；在Solaris上，这个文件是/etc/hosts。<br>在文件中加入IP和主机名映射的方式是<br>&nbsp;&nbsp;&nbsp; xxx.xxx.xxx.xxx hostname</p>\n<p>又是一场恶斗，虽然精疲力竭，却也心情愉悦！战斗后的胜利感觉，总是最美妙的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405281345",
    "date": "2004-05-28",
    "time": "13:45",
    "tags": [
      "向上走"
    ],
    "title": "恶斗EJB（四）",
    "body": "<p>我最不愿意见到的事情发生了，这场恶斗有了续集。</p>\n<p>我们的应用实际运行在SUN ONE Application Server上。原本以为在J2EE RI上搞定一切的我可以顺利地把这些东西过渡到我的目标平台。没想到，等待我的却是另一场恶斗。<br>哎，Java的可移植性啊！</p>\n<p>开始阶段异乎寻常的顺利。<br>虽然SUN ONE Studio是个让人不敢恭维的IDE，但与SUN ONE Application Server配合起来，还是比较愉快的。在向导的帮助下，我很快就建起了一个新的HelloWorld EJB，把它加入一个EJB Module，部署，OK。<br>几个必要的参数也很快的从文档中被我搜了出来，于是几个参数设成了这样：<br>&nbsp;&nbsp;&nbsp; env.put(\"java.naming.factory.initial\", \"com.sun.jndi.cosnaming.CNCtxFactory\"); <br>&nbsp;&nbsp;&nbsp; env.put(\"java.naming.provider.url\", \"iiop://xxx.xxx.xxx.xxx:port\");<br>lookup方法中，我使用了JNDI名称，而舍弃了那个需要繁琐设置的引用名称。<br>眼前的一切似乎预示着，我只要点一下run，任务就算完成了。</p>\n<p>当我点下run的时候，不可思议的一幕发生了，程序僵死在那里，一动不动。<br>我不敢相信这一切，赶紧用出最原始的招数：加打印信息。打印信息给我的答案是，程序运行到下面这句后停住不动了。<br>&nbsp;&nbsp;&nbsp; Context initial = new InitialContext(env);</p>\n<p>冷静，冷静，问题出在哪了呢？<br>率先闯进来的失误是我没有创建一个EJB Stub。解决问题总是比发现问题来得容易，当我在EJB上点下右键的时候，我傻眼了，根本就没有创建EJB Stub的选项。挺住，再看EJB Module，还是没有，怎么会这样？<br>于是，我开始了新一轮的搜索，使用SUN ONE Studio创建EJB Stub。与此同时，我通过公司的同事向SUN的工程师请教。<br>SUN网站上的一个例子拯救了我，那也是一个使用SUN ONE Studio创建普通应用调用EJB的例子。<br>它创建EJB Stub的方法是创建一个应用，把EJB Module加入其中。右键点击这个应用，菜单上会出现“Export Client Support”的选项。<br>我要的只是一个EJB，为什么非得加入应用？况且EJB Module是可以单独部署的。<br>人在屋檐下，不得不低头。照猫画虎，当我点击这个选项的时候，蹦出一个对话框“Cannot export client stubs jar for an application this is not deployed”。<br>这又是什么道理，非得让我必须部署才行。<br>SUN论坛中的一个帖子给了我这样的答案，部署的时候，SUN ONE Studio会在本地创建一个临时目录，里面存放着部署的东西，也就是我们常说的EAR文件，创建EJB Stub实际上就是到那里找到这个EAR文件，根据它进行创建。我通过实验证明，只要在把应用服务器上部署了这个应用，即便把临时目录下的东西都删了，它还是会去创建一个临时目录存放这个EAR文件，然后再创建EJB Stub。<br>不管怎样，EJB Stub创建出来了。<br>这时，SUN工程师的应答也来了。我又得到了两种得到EJB Stub的方法。<br>当EAR文件部署到应用服务器上之后，这个应用的目录下就会产生一个Stub的文件，可以把它拿过来。另外在SUN ONE Studio中，右键点击EJB的时候，会有一个“Create New EJB Test Application...”的选项，通过它绕个弯子，也可以得到EJB Stub。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405251543",
    "date": "2004-05-25",
    "time": "15:43",
    "tags": [
      "向上走"
    ],
    "title": "恶斗EJB（三）",
    "body": "<p>一切都结束了吗？别急，刚到再接再厉的好时候，难道你不觉得有了IP，再有个端口就更好了吗？遗憾的是，文档没有给我们答案。<br>以前面的结果为契机，我们继续向前。<br>端口常与IP齐舞，那我们就从“org.omg.CORBA.ORBInitialHost”出发。既然它能起作用，显然代码里应该有这个字符串，搜！<br>不出所料，在它身边，“org.omg.CORBA.ORBInitialPort”出现了。<br>在代码中再加一段：<br>&nbsp;&nbsp;&nbsp; System.setProperty(\"org.omg.CORBA.ORBInitialPort\", \"1050\");<br>如果测试的话，使用1050和没使用几乎没什么区别，因为它是缺省端口。改一下容易，但也要同时改了server的端口，才能验证我们的想法。<br>有了前面的探索，找到server的配置简单许多。最终我将目标锁定在config/orb.properties上。一个port和一个host。改动port，重新启动server，从打印出来的信息，我确信自己的改动是成功的。<br>client，跑！OK！</p>\n<p>port我们已经知道了用途，但那个host呢？难道启动还能绑到别人的IP不成。强烈的好奇心让我暂时偏移了原来的轨道，改动IP，没什么，它依然能够启动，关了吧！<br>发现问题了！<br>关掉的不是这台机器的server，而是由host指定的那台机器上的server，原来它是干这个的。</p>\n<p>回到原来的路上。<br>这里已经有了IP和端口，在Context.PROVIDER_URL中指定的URL也涉及到IP和端口，意义何在呢？<br>删了它，试一下。代码居然仍然运行良好。</p>\n<p>再来看一下HelloWorldAppClient.jar，把它加入classpath之后，我们几乎忘了它的存在。<br>在J2EE Tutorial中，HelloWorldClient也被打到了这个JAR文件中，我们自己编写就是一个client，那么这个client有作用是什么呢？事实证明，它是标准的托，没用，删了它对大局无碍。<br>现在看看HelloWorldAppClient.jar，只有与EJB紧密关联的类，清净不少啊！</p>\n<p>还有什么问题呢？<br>还记得我们在开始的时候，将引用名称改成了JNDI名称吧！<br>我想把它改回来。<br>同样以异常起步，寻着调用逆流而上，一步一步解决出现的问题。<br>对比直接用runclient运行，很容易就可以找到二者的差异，大踏步向前。<br>runclient其实只是一个批处理文件，其中我最核心的一句简化一下就是下面这个样子：<br>%JAVA_COMMAND% com.sun.enterprise.appclient.Main %*<br>%JAVA_COMMAND%就相当于我们常用的java命令，那实际上这一句就是运行com.sun.enterprise.appclient.Main。<br>同直接运行相比，二者之间的差别肯定是runclient在前期设置了一些东西，才使得代码最终可以运行良好，所以，直接调用就需要自己完成这一些设置的工作。</p>\n<p>当我在代码中加入一些新的代码后，我决定放弃。<br>并非问题无法解决，而是从差别中查找出来的一些设置方法同J2EE RI中的一些类紧密关联在一起。如果说前面设置属性的方式是我可以接受的，那么这里就完全破坏代码中的那种美感。这样，即便最终可以完成，那也已经失去应有的意义。</p>\n<p>想来，我最初“调用远程EJB”的目的已经达到了，而在我将来的代码会运行在应用服务器上，这些设置工作应用服务器可以替我很好的完成，我也就不必理会了。</p>\n<p>最后，我要告诫一下对有兴趣尝试一下的朋友，前面所有的代码都是在J2EE RI上完成的，具体的应用服务器之间还是有差别的。<br>好了，一场恶斗就此结束。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405251538",
    "date": "2004-05-25",
    "time": "15:38",
    "tags": [
      "向上走"
    ],
    "title": "恶斗EJB（二）",
    "body": "<p>我们的最终目的是在不同的机器上调用EJB，下面就该体验分布式了。<br>在另外一台机器上，架起一个Server，把EJB部署上去，然后改动client代码中的IP，准备，跑！<br>成功了吗？<br>我期望的是失败。<br>如果你看见了来自远程的问候，先别兴奋，看看运行client的机器上是否还跑着一个J2EE RI呢？<br>我调的是远程的EJB，和我本机起的server有什么关系呢？先别管这些，关了它。<br>恭喜你，代码终于正常的失败了。</p>\n<p>谁愿意面对失败呢？出现了问题，我们要做就是解决它。<br>异常的提示是个不错的起点。<br>&nbsp;&nbsp;&nbsp; javax.naming.CommunicationException: Can't find SerialContextProvider<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.sun.enterprise.naming.SerialContext.getProvider(SerialContext.java:63)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.sun.enterprise.naming.SerialContext.lookup(SerialContext.java:120)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at javax.naming.InitialContext.lookup(Unknown Source)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>显然，这不是很好的提示，因为我们无法通过异常信息获得更多，但我们知道了出现错误的类。<br>幸运的是，SUN的J2EE RI源代码是公开的，这样我就省去了反编译class文件的麻烦。<br>打开com.sun.enterprise.naming.SerialContext这个类，找到getProvider，其中的一个debug变量引起了我的兴趣，这是一个调试的标志，只要把它置为true，一些调试信息就会流出来。<br>我肯定了自己的想法，改变debug，但如何来编译源代码呢？<br>我并不想费尽心力去编译J2EE RI庞大的源码，毕竟我需要的只是改变其中的一个类，而不是研究整个J2EE RI。</p>\n<p>挥出自己常用法宝，在自己的IDE中建立，建立起一个工程之后，直接把包含目标类的JAR文件（可能还有一些比较的JAR文件）加入工程，这样编译这个类所需的全部内容就都有了。<br>取过我的目标类，按照包结构放入工程之中，这样代码应该就可以正常编译了。<br>将改动后的class文件再塞进JAR，这样我的改动就开始发挥作用了。</p>\n<p>通过改动，我们可以多一些信息。<br>&nbsp;&nbsp;&nbsp; org.omg.CORBA.COMM_FAILURE:&nbsp;&nbsp; vmcid: SUN&nbsp; minor code: 201&nbsp; completed: No<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.sun.corba.ee.internal.iiop.ConnectionTable.getConnection(ConnectionTable.java:176)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.sun.corba.ee.internal.iiop.ConnectionTable.getConnection(ConnectionTable.java:68)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at com.sun.corba.ee.internal.iiop.GIOPImpl.getConnection(GIOPImpl.java:70)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<br>CORBA错误？是的，CORBA。这就不太好办了，虽然听说过EJB和CORBA之间千丝万缕的联系，但是我可是标准的CORBA门外汉。<br>在下定决心不去从头学习CORBA之后，我决定继续用前面的手法挖掘问题的原因。</p>\n<p>逆流而上的结果是我发现了这样的信息。<br>&nbsp;&nbsp;&nbsp; com.sun.corba.ee.internal.iiop.GIOPImpl(Thread[main,5,main]): getEndpoint(IIOP_CLEAR_TEXT, 0, null)<br>&nbsp;&nbsp;&nbsp; com.sun.corba.ee.internal.iiop.GIOPImpl(Thread[main,5,main]): createListener( socketType = IIOP_CLEAR_TEXT port = 0 )<br>&nbsp;&nbsp;&nbsp; com.sun.corba.ee.internal.iiop.ConnectionTable(Thread[main,5,main]): Client get called: host = localhost port = 1050<br>&nbsp;&nbsp;&nbsp; com.sun.corba.ee.internal.iiop.ConnectionTable(Thread[main,5,main]): Exception java.lang.RuntimeException: Connection refused: connect while creating socket for new connection: aborting connection<br>&nbsp;&nbsp;&nbsp; com.sun.corba.ee.internal.iiop.ConnectionTable(Thread[main,5,main]): DeleteConn called: host = localhost port = 1050<br>&nbsp;&nbsp;&nbsp; com.sun.corba.ee.internal.iiop.ConnectionTable(Thread[main,5,main]): Client get called: host = localhost port = 1050<br>很奇怪吧！这里出现了localhost。从直觉来说，我们明明在代码中写了调用远程的EJB，应该根本没有localhost什么事。事实就是这样奇怪，调用的时候居然先走localhost，这也就是为什么如果本机起的一个J2EE RI，我们就可以看到来自远方的问候。<br>就在我疑惑不知该如何走下一步时，无意之举给了我新的方向。<br>我翻起了J2EE RI配套的文档。没错，之前我一直在自行探索。<br>在J2EE SDK Tools的文档中，runclient的讲解中有一个小节，其标题是《Accessing a Remote Server》，显然这对我是个极大的触动。<br>其中提到了一个属性“org.omg.CORBA.ORBInitialHost”。<br>设置这个属性就可以访问远程EJB？？？<br>还等什么？<br>我们知道在Java运行时以-D定义一个属性同直接在代码中使用System.setProperty具有相同的功效，于是代码中出现了这样一段：<br>System.setProperty(\"org.omg.CORBA.ORBInitialHost\", \"xxx.xxx.xxx.xxx\");<br>运行，祈祷！<br>来自远方的问候终于出现在我的面前，那种激动相信是程序员无数次经历却依然愿意体味的感觉。我愿意把这种感觉与吸毒等同起来，完全是一种瘾，这是这种瘾让我愿意迎接一次又一次的挑战，克服一个又一个的困难。</p>\n<p>“众里寻她千百度，蓦然回首，那人却在灯火阑珊处”<br>应该说我的习惯并不好，在我自己绞尽脑汁独自摸索时，在我挥动google四处搜寻时，我居然没有想过自己的身边已经有了最好的答案。<br>以此为戒，以后解决问题时，先要了解配套文档中有哪些内容。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405251528",
    "date": "2004-05-25",
    "time": "15:28",
    "tags": [
      "向上走"
    ],
    "title": "恶斗EJB（一）",
    "body": "<p>虽然近来EJB 3.0已经吵得沸沸扬扬，但作为EJB 3.0根基的JDK 1.5还不知道什么时候正式发布，享受EJB 3.0带来的便利指不定是在什么时候，眼下我们拥有的还只是麻烦的EJB 2.0。</p>\n<p>终于找到了一个使用EJB稍微合适一些的理由。系统要支持多机，其中最难解决的数据共享，于是我想到了EJB，也开始了与EJB艰苦的战斗。</p>\n<p>按照J2EE Tutorial在J2EE RI上跑通一个Hello级的EJB并不是什么难事。<br>下面是我的Hello EJB的客户端代码：<br>&nbsp;&nbsp;&nbsp; Context initial = new InitialContext();<br>&nbsp;&nbsp;&nbsp; Context myEnv = (Context)initial.lookup(\"java:comp/env\");<br>&nbsp;&nbsp;&nbsp; Object objref = myEnv.lookup(\"ejb/HelloWorld\");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; HelloWorldHome home = (HelloWorldHome)PortableRemoteObject.narrow(objref, HelloWorldHome.class);<br>&nbsp;&nbsp;&nbsp; HelloWorld helloEJB = home.create();<br>&nbsp;&nbsp;&nbsp; System.out.println(helloEJB.hello(\"dreamhead\"));</p>\n<p>Hello的实现非常简单：<br>&nbsp;&nbsp;&nbsp; public String hello(String name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return \"Hello, \" + name;<br>&nbsp;&nbsp;&nbsp; }</p>\n<p>照本宣科，把J2EE RI启动起来，运行客户端代码：<br>&nbsp;&nbsp;&nbsp; set APPCPATH=HelloWorldAppClient.jar<br>&nbsp;&nbsp;&nbsp; runclient -client HelloWorldApp.ear -name HelloWorldClient -textauth</p>\n<p>bingo！成功。</p>\n<p>这当然不是故事的结局，否则太对不起“恶斗”的题目了。<br>我们最习惯的运行Java程序的方式是<br>&nbsp;&nbsp;&nbsp; java classname<br>而这里运行代码用得居然是runclient，J2EE RI自带的一个工具，显然这并不符合我们的日常行为规范。<br>我的目标，直接用java运行EJB客户端。</p>\n<p>直接运行HelloWorldClient显然不行，如果你不信邪，可以自己尝尝失败的滋味。</p>\n<p>一些资料给了我些许提示，设置一些必要的属性会帮助也许可以帮助我完成任务。于是在代码中加上了这样几句：<br>&nbsp;&nbsp;&nbsp; Properties env = new Properties();<br>&nbsp;&nbsp;&nbsp; env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.enterprise.naming.SerialInitContextFactory\");<br>&nbsp;&nbsp;&nbsp; env.put(Context.PROVIDER_URL, \"iiop://xxx.xxx.xxx.xxx:1050\");<br>这里关注的主要是Context.INITIAL_CONTEXT_FACTORY和Context.PROVIDER_URL，它们其实是两个字符串，分别代表着“java.naming.factory.initial”和“java.naming.provider.url”，在一些资料里，它们往往素面示人。<br>上面代码中给出的是针对J2EE RI的设置，不同的应用服务器设置是不同的，如果想在自己的应用服务器上使用类似的代码，先要找到自己的应用服务器上这两个参数是什么。因为关于J2EE RI的资料太少，就这两个参数，也害我花了好长时间。<br>好容易找到的参数，写了一堆代码，可别忘了让它起作用啊！<br>&nbsp;&nbsp;&nbsp; Context initial = new InitialContext(env);</p>\n<p>还有一个要改动的地方，那就是JNDI的名称。<br>跟着J2EE Tutorial一路走来，我们很少在意代码中用以查找的那个“java:comp/env/ejb/HelloWorld”根本不是JNDI的名称，而只是一个引用名称。直接运行代码，给出的只是一个个错误提示。把它改回JNDI名称，问题迎刃而解。<br>&nbsp;&nbsp;&nbsp; Object objref = initial.lookup(\"MyHelloWorld\");</p>\n<p>J2EE的东西可不是随处可见的，所以，要自己运行的话，把J2EE RI的lib目录下的j2ee.jar拿过来会省去不少麻烦。另外，使用这个东西运行时可能会用到一些属性文件，我采用最直接的方式，将config目录下的东西直接搬了过来。</p>\n<p>代码可以编译了，别急着运行。想必听过EJB种种传闻的你一定知道Stub之类的东西，少了这个，代码绝对跑不起来，所以我们要把HelloWorldAppClient.jar加入到classpath中，传说中的Stub就在其中。</p>\n<p>我想许多人和我一样，跑这种例子会把server和client放在同一台机器上，上面的IP设置的是localhost或是本机IP。这样我们就可以幸福的通过第一关，看到EJB亲切的问候。</p>\n<p>万里长征终于走出第一步！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405190947",
    "date": "2004-05-19",
    "time": "09:47",
    "tags": [
      "向上走"
    ],
    "title": "小心翼翼跨平台",
    "body": "<p>Java的宣传广告中清清楚楚的写着“跨平台”几个大字，可Java程序写出来真的就能横行于各大平台之间吗？我们的开发平台是Windows，而最终的程序将运行在Solaris上，于是我有机会体会平台的差异。</p>\n<p>先来看看今天的问题。<br>只要是你写的东西，指不定它会在哪天蹦出来恶心你。记不清哪位高人曾经说过大意如此的话，今天我算是体会到了。一个扔了大半年的程序突然就要用，在Windows下全部功能一直都跑得好好的，而且在Solaris上基本功能也一切正常，今天用到了一个从未在Solaris跑过的功能，结果……挂了！</p>\n<p>在手头没有源代码的情况下，我只能反编译，幸好当时没有混淆，庆幸！<br>经过分析，问题出在了这里：<br>&nbsp;&nbsp;&nbsp; private static final String CONFIG_FILE = \"conf\\\\config.xml\";&nbsp;&nbsp;&nbsp; <br>它的目的是从工作路径中conf目录下的configx.xml，这在Windows下一切正常，而在Solaris下，它就玩不转了，因为“\\”不是Solaris下的目录分隔符。<br>找到问题解决就容易多了，把文件名改成下面这样就OK了。<br>&nbsp;&nbsp;&nbsp; private static final String CONFIG_FILE = \"conf\" + File.separator + \"config.xml\";</p>\n<p>这个问题让我想起了前不久遭遇同样因为平台差异造成的问题。<br>写了一段在包内查找文件的程序，其基本结构来自于Groller的PackageUtil。这段实际包的不同，这段查找分为查找目录和查找JAR文件两种情况。在查找JAR文件的代码中，有这样一段代码：<br>&nbsp;&nbsp;&nbsp; String path = url.getPath();<br>&nbsp;&nbsp;&nbsp; String jarFileName = path.substring(FILEPROTOCOLLEN,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path.lastIndexOf(\".jar!\") + JARTRINGLEN);<br>因为包内查找使用的是Class LoadergetResource方法，这里将会得到的是一系列的URL，比如像下面这样：<br>&nbsp;&nbsp;&nbsp; file:/C:/jarfile.jar!/packagename/<br>上面那段代码的目的是根据从这段URL中解析出jar文件的名字。</p>\n<p>在最初的版本中，两个常量的定义是<br>&nbsp;&nbsp;&nbsp; private static final int FILEPROTOCOLLEN = \"file:/\".length();<br>&nbsp;&nbsp;&nbsp; private static final int JARTRINGLEN = \".jar\".length();<br>由此得到的JAR文件名是<br>&nbsp;&nbsp;&nbsp; C:/jarfile.jar<br>在Widnwos下，这段代码运行的很好，但到了Solaris上，它就坚持不住了。因为在Solaris上，URL变成了这样：<br>&nbsp;&nbsp;&nbsp; file:/root/jarfile.jar!/packagename/<br>经过解析得到的JAR文件名成了<br>&nbsp;&nbsp;&nbsp; root/jarfile.jar<br>显然原本期望的是一个绝对路径，结果成了相对路径，差在哪呢？多去了一个“/”。<br>改动方法是修改FILEPROTOCOLLEN的定义：<br>&nbsp;&nbsp;&nbsp; private static final int FILEPROTOCOLLEN = \"file:\".length();<br>这样在Solaris上，JAR文件名就成了<br>&nbsp;&nbsp;&nbsp; /root/jarfile.jar<br>这样，它就可以在Solaris上顺利运行了。</p>\n<p>也许细心的你已经发现了，由此带来的Windows上JAR文件名成了：<br>&nbsp;&nbsp;&nbsp; /C:/jarfile.jar<br>一开始，我也担心这个问题，但瞎猫碰死耗子的结果是，这段代码在Windows上也能很好的运行，于是，我就当它不存在。</p>\n<p>《Code Reading》中提到两种对待代码的态度，大多数是“如果它能工作，那么它就是正确的”，而NetBSD的哲学却是“除非它正确，否则它无法工作”。看来，我属于大多数。^_^</p>\n<p>再往前，还有这样的故事。<br>一个同事向我求救，他的Tomcat起不来，我装了半天高手，结果很没面子，没搞定！最后的原因是这个哥们把Windows版的Tomcat放在Solaris上。按照我们通常的想法，以Java写成的Tomcat应该可以轻松放在Solaris上，但事实不是。</p>\n<p>号称跨平台的Java虽然比起它的一些前辈在可移植性上已经有上佳的表现，但并非100%的Java代码都能跨平台。虽然Java在可移植性做了很大的努力，比如第一个例子中File.separator，但这丝毫不妨碍我等无知小辈胡乱使用，加之第二个例子中少人注意的星星点点，如果跨平台的话，还真得多非点功夫。如果你和我一样，必须横跨多个平台，最好让代码在这几个平台上都跑跑。这里的平台可不只是操作系统，也可能应用服务器或是其它什么东西。如果代码压根就是绑死在某个平台，而且千秋万代也没有移植的可能，那你大可不必考虑可移植的问题，毕竟移植也需要时间和精力。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405170905",
    "date": "2004-05-17",
    "time": "09:05",
    "tags": [
      "脚下的路"
    ],
    "title": "初试啼声",
    "body": "<p>尽管早在一个月前闫辉就向我约了《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=513036\">技术的文字</a>》，尽管半个月前看到CSDN上新一期《程序员》的预告上出现了《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=513036\">技术的文字</a>》，直到把新一期《程序员》拿在手里，确确实实的看到《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=513036\">技术的文字</a>》，我才相信，原来我信口开的这条河居然可以流成铅字。</p>\n<p>《程序员》一向是我比较欣赏的一个杂志。早在囊中羞涩的穷学生时期，初创的《程序员》就吸引了我的眼球。当时忍着每月9.8元人民币昂贵价格，我坚持每期必买，这个习惯一直坚持到现在。从试刊至今的每一期《程序员》都未能逃出我的摩掌，就连合订本也未能幸免。虽然并不是每一篇文章我都能读懂，但在《程序员》着实给了我这只井底蛙一个开眼看世界的机会。</p>\n<p>在《程序员》上发表文章是我脑中曾经偶然闪过的念头。鉴于自己有限的学识和无力的文字，加之对于退稿的恐惧，我放弃了尝试的机会。<br>结果，无心插柳又一次上演。</p>\n<p>《技术的文字》是去年的一篇旧文。初写的目的原本是打算批判一下我自己买书不读的可耻行为，结果当天思维紊乱，莫名其妙的就写成那个样子。坚持着举手无悔的原则，我还是把它放了出来，只可惜对自己的批判糊里糊涂的流产了。</p>\n<p>Darwin对它的反应绝对出乎我的意料。他对我说，这篇blog改变了他看待技术文字的一些看法，准确之外加上可读确实远胜于干瘪的描述。这篇blog的另一个副产物是让Darwin认识到了blog的有趣，于是，他也开始了自己的blogger生涯。</p>\n<p>2003年诺贝尔文学奖得主库切曾经的一个身份就是程序员.虽然现在我并不打算做成为职业作家的春秋大梦，但我相信程序员和好文笔之间没有绝对的鸿沟。<br>如果像我这种小程序员都可以，那么无论实力还是文字都在我之上的你有什么不可以。套用赵本山在《卖拐》中的一句经典，“你跺你也麻”。<br>各位，出手吧！让坎坷的程序人生更加丰富多彩，给我们后进之辈一个像舒服的学习机会。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405131051",
    "date": "2004-05-13",
    "time": "10:51",
    "tags": [
      "我眼看世界"
    ],
    "title": "技术的风险",
    "body": "<p><a href=\"http://hhee.blogdriver.com/\">咖啡动力</a>上<a href=\"http://www.blogdriver.com/showBlog.do?diaryID=151792\">关于新技术</a>的话题给了我一个信口开河的话题。</p>\n<p>又有一项让令人心潮澎湃的技术在我们面前出现，具有极强\"职业敏感度\"的我们立刻着手操练起来。<br>当我们对这项技术有了广告之外的认识之后，最希望的当然就是把它应用在实际的项目之中。如果刚好具备影响一个项目的能力，恐怕那更是迫不及待。<br>当我们把自己的想法摆在项目组其它成员面前时，如果不出意外，总会有人站出来，告诫你风险的存在。</p>\n<p>风险？没错。毕竟我们的项目是公司用来赚钱的东西，公司赚不到钱，大家都没好日子过。你可以在私下里进行各种尝试，那与大家无关。但你要把这个东西引入到公司的项目中，让大家因为你的一时之快而冒喝西北风的风险，那是断然不可的。<br>风险这东西怎么说都是不过分的，《与熊共舞》能拿到Jolt大奖充分说明了全世界的软件开发者对于风险的重视。<br>一顶能压死任何人的大帽子扣了下来。</p>\n<p>我丝毫不否认新技术的引进等价于风险的引进。但不知道你考虑过这样一个问题没有，实际上，许多项目的失败并非因为技术：<br>我们开发了一个市场根本不需要的东西，仅仅因为领导认为市场可能会有需求。<br>混乱的开发使得这个产品距离原计划的推出时间晚了几个月，市场没了。<br>这个产品可是要买几百万的，但客户只给几十万，连成本都合不上。<br>我们辛辛苦苦的开发了几个月，项目就无声无息的停了，领导连个原因都不给。<br>真正因为技术的有多少呢？</p>\n<p>就现实情况来看，真正能够站在技术前沿，冒技术失败风险的程序员只能算是沧海一粟。大多数的程序员使用的技术都是前人们花费了无数精力探索的结果。即便是我们看来的新东西，多半也是别人的隔夜饭了，只是我们不了解而已。基于程序员们的学习能力，在不太长的时间内掌握一项不是非常复杂的技术应该不是什么难事。</p>\n<p>既然如此，为什么技术风险总在风险讨论中名列前茅呢？因为它比较容易想到。<br>人们对于容易想到的东西，往往有着异乎寻常的兴趣。《人件》中讲到老板们非常愿意通过节省空间而节省成本，因为这种方式可以确确实实的见到省下的MONEY。而深层次的探索需要时间和精力，而且不一定会有结果，总不如看得见，摸得着的东西来得实在。</p>\n<p>拒绝新技术，往往是许多人不愿意改变的借口。想必许多人都拜读过《谁动了我的奶酪》，但又有几人把愿意主动改变呢？任何新技术的学习都需要时间和精力，相比之下，吃老本是一件很惬意的事情。</p>\n<p>虽然不愿意见到新东西的出现，但实际情况是，几乎没有那个项目不用到我们之前没接触过的东西，无论是技术还是业务，总而言之，学习还是无可避免的。</p>\n<p>程序员们大概都知道实践的威力，一项新技术，自己学习和在项目中实际运用，感受绝对是天差地别。任何的新技术，如果不去实际使用，永远都是新技术。</p>\n<p>不过无可否认的一点是，新技术绝对是一种风险。<br>贸然使用新技术，确实会给项目带来很大的压力。仅仅因为看了广告，或是写了个“Hello,world”就决定在项目中应用绝对是不可取的。必要的评估是不可缺少的，新技术能带来怎样的变化，提高的生产力能否抵消风险的代价。通常一个人的眼光是有限的，把它介绍给项目组的其它成员，让头脑风暴协助你一起思考，虽然不同的声音会让人有不舒服的感觉，但这总比单枪匹马杀出重围让人放心得多。</p>\n<p>由此得出我的结论，不能不动，不要妄动。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405111600",
    "date": "2004-05-11",
    "time": "16:00",
    "tags": [
      "向下走"
    ],
    "title": "Make雕虫技",
    "body": "<p>在一个规模相对较大的项目中，常常许多目录中都有自己的Makefile，负责处理这个目录中的内容。<br>顶层Makefile中可以使用不同的方法调用子目录中的Makefile，下面是我所知道的两种:<br>1 进入子目录编译，比如:<br>&nbsp; cd kernel; make clean;<br>2 利用Makefile的特性，比如:<br>&nbsp; $(MAKE) clean -C kernel<br>Linux的makefile使用了后一种方法。</p>\n<p>随之而来的是一个有趣的问题。</p>\n<p>编写Makefile的时候，我们常常定义一些变量，比如：<br>CC&nbsp;= gcc</p>\n<p>基于程序员懒惰的特性，我们当然不想在多个地方定义这个变量，我们期望的效果是顶层定义，底层使用，也就是说，上面的定义只出现在顶层的文件中，至于底层Makefile，我们只是简单$(CC)就可以使用了。</p>\n<p>虽然这是一个合理的要求，但如果你只把这个变量定义在顶层的Makefile中，就期望使用前面提到方式的执行子目录的makefile能够如你所愿，那你只有失望的份了。底层Makefile是无法看到顶层Makefile定义的变量，make没有提供这种支持。</p>\n<p>要解决这个问题，我知道的也是两种方法:<br><strong>包含文件</strong><br>同我们了解的C/C++一样，Makefile中也支持包含文件。只要把定义了变量的文件包含在Makefile中，Makefile就可以看到这个变量定义了。<br>听了这种说法，性子急的人直接就在底层的Makefile中把顶层的Makefile包含进来。请再给我个说话的机会，不要这么直接，好吗?<br>我们可以这样做，把变量定义同具体的编译内容分离开来，专门用一个文件存放变量定义，假设这个文件叫Make.rules，用这种方法，我们把原来定义在顶层Makefile中的变量分离了出来，而我们只要对这个Makefile稍做修改，加上一句<br>&nbsp; include Make.rules<br>对于底层需要这些变量的Makefile，只要按照目录结构包含Make.rules就可以顺利的工作了。<br>如果你问为什么不直接包含整个Makefile，那你一定算不上一个好程序员，好程序员怎么能容忍过分的暴露呢?<br>&nbsp; <br><strong>导出变量<br></strong>这种方式是在变量定义之后，将它导出来，对于上面CC定义，我们还要额外的写上<br>&nbsp; export CC<br>这样，采用前面提到过的方式处理子目录的时候，就可以使用这些变量了。<br>这是Linux的makefile使用的方式。<br>同包含文件相比，这种方式有一个缺陷，因为这些变量都是在make执行的过程中定义的，所以如果没有在顶层执行make，那么这些变量实际上是不存在的。换句话说，直接在某个子目录中执行make，很有可能的结果是因为变量没有定义而执行失败。<br>&nbsp; <br>其实，对于解释我们的问题来说，CC并不是一个很好的例子。<br>可能你会遇到这样的现象，底层的makefile中并不包含CC的定义，但它依然可能编译代码，我知道你已经准备置疑我前面的结论了。<br>但在置疑之前请仔细看一下，执行的是我们定义的gcc吗?<br>真正运行的是cc。</p>\n<p>为什么会这样?<br>原因很简单，因为make中有一批预定义的变量，其中就包括CC，它预定义的值就是cc。如果你在应用中定义的变量同预定义的变量具有相同的变量名，那么起作用的将是你定义的值。<br>用下面这个命令可以了解make有哪些预定义变量：<br>make -p</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200405082119",
    "date": "2004-05-08",
    "time": "21:19",
    "tags": [
      "脚下的路"
    ],
    "title": "痛心疾首",
    "body": "<p>长假出游。鉴于来回的路上，要在火车上熬三十几个小时，我准备从藏书中选一本作我的旅伴。最终和我一起踏上旅途的是Tom DeMarco和Timothy Lister的《人件》。<br>这本书进入我的书架已经是好久以前的事，但时至今日，我依然无缘拜读。这次正好趁着旅途无聊，消磨一下时间。就这样，抱着游戏一般的心态，我开始了自己的《人件》之旅。</p>\n<p>低期望换来了高回报。<br>从一开始，习惯在书上随意涂鸦的我，手中的笔就没有停下来过。两位大师精彩论述让我的敬仰之情一次又一次的升起，但更多感到的是一种痛——切切实实的心痛，从未有过的读书体验。</p>\n<p>书中提到的问题几乎无一例外发生在我的身边：把所有人等同起来；没有加班费的加班；低劣的工作质量；嘈杂的工作环境……</p>\n<p>有一段时间，我一直想不通，为什么公司做了那么多大项目怎么就是挣不到钱呢？现在想来，根本问题还是出在了人身上。<br>在这里，一直弥漫着“人人平等”的思想，正是自欺欺人的想法让领导们相信没有谁是不可替代的。于是，当一个在这干得相当不错的人离开的时候，领导至多会象征性的挽留一下，因为他们相信，马上招入一个新人就可以完全替代了他。这样，熟练工离开了，取而代之的往往是那些刚刚毕业的学生。<br>如果仅仅是熟练程度上的差异，恐怕这根本算不上什么损失，毕竟新人的干劲远胜于热情渐渐消散的老手。</p>\n<p>然而事实并非如此。<br>如果不是一个完全不思进取的程序员，经过几年的锻炼，他对于已经做过的项目存在那些缺陷，一定会有自己的想法。出于程序员自身的道德，他一定会在新的项目中避免犯同样的错误。这也是许多公司招聘时，喜欢招有工作经验的人的原因之一。<br>而新手往往会凭着初生牛犊不怕虎的冲劲把老手犯过的许多错误再犯一遍。对于新手的成长而言，这不是什么错误，但对于一个公司的发展来说，这却是致命的。</p>\n<p>在某种程度上，我很敬佩我们公司的高层领导，他们的眼光很独到，总能发现一些很有前途的市场，然后以先行者的身份进入市场狠捞一笔。一锤子买卖显然对公司的名声不利，而且领导们相信既然已经进入了这个市场日后的Money就会源源不断，于是他们选择固守。<br>前期的没有选择让一批客户上了贼船。<br>随着对产品了解的深入，客户纷纷开始有了自己的想法。为了不浪费先前的投资，很多客户选择了“需求变更”。<br>那些匆忙上阵的产品显然不是为了变更而存在的，于是一发而动全身的精彩大戏上演了。</p>\n<p>为什么会这样？<br>你相信一批刚毕业的新手和一批不思进取的老手能设计出好东西吗？<br>路绝对是要一步一步走的。虽然我觉得自己的水平不高，但现在回过头来看看之前的一些工作，往往会嗤之以鼻。<br>接下来的就是，在现场贪黑熬夜拼命改bug，然后，因此成为英雄的一幕幕精彩镜头了。</p>\n<p>听说有一个几十万的项目，近十个人在现场开发半年交工。除去这些人的工资、补助和住宾馆的费用，这个项目能赚到钱？如果是壮士断臂的壮举倒也值得称赞，但如果这成了日常习惯，恐怕任谁也笑不起来！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404292017",
    "date": "2004-04-29",
    "time": "20:17",
    "tags": [
      "向上走"
    ],
    "title": "规则思变",
    "body": "<p>今天写了一个小工具，因为有一批数据要导。如果我勤快，我会选择手工来做，不过是几个文件里里面几十张表的几千条数据嘛！不过，我是个懒惰的程序员。</p>\n<p>编写这个小工具的过程中，有一个有趣的小问题。<br>写完一段代码之后，产生数据是这个样子：<br>1234567=名称A1-B2<br>负责人对我说，我们只要前面的名称就成了。<br>在代码里，“名称A1-B2”存在了一个字符串中，于是我的工作变成了从这个字符串中删去后面“A1-B2”的部分。用伪码表示或许更清楚一些。<br>原来的是这样：<br>target=\"名称A1-B2\";<br>我要的是这样：<br>target=\"名称\";</p>\n<p>你想到了什么？<br>反正我第一个打消的念头是手工删除。实际的字符串肯定不只“A1-B2”，也许还有“C3-D4”、“E5-F6”，也可能是“G7”、“H8”，总之，要删除的部分是一个由ASCII码组成的字符串。所以，解决问题的关键是识别出要删除的字符串。</p>\n<p>识别出字符串，那么这个字符串必须满足一定条件，匹配？正则表达式？<br>没错，就是它。</p>\n<p>身处Java世界是幸福的，JDK 1.4中已经加入了对正则表达式的支持，只是……，我没有用过。<br>JDK的API不会用？没关系，<a href=\"http://javaalmanac.com/\">Java Almanac</a>是最好的答案，其中给出的例子让我可以很轻松的了解大部分JDK API的用法。它基本上已经成了我现学现卖的首选。</p>\n<p>定义一个用来匹配的Pattern，我们要匹配一个由ASCII字符组成的串，那就这么写：<br>Pattern pattern = Pattern.compile(\"(\\\\p{ASCII})+\");<br>关于模式的含义，JDK的文档中写得很清楚。再说，我又不打算立即开始系统学习，只找自己需要的应该是很容易的一件事。<br>在文档中，匹配ASCII字符的模式是“\\p{ASCII}”，因为在字符串里“\\”又特殊含义，所以得多来一笔。</p>\n<p>有了模式，我们就可以在一个字符串中查找匹配的串了。<br>Matcher matcher = pattern.matcher(source);</p>\n<p>找到问题以后解决就容易多了，接下来就删了它。<br>我选择了替换来完成这个需求，没错，替换！<br>我用\"\"替换了匹配出来的字符串，这和删除不是异曲同工吗？<br>matcher.replaceAll(\"\");</p>\n<p>大功告成！</p>\n<p>问题是解决了，兴奋之余，我想到正则表达式，想到了Perl。<br>Perl在文本处理上的强大，恐怕大家多少都有些耳闻，而正则表达式正是Perl强大实力的体现。年初的时候，信手翻了一些《Perl语言入门》，因为是兴之所致，没有具体的应用方向，所以没有很好的掌握。今天遇到的这个问题，如果以Perl来解决恐怕就不必劳烦Java的大驾，毕竟这不是Java的强项。<br>最近在看《The Pragmatic Programmer》，第三章就谈到了一个Text Manipulation的问题。可能许多程序员和我一样，习惯以编译语言解决问题，其实很多脚本语言也很强大，尤其在处理这种小问题的时候。</p>\n<p>我们写程序不就是为了解决问题吗？如果能够“多快好省”的解决，何乐不为？</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404282302",
    "date": "2004-04-28",
    "time": "23:02",
    "tags": [
      "脚下的路"
    ],
    "title": "为了忘却的纪念",
    "body": "<p>宿舍中又有两个人离开了。<br>虽然他们提出辞职已经有些日子，虽然大家吃散伙饭时还是嘻嘻哈哈。今天回到宿舍准备和这两位兄弟道声别离的时候，他们已经离开了。站在空空荡荡的房间里，我不禁有一丝惆怅。</p>\n<p>昨天晚上，愤青们聚在一起，开了最后一次“愤青会议”。<br>如果说刚到某个公司就对这个公司充满了失望，那一定怨不得公司，心甘情愿的让一个连表面功夫都做不好的公司给骗来，多半是精神不大好。<br>但如果一个个有志青年选择离开的原因都是因为心灰意冷，那一定是公司的问题了。<br>如果让员工产生一种“干多干少一个样，干与不干一个样”的大锅饭心理，谁还会愿意付出呢？</p>\n<p>更为幽默的是，干得不好也可以成为英雄。<br>一个负责人对手下的一个人说，你把这个做了，那人问，怎么做，负责人回答，你看着办吧！<br>于是，这个“看着办”的仁兄开始了自己的攻坚历程，由于水平太高，本来安排两周的进度，他短短三个月就做完了，给了其它模块开发人员以充分的休息时间。在此过程中，负责人给予了他充分的信任，省去了评审，省去了文档，结果是，做出来的东西包括他自己在内没有任何人完全了解。</p>\n<p>好戏就此开场。<br>由于他的模块在系统中的重要性和他创造bug的能力，他成了项目组中最繁忙的人，每天穿梭于开发大厅中，与每一个发现bug的人一同寻找他的经典之作。他繁忙的身影每天在领导眼前晃来晃去，于是领导得出结论，这是个好员工。为了鼓励先进，领导利用一次涨工资的机会大幅度提高了他的工资。</p>\n<p>下面就选取一个经典中的经典，供大家学习。<br>有一个表，系统运行时需要对它进行操作，这位仁兄选择的处理手法是把表中所有的内容一次加载到内存的一张Hash表中，可以肯定的是，每条数据也绝对不是一两个字节可以搞定的。经过这位仁兄的测试，这个模块发布了，结果是，真正到了现场跑起来，几乎总可以制造出OutOfMemory的经典错误。经过仔细研究，发现实际运行起来后，这张表里会有80万的数据，估计测试时，最多也就用了千八百的数据。问及这位仁兄，他的回答是，加内存。</p>\n<p>从需求开始，几乎步步精彩，结果更是让人叹为观止。<br>于是有得出结论，我们在这里得到了很多的教训。经验？没有。我们知道如何做不对，至于如何做是对的，不知道，因为我们从来就没有对过。</p>\n<p>现在我们彻底知道了“浪得虚名”的含义。这是一家对外宣称过了CMM 5的公司，而内部却是一个个小作坊的和。不过它并没有小作坊那种灵活，没有那种激情，因为它本身还是一个大公司，拥有着大公司通常具有的问题：等级森严，行动迟缓……</p>\n<p>这篇blog的题目是一个离开的兄弟给的，纪念他们的离开，纪念在这里一起度过的日子。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404272139",
    "date": "2004-04-27",
    "time": "21:39",
    "tags": [
      "我眼看世界"
    ],
    "title": "单元测试的习惯",
    "body": "<p>potian<a href=\"http://www.aspectoriented.org:9080//space/2004-04-26\">关于“单元测试”的话题</a>，一呼百应。没人会在乎再多我一个吧！</p>\n<p>在我看来，单元测试只是一个习惯。<br>如果谁胆敢站出来指责单元测试存在的必要性，恐怕只会遭来骂声无数。<br>那为什么还有人拒绝着单元测试呢？<br>习惯。</p>\n<p><strong>习惯中单元测试不是程序员的事<br></strong>念书时最令我犯困的就是《软件工程》，而单元测试就是《软件工程》讲的东西，所以，单元测试一定属于那帮有闲心的专家才去研究的东西，跟我关系不大。就这样，单元测试就轻松的被划在程序员的基本技能之外。再说了，我们这里有专门的测试人员，我把测试的活都干了，他们岂不失业了，社会要有分工，不是吗？</p>\n<p><strong>习惯中单元测试与XP联系在一起</strong><br>每每提及单元测试，听说过诸如“测试先行、测试驱动开发”之类名词的我们总是情不自禁的把它和XP划上一个等号。我们这里不兴这一套，约束我们的是CMM、ISO之类的东西，没有条件，你叫我如何XP？既然不可能XP了，单元测试也算了吧！</p>\n<p><strong>习惯中单元测试不正经<br></strong>单元测试在最终运行的代码中不起任何作用，一点CPU时间都不占，让我花费时间编写这些最终不用的代码，还是省省吧！再说了，项目这么紧，上面的领导成天催我，只编写功能代码我都不敢保证按时完成，叫我编写单元测试，没时间。程序员的优点之一，就是懒惰，所以，我更不会去编写单元测试了。</p>\n<p><strong>习惯中没有单元测试也很好<br></strong>我写程序也不是一天两天，这么多年都没有单元测试，我的日子也不错，工资一点都不低。一旦出了bug，我操起debugger就可以搞定，虽然有时候花得时间稍微长了一些。再说，即便你写单元测试就能保证没bug了，你信吗？《The Pragmatic Programmer》有云：“You Can't Write Perfect Software”。</p>\n<p><strong>习惯中不知如何单元测试<br></strong>OK，我已经经历了太多关于单元测试的轰炸，我已经开始尝试在日常工作中编写单元测试。但是我该如何编写单元测试呢？这帮“广告人”都在宣传测试驱动开发，这到底是咋回事？我怎么能在编写代码之前编写测试呢？东西都没有，我测啥？</p>\n<p><strong>习惯中有些单元测试编写起来困难重重<br></strong>你看，这个部分需要这个部分、这个部分和那个部分，我把它们合起来和把整个系统整合起来难度差不多，这叫单元测试吗？那些书上写的例子，都是简单的功能，一点都不实在。要访问外部文件怎么测？要访问数据库怎么测？要和外部实体通信怎么测？</p>\n<p>我怎么会想到这些？没什么好奇怪的，我以前就是这么想的。<br>与其说是习惯，不如是一种误解。对于“不到黄河不死心”的程序员来说，没有什么比撞得头破血流更能刻骨铭心了。<br>以前我也知道单元测试，也知道它的重要，但我对空穴来风不是很感兴趣。<br>让我接受单元测试的是Martin Flower的《重构》，凭借单元测试保证代码重构的正确性，因为重构带来的优美让我顺便接受了单元测试。<br>让我接受测试驱动开发的是Robert Martin的《敏捷软件开发》，书中的一个例子刚好点了我的死穴，和我遇到的问题一摸一样。</p>\n<p>其实，测试驱动开发是个很简单的过程，只要掌握了”红、绿、重构”的节奏可以说就掌握了测试驱动开发，只是这不同于之前那种直取要害的做法，想要把它融入自己的血液中还是需要做一些思维习惯上的改变。<br>又是习惯！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404222312",
    "date": "2004-04-22",
    "time": "23:12",
    "tags": [
      "脚下的路"
    ],
    "title": "DOOM之旅",
    "body": "<p>终于读完了《DOOM启世录》。<br>我不是DOOM的玩家，也无缘Quake。这丝毫不妨碍我对这本书的喜爱。</p>\n<p>周六晚上，我开始了这次有趣的阅读旅程。<br>同住的兄弟买了这本书，本来我只是随便翻翻，谁曾想拿起来容易，放下去难。阅读的过程中，我不只一次的告诫自己，明天还要加班，读完了这一段就去睡觉吧！结果是一口气读了近一百页，时间已经超过午夜一点。</p>\n<p>如果不是要早起加班，我100%会把它读完，没办法，太精彩了。</p>\n<p>接下来的几天太多乱七八糟的事影响了这个旅程。只有在每天醒来后，我能看上不到半个小时。好容易熬到一个没有事的晚上，我当然不会放过这一天赐良机，把剩余的部分一气清光。</p>\n<p>《DOOM启世录》是计算机图书中一本难得的精彩译作，如果它还算是一本计算机图书的话。阅读的过程中，我几乎没有感受到语言的障碍，加之原作本身的精彩魅力，这是一次舒服的旅程。我给这本书的评价是“不愿意放手的书”。</p>\n<p>这本书本身应该算是一部传记，记载了id software的天才们如何给世界带来一次又一次的震惊。书中的主角自然是天才中的天才：John Carmack和John Romero，两个John，一个是天才的程序员，一个是天才的设计师。正是二者的珠联璧合，这个世界才拥有了DOOM和Quake这样震惊一时的伟大游戏。</p>\n<p>就个人感受而言，我更喜欢这本书的前半部分。那是id software的一部奋斗史。一群除了理想一无所有的年轻人，为了一个共同的目标走到了一起，打造“最好的游戏”。在那些不分昼夜的日子里，这些人带着激情追逐着自己的理想。<br>他们成功了！</p>\n<p>至于后半部分，只是为“共患难却不能同富贵”增加一个注脚而已。</p>\n<p>就我从书中得到的感觉，我更喜欢John Carmack。<br>没人否认Carmack的天才，但有多少人了解他的付出呢？“要想人前显贵，必须背后受罪”，这句话又一次得到了证明，这里也不例外。Carmack总是付出最多的，正是他对技术不断追求，使得id software总是走在世界的前面。年少时对于黑客文化的了解，使得Carmack身体力行着黑客的精神。开放自己部分源代码，开放自己的计划，这在商业软件的世界里几乎是不可能的，但Carmack做到了。<br>但无可否认，Carmack也阻碍了id software的发展。虽然他的理想并不是像Romero那样创建的一个游戏帝国，虽然Romero的好大喜功使自己迷失了方向。正是Romero的离开，id software开始走了下坡路，尽管他们还有Carmack天才的技术。</p>\n<p>Carmack和Romero有如阴阳一般的互补：Carmack的技术只有在Romero的天才下才能得到最大限度的发挥，而Romero的设计也只有在Carmack的天才下才能得以实现。</p>\n<p>如果你和我一样，平淡如水的生活需要一丝刺激，或许这本《DOOM启世录》是个不错的选择。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404202152",
    "date": "2004-04-20",
    "time": "21:52",
    "tags": [
      "我眼看世界"
    ],
    "title": "内外兼修",
    "body": "<p>之前的几篇blog，我谈到过文字的表现力、谈到过软件的可用性、谈到过程序员应该得自我表现。<br>仅仅宣扬“皮”的重要性，很容易造成不必要的误导，让人忘记“瓤”才是一切的根本。</p>\n<p>几年前，当我沉醉于Windows的时候，最吸引我眼球的技术是如何制作一个比较酷的界面。<br>今天看到杂志上一个新的界面效果，赶紧操起键盘；明天见到新软件的特别效果，立即动脑琢磨如何实现。<br>结果是，我学到的界面制作技术完全没有用武之地，因为每当我准备写一个程序发挥一下自己所学的时候，我发现自己竟然不知道如何下手。于是，那些界面技术成了过眼云烟，在我的大脑中渐渐散去。</p>\n<p>我的工作是编写服务器端的程序。<br>在这种开发中，我不必关心用户体验如何，因为我们的程序根本就没有界面。所谓的接口，只是通信协议。这种接口没有什么可用性而言，因为那完全是别人制定的规范，我们只能无条件的服从。<br>从那时起，我的精力转向了软件的“瓤”：如何写出漂亮的代码、如何设计更好的结构……</p>\n<p>工作的这段时间，我自觉水平得到了很大的提高。除了在项目中有了比以前更多的实践机会之外，将精力放在软件的“瓤”上，也使得自己对于软件开发的认识也发生了根本的变化。<br>如果现在让我去开发一个需要与用户打交道的程序，除了可能存在的技术点之外，我会先为搭建一个合理的结构，考虑功能如何实现，而不是我设计一个什么样的界面更能让用户感到舒服。</p>\n<p>前几天和Darwin聊天。他提到一个观点，从某种角度上来说，写文章与开发软件并没有什么不同，文字是用户界面，内容是界面背后的算法与机制。即使界面再友好，如果背后的算法一堆错误，或者不实用，或者根本有没有真正有用的功能，那么这个软件就是没有用的。<br>我赞同这个观点。追求表面功夫没有错，但缺少了内涵也就失去了方向。<br>除了我大学时所犯的错误，南北朝代时期盛行骈体文也是极好的例证。虽然不乏骈体佳作，但太多的辞藻华丽却内容空虚的骈体文，极大的影响了骈体文在后世人心目中的形象。</p>\n<p>如果把前后的几篇blog合到一起，我似乎把正反两个方面都给说了，真是“人嘴两张皮，咋说咋有理”。没错，我不否认“皮”的重要，也没有贬低“瓤”的意愿。儒家的中庸之道同样适合如我一般的程序员，所以，这篇blog的题目叫“内外兼修”。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404182255",
    "date": "2004-04-18",
    "time": "22:55",
    "tags": [
      "脚下的路"
    ],
    "title": "原始武器",
    "body": "<p>你是程序员吗？你会用debugger吗？<br>我似乎已经看到了你轻蔑的笑容，程序员哪有不会玩debugger的。原本我也这样认为，但如果一切遂人愿，那早就天下太平了，我也就没了这次的话题。</p>\n<p>刚开始自己程序人生的时候，我手上的工具是那个为Borland开创了一个时代Turbo Pascal。除了语言本身，我最先学会就是TP自带的就是debugger，每当程序无法按照我预想的方式运行，大脑最先出现的总是debugger的经典词汇：设断点、单步调试、观察变量值……于是，debugger成了我屡试不爽的看家本领，从TP、TC、VC到现在的Java。</p>\n<p>和一个同事协助开发一个模块。<br>有一次，单元测试出了问题，他束手无策，把我叫了过去。<br>“快看看这是怎么回事，为什么就是过不去？”<br>“你单步调试过吗？”<br>“单步调试？”，他像发现了外星人一样看着我。“什么叫单步调试？怎么单步调试？”<br>这回轮到我像发现了外星人一样地看着他了。<br>迟疑了片刻，我假装没事人一样把如何运用debugger给他演示了一遍。<br>“哦，原来可以这样啊！”这位同事有种哥伦布发现了新大陆的感觉。<br>“你没用过debugger吗？你以前开发C程序不用吗？”<br>“没有，我以前写C程序都是在里面加打印语句。”</p>\n<p>如果这是一次偶然的意外，我的大脑很快就会把它遗忘。可就在我大脑还没来得及完成这个需要时间的工作时，又一个同事找到了我。<br>“帮我看看这里为什么总是空指针？“<br>瞪了半天眼睛，未果。<br>于是，我选择了debugger。<br>很快一个未赋值的引用被我抓了出来，就当我准备炫耀一番的时候，这位同事发话了。<br>”原来可以这么调啊！我以前从来没用过。“<br>我无语……</p>\n<p>我的这两位同事都不算上新手了，最短的写代码也超过了半年。而他们竟然对debugger——这件程序员的原始武器没有丝毫的概念。很难想象他们是如何编写调试代码的，且不说代码的质量如何，单单想象他们的调试手法，我都会替他们觉得累。</p>\n<p>或许看过Robert Martin的《<a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=23476\">Debuggers are a wasteful Timesink</a>》之后，你会站出来为我这两位同事说说好话：Uncle Bob都说debugger浪费时间了。没错，这篇文章多多少少也颠覆了debugger在我心目中的高大形象。但不要忘了，Uncle Bob认为debugger浪费时间需要建立良好的单元测试基础之上。况且，他也并没有把debugger一棒子打倒在地，一旦发现实在无法解决的问题，我们依然要祭起这件原始武器。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404152148",
    "date": "2004-04-15",
    "time": "21:48",
    "tags": [
      "向上走"
    ],
    "title": "二三有别",
    "body": "<p>Martin Flower在他的那篇《<a href=\"http://www.martinfowler.com/articles/injection.html\">Inversion of Control Containers and the Dependency Injection pattern</a>》中，提到了三种Injection的形式，它们分别是Interface Injection、Setter Injection和Constructor Injection，对应着IoC中谈到的type 1、type 2、type 3。除了Interface Injection由于较强的侵略性让我有些反感，其它的两种形式，我并没有看出什么不同。Spring和Pico都实现了这两种形式的Injection，只是Spring推崇Setter Injection，而Pico倾向于Constructor Injection。</p>\n<p>一个有趣的小问题向我展示了二者之间一些差别。<br>问题是这样的，两个组件，如果A需要B，B也需要A。那么Setter Injection和Constructor Injection是否都能很好的解决问题呢？<br>如果你明白了我要说什么，就不必再浪费时间了。如果没有，继续往下看。</p>\n<p>先来看看Setter Injection的代码。<br>public class A {<br>&nbsp;&nbsp;&nbsp; private B b;</p>\n<p>&nbsp;&nbsp;&nbsp; public void setB(B b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.b = b;<br>&nbsp;&nbsp;&nbsp; }<br>}</p>\n<p>public class B {<br>&nbsp;&nbsp;&nbsp; private A a;</p>\n<p>&nbsp;&nbsp;&nbsp; public void setA(A a) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.a = a;<br>&nbsp;&nbsp;&nbsp; }<br>}</p>\n<p>接下来是配置文件。<br>&lt;bean id=\"a\" class=\"A\"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;property name=\"b\"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ref bean=\"b\"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/property&gt;<br>&lt;/bean&gt;</p>\n<p>&lt;bean id=\"b\" class=\"B\"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;property name=\"a\"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ref bean=\"a\"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/property&gt;<br>&lt;/bean&gt;</p>\n<p>如果用Constructor Injection来完成，代码就变成了这样。<br>public class A {<br>&nbsp;&nbsp;&nbsp; private B b;</p>\n<p>&nbsp;&nbsp;&nbsp; public A(B b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.b = b;<br>&nbsp;&nbsp;&nbsp; }<br>}</p>\n<p>public class B {<br>&nbsp;&nbsp;&nbsp; private A a;</p>\n<p>&nbsp;&nbsp;&nbsp; public B(A a) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.a = a;<br>&nbsp;&nbsp;&nbsp; }<br>}</p>\n<p>配置文件也随之发生了变化。<br>&lt;bean id=\"a\" class=\"A\"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;constructor-arg&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ref bean=\"b\"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/constructor-arg&gt;<br>&lt;/bean&gt;</p>\n<p>&lt;bean id=\"b\" class=\"B\"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;constructor-arg&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ref bean=\"a\"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/constructor-arg&gt;<br>&lt;/bean&gt;</p>\n<p>显然，我们无法从字面上看出问题来，事实上，即便编译器也无法发现问题所在。那就让我们把代码运行起来。我们的测试代码也不用很复杂，读文件之后，取个bean就可以了。<br>InputStream is = new FileInputStream(\"config.xml\");<br>BeanFactory factory = new XmlBeanFactory(is);<br>factory.getBean(\"a\");</p>\n<p>看到什么了？<br>Setter一切正常，而Constructor疯狂的滚屏，直至堆栈溢出。</p>\n<p>解释这个现象很容易。想想如果我们是Spring的作者，我们如何来完成这两个组件间的组合。<br>如果是Setter，遇到A，我们用缺省的构造函数将它构造出来，发现它需要B作为它的一个属性，因为B不存在，我们构造B。B的构造过程用的也是缺省的构造函数。发现B需要A作为它的一个属性，因为A已经存在了，就把A加进来。B完成了，回头用它把它加入到A中。<br>而Constructor则有所不同。遇到A，我们构造A，但A的构造参数需要B，因为B不存在，我们构造B，结果B又需要A，我们只好再构造A，而A需要B，如此反复，直至堆栈溢出。</p>\n<p>由此可见，如果需要两个组件互相知晓，通过上面的这种Constructor Injection方式显然行不通。当然，我们可以找到其它的变通手法。</p>\n<p>或许你会问，为什么这两个组件要互相知晓？这是一个很正常的需求，比如在MVC框架中，用户在View上的操作显然要View知道Controller在哪里才能传递过去，而Controller也需要知道View在哪才能将一些处理结果让View反映给用户。</p>\n<p>总结一下。当两个组件需要相互知晓时，Setter Injection表现得明显要比Constructor Injection好，属于心理素质好，能够正常发挥的那种，这种精神值得中国足球队的小伙子们好好学习一下。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404142201",
    "date": "2004-04-14",
    "time": "22:01",
    "tags": [
      "我眼看世界"
    ],
    "title": "先作用户，后作程序员",
    "body": "<p>作为程序员的我们是否常常忽略自己计算机用户的身份呢？否则，怎么会有那么多蹩脚的软件横冲直撞呢？</p>\n<p>白天，尝试隐藏一篇blog，把管理界面翻了个遍，未果。<br>晚上，看到RssView，一个开源的Java RSS Reader。down下来，试了一下，差点吐了。</p>\n<p>想起来前几天体验SUN的Java Studio Creator的经历。<br>Java Studio Creator，这个代号Wave的IDE，号称可以简化Java程序员开发。鉴于SUN ONE Studio给我留下印象实在不好，加上《Borland传奇》中Java Workshop的故事，我实在不敢对这个产品抱有太高的期望值。结果，它果然不负众望，一如SUN之前的几个IDE一样，令人失望。<br>比起SUN ONE Studio来说，界面效果稍微强了一点，有点Delphi的味道，但无论与Eclipse还是JBuilder相比，都相去甚远，更不用说我心目中最舒服的Java开发环境IntelliJ IDEA了。创建项目时只有一个Web应用可选，我想写个Hello World都不成吗？更可恨的是，安装的时候缺省地把Sun的AppServer给装上了，之前因为安装SUN ONE Studio，我的机器上就已经装了一套SUN ONE AppServer。<br>很难相信这是一套要与Visual Studio的IDE，如果不好好改进一番，它能在Java的IDE市场出头就已经很不容易了。当然，它肯定会有一部分市场，毕竟SUN还是会通过各种渠道把它送到一些开发者面前的。</p>\n<p>回到最初的话题上。<br>在越来越强调架构、模式的今天，我们是否考虑还过我们的用户呢？<br>曾经和gigix谈论G-Roller，gigix认为对于我们最难办的就是View一层，因为程序员的强项不在于此，但我们不该因为不擅长而忽略它。<br>为什么现在Linux在桌面环境上还无法于Windows抗衡？简单易用美观是Windows的取胜法宝。普通用户才不会理会哪个操作系统内部结构更合理，性能更强大。这和我们开发软件有着异曲同工之妙，比之于内部结构，老板更在乎的是功能完成得如何。<br>这就叫“眼不见，心不烦”！</p>\n<p>编写一个面向普通用户的应用要承担比其它应用更严格的考验。作为一个程序员，在精心设计一个优美的技术架构的时候，能否给自己点时间站在用户的角度考虑一下。往往这种程序员的第一个用户就是自己，折磨自己也就罢了，把别人也捎带上，这不太合适吧！<br>有一种说法，“长得难看不是你的错，出来吓人就不对了”。</p>\n<p>提出这个问题，我更多的是站在用户的立场上，因为我写的多半是根本无需与普通用户打交道的服务器程序。如果你和我一样，至少我们没有危害劳苦大众的机会。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404122257",
    "date": "2004-04-12",
    "time": "22:57",
    "tags": [
      "向上走"
    ],
    "title": "会调程序的福尔摩斯",
    "body": "<p>知道福尔摩斯吧！即便无缘拜读柯南·道尔的大作，如果你敢说自己没听说过福尔摩斯，周围人一定会把鄙夷的目光赏赐给你。</p>\n<p>那你知道福尔摩斯是个程序高手吗？<br>在看了新一期《程序员》杂志的王咏刚先生所写的《打印机疑案》之前，我也不知道。<br>在这篇文章重，福尔摩斯先生重回人间，这次他又掌握程序技术，以高超的调试技巧，帮人侦破了打印机疑案。<br>这是我头一次看到以侦探小说的形式写出来的技术文章。早就听说，国外有高手曾经有如此惊人之举，如今看到国人的一篇另类技术文章，着实让我欣喜了好长时间。<br>对我来说，单凭这一篇文章，就已经值回整本《程序员》的价值了。</p>\n<p>在《技术的文字》中，我曾提到，许多程序员们受了太多的文字折磨。以致于面对优美的文字，脑子里首先闪现的是“废话太多”。如果把王先生的这篇文章，放到他们面前，恐怕得到的评价不会好到哪去。</p>\n<p>以个人喜好来说，我非常喜欢这种“废话太多”的文章。<br>注意王先生的文字有一段时间了。王先生的文字一向是幽默而富有内涵，阅读的过程很是享受，常常在会心一笑之际，体会到一些软件开发的基本道理。<br>最初认识王先生是他所著的那本《凌波微步——软件开发警戒案例集》。一本关于计算机技术的书，敢命名为“凌波微步”，本身就是一种不凡。<br>让我下定购买决心的是他的那篇自序《<a href=\"http://www.contextfree.net/wangyg/lbwb/lbwb_zixu.html\">青年程序员的肖像</a>》，我喜欢他那种不缊不火的幽默。</p>\n<p>《凌波微步》对我来说，短了些，意犹未尽。<br>2003年7月开始在《程序员》上连载的“凌波微步II”算是对这种遗憾的一种弥补。现在“凌波微步II”已经成了我每期《程序员》的必读，虽然碍于自己眼界，无法完全理解每一篇的精髓。</p>\n<p>在我看来，王先生的文字无疑于传统计算机技术写作的一种挑战。为什么我们还要忍受那些令人作呕的文字呢？</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404102027",
    "date": "2004-04-10",
    "time": "20:27",
    "tags": [
      "脚下的路"
    ],
    "title": "酒香也怕巷子深",
    "body": "<p>今天，和几个同学见了面。<br>工作快两年了，哥几个对自己所处的环境、获得的回报多多少少都流露出了一丝不满，有几位甚至已经开始计划自己改换门庭的时间表了。联想到近一段时间，公司里经常传出与我一同入司的某某离职的消息，似乎我们这一批人已经进入了一个换工作的高峰期。</p>\n<p>如果我说自己完全没有考虑过这个问题，包括我在内，谁都不会相信。寻找一份理想的工作也并非那么简单，高薪的工作需要至少在应聘时展现出与之相称的表现。<br>工作的朋友想必都知道应聘的艰辛。从简历上看，每个人几乎都是无所不能的超人，稍微谦虚一点都可能被当作弱智处理了。都说自己行，如何让别人相信自己才是货真价实？除了肚子里要真有货，懂得如何恰如其分的表现也是必不可少的。<br>于是，在这个“是骡子是马拉出来遛遛”的年代，学会自我展示，也成了我们这种小程序员的必修课程。</p>\n<p>梦想风暴就是一个例子。<br>梦想风暴的访问量达到第一个1000用了将近4个月时间，达到第二个用了不到3天。</p>\n<p>在《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=64254\">早到的祝福——新年快乐！</a>》中，我曾经开玩笑的谈到“等梦想风暴再壮大一些，我就得宣传一下了”。天生的懒惰使我的想法仅仅停留在思想中。慢慢地，自己都忘却了这个曾经的抱负。</p>\n<p>《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=125334\">我眼中的Spring</a>》本来只是我自己为了准备部门内部交流而做的一些总结，贴出来之后，受到许多朋友的鼓励。为了与更多的人分享自己的心得，我先后将这篇blog贴到了Spring中文论坛和灰狐的论坛上。无意的宣传换来了更多的关注。</p>\n<p>梦想风暴的变化，给了我继续努力的动力，也教会了我“广告”的力量。<br>不知道有多少人对电视上那个几乎每天扰民的送礼广告深恶痛绝，但有一点可以肯定，它的品牌已经深入民心，虽然可能不那么正面。</p>\n<p>我所结识的程序员大多对自己的技术都有充分的自信，但善于表现的确实不多。部门里，经常给大家讲东西的，也就是表现自己的，算来算去总是那么几个。大多数人都选择了沉默，如果说一点东西不懂，着实冤枉这些有着N年开发经验，甚至可以称之为资深的程序员们。除了我在《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=110926\">平凡也伟大</a>》中讨论过的不屑于平凡之外，不善于表现也应该算是一条原因。我的另一个水平并不很高的同事，因其人来疯的表现，已经在公司内外声名鹊起，并且拿到了同来者中较高的工资。</p>\n<p>最后再来说说梦想风暴。<br>它的出现始于我对blog的好奇，现在的结果早已超出了我最初的预计。<br>blog的威力已经由木子美和竹影青瞳发挥到了极致，限于本人的眼界、关心的范围和写下的文字，我不奢望梦想风暴能有那么恐怖的成就。<br>能通过梦想风暴结识几个朋友，对我来说，已经是很大的满足了。<br>如果梦想风暴中任何一篇让你的大脑细胞不再安分，那就信手评论一番，再不过瘾，就直接给我发信给我，我随时恭候！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404082037",
    "date": "2004-04-08",
    "time": "20:37",
    "tags": [
      "脚下的路"
    ],
    "title": "可怕的习惯",
    "body": "<p>最近和一个同事一起在做一个模块。我的这个同事是后加入项目组，对整个系统不是很熟悉，为了加深对系统的理解，他主动要求独自承担这个模块的开发，对我的要求是时不时的帮一把。</p>\n<p>我们这里大多数人的开发习惯并不好。我希望通过这次的合作，能把我认为好的一些东西带给他。我并不是说自己的习惯就有多么好，我只是不想让他犯我以前翻过的错误。</p>\n<p>我们的合作从测试驱动开发开始。我以项目中实际需要的一个功能为例，给他演示了如何先写测试再写功能，把“红、绿、重构”的开发节奏告诉给他。</p>\n<p>第二天，我从CVS update出他接着我的演示继续编写的代码，虽然还有些不尽人意的地方，但比起我在项目中看到其它一些代码漂亮了许多，而且测试用例写得也不错。</p>\n<p>今天看他在编写测试用例，根据之前他问我的问题，我觉得他已经写完了功能代码。我问他为什么还要先写功能，后写测试，他的答案是习惯。</p>\n<p>我的这个同事为人十分谦虚，开发的过程中经常向我问一些问题，这倒充分满足了我好为人师的虚荣心。</p>\n<p>我并不想越俎代庖把每一个细节都替他做决定，那种代码会写得很痛苦，我希望给他留下自己发挥的空间。但在实际的开发过程，几乎每一步到了最后都是我在做决定。</p>\n<p>每次我的答案都是点到为止，剩下的问题只要自己稍微思考一下完全可以解决。每次也都是用不了多长时间，他就跑过来问我更细节的该如何来做。</p>\n<p>从前与他的一些交流里，类似的情况屡有发生。<br>我给他解释了一个问题之后，向他推荐一本相关的书。之后不久，再与他交流，当我问起他是否读了那本书的时候，我得到的几乎总是“没有”。</p>\n<p>我是一个坚定交流支持者，但我确实不喜欢这种事事靠别人的态度。我的这位同事现在几乎养成了一种有问题就问的“好”习惯，而渐渐放弃了自己独立思考和学习的能力。</p>\n<p>习惯的力量多么可怕，更可怕的是不那么好的习惯。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404071928",
    "date": "2004-04-07",
    "time": "19:28",
    "tags": [
      "向下走"
    ],
    "title": "引导在哪里？",
    "body": "<p>操作系统讲什么？快翻开你那本落满灰尘的操作系统教材看看。<br>我的答案来自给了Linus开创世纪动力的《<a href=\"http://www.amazon.com/exec/obidos/tg/detail/-/0136386776/qid=1081334021/sr=1-7/ref=sr_1_7/002-9353266-0492001?v=glance&amp;s=books\">Operating Systems: Design and Implementation</a>》（中文版《操作系统：设计与实现》）。除了前面的引言和后面的代码，书中讲到了进程、输入/输出系统、存储器管理、文件系统。</p>\n<p>不知道你有没有想过这样一个问题，操作系统如何开始自己的旅程。<br>想当年，我兴致勃勃的准备以“好好学习，天天向上”的态度认认真真的学学操作系统。结果没有几天，我就被这个问题捆住了，久久不得解脱。</p>\n<p>当我通过各种渠道对操作系统的启动过程有了些许的认识时，另一个问题又冒了出来。既然启动是操作系统必不可少的一部分，那为什么各种操作系统教材对它却如此不屑。<br>我能想到的答案只有平台差异。不是吗？大家有着各自的机器结构、有着各自的汇编。胆敢涉足此处，千差万别的细节足以让所谓的权威论断碰得头破血流。</p>\n<p>如果不是听说了<a href=\"http://www.mcc.ac.uk/Documentation/grub/multiboot.html\">Multiboot Specification</a>，我一定会坚持认为自己得到就是标准答案。</p>\n<p>在Multiboot Specification出现之前，几乎每个OS都拥有自己的boot loader。也许你知道Boot loader要占据你可爱的硬盘上唯一的MBR（Master Boot Record，主引导扇区），如果每个OS要有自己的boot loader的话，那结果只能是只有一个操作系统可以启动。想像现在这样既装Linux又装Windows显然是不现实的。</p>\n<p>如果能够制订一套游戏规则，大家按照统一的方式启动，上面的问题也就迎刃而解了。在众多自由操作系统开发者的共同努力之下，Multiboot Specification应运而生。<br>可能Multiboot Specification现在还只是在你眼前闪亮的新名词。如果我请出<a href=\"http://www.gnu.org/software/grub/\">GRUB</a>和LILO两个大名鼎鼎的名字，不知能否让你产生一丝亲切感。它们两个就是遵循Multiboot Specification的boot loader，Multiboot Specification的制订者之一就是GRUB的创始人Erich Boleyn。正是GRUB和LILO这样的boot loader的存在，我们才能过上Linux和Windows和平共处的生活。这样的boot loader替我们完成了本来要由我们自己的工作，对于我们的PC而言，这些工作可能加载内核、切换至保护模式、设置内核参数等等。</p>\n<p>回头看看我先前的问题。<br>Multiboot Specification的出现，使得大家可以共享一个boot loader，于是boot loader变不再是操作系统的一部分了。<br>这是由于这个原因，后来的开发者可以将更多的把精力集中在操作系统内核的开发上，至于那些繁琐的引导细节，我们就当它不存在吧！<br>也许有人要说，不自己开发boot loader，我如何掌控全局？<br>即便自己开发boot loader，加载MBR的过程依然由机器完成，我们不可能100%的掌控全局，支持不自己开发boot loader的另外一个理由就是众所周知的“不要重新发明轮子”。自己学习当然例外。</p>\n<p>这就是开放的力量，没有开放，累傻小子去吧！<br>说到开放，不得不再说微软几句。尝试过Linux和Windows共存的朋友一定体会过重装Windows找不到Linux的悲惨。原因很简单，Windows的boot loader不符合Multiboot Specification，一旦它抢占了MBR这块高地，其它系统就只能忍气吞声了。<br>微软霸道，无处不在！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404062045",
    "date": "2004-04-06",
    "time": "20:45",
    "tags": [
      "我眼看世界"
    ],
    "title": "朋友和敌人",
    "body": "<p>微软和SUN和解了！<br>我想起了《三国演义》中的那句名言，“天下大势，合久必分，分久必合”。昔日大打出手的敌人今天把手握到了一起。</p>\n<p><a href=\"http://www.theserverside.com/\">TheServerSide</a>上有一幅非常有趣的<a href=\"http://www.theserverside.com/cartoons/GatesMcNealy2/GatesMcNealy2.gif\">漫画</a>，因为Linux的威胁，Bill Gates和Scott McNealy走到了一起。不知道是作者是有先见之明，还是对此事早有耳闻，这一幕果然上演了。</p>\n<p>国共合作始于外族入侵，微软和SUN和解缘起Linux和IBM。</p>\n<p>微软对Linux的仇恨已经不是一天两天了，早在1998年，Eric Raymond披露的万圣节文档中，微软就已经把Linux划入了敌人的行列。如果说在桌面应用上Linux的威胁多少还是来自于微软的未雨绸缪，在服务器市场上，Linux对SUN的威胁却是实实在在的，更何况觊觎这块肥肉已久的微软了。</p>\n<p>IBM是无论何时都不能小觑的。没有它，我们恐怕没有与计算机亲密接触的机会。虽然它犯了一些险些送命的错误，但今天，我们看到的是一只翩翩起舞的大象。到我们最熟悉的developerWorks走一遭，除了IBM自家的东西，我们看到的是Linux、Java这样一个个熟悉的名字。显然，IBM已经找到了PC之外的另一条霸主之路：Linux+Java，微软不会涉足的市场。</p>\n<p>时至今日，谁也无法否认SUN推出的Java是难得的好东西，多少公司在这个微软不愿涉足的领域获得了成功。遗憾的是，Java的自家人只有眼见别人数钞票的份。同施乐著名的Palo Alto研究中心（PARC）全心奉献不求回报不同，SUN琢磨的更多的是怎么用Java赚钱。如此心态换得如此结果，SUN显然无法满足。IBM一次又一次的呼唤SUN开放Java，要知道，在一次调查中，Java的品牌已经超过SUN本身。面对蓝色巨人步步紧逼，SUN何去何从。<br>微软推出.NET为的就是和Java抢市场，毕竟.NET还年轻，加之微软的霸道，于是太多人选择了站在Java一边。IBM PC当年的取胜法宝是什么？开放。开放了，大家都有的玩，于是跟进的人也就多了，虽然最终无法避免弱肉强食，至少大家都还可以在初始阶段趁乱捞一把。这就叫人多力量大。而其中，蓝色巨人扮演了重要的角色。</p>\n<p>面对着Linux和IBM两个强敌，本着“敌人的敌人是朋友”的原则，两个曾经的敌人走到了一起。</p>\n<p>CSDN上有网友评论，与微软合作多半没有好下场，SUN呢？起码刚开始不会，毕竟大敌当前。至于以后，谁知道呢！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404041527",
    "date": "2004-04-04",
    "time": "15:27",
    "tags": [
      "我眼看世界"
    ],
    "title": "再谈代码阅读",
    "body": "<p>下面是dequator对《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=127200\">代码阅读</a>》的评论：<br>代码阅读，你真的有必要花费大量的心血，甚至还专门买本书吗？<br>诚然，好的代码习惯会使整个项目得益，但是你从阅读代码的方法中是否真正能够得益？你所面临的代码，是否真能够像你所想象的那样去阅读？</p>\n<p>代码阅读，各人有各人的目的，《Code Reading》将代码阅读的动机整理了一番：<br>&nbsp;&nbsp;&nbsp; 将代码作为文献（Code as Literature）<br>&nbsp;&nbsp;&nbsp; 以代码为范例（Code as Exemplar）<br>&nbsp;&nbsp;&nbsp; 维护（Maintenance）<br>&nbsp;&nbsp;&nbsp; 演进（Evolution）<br>&nbsp;&nbsp;&nbsp; 重用（Reuse）<br>&nbsp;&nbsp;&nbsp; 审查（Inspections）</p>\n<p>由此可见，代码阅读既有主动为之，也有被动而行。但结果是一样的，阅读代码。<br>出于自愿自觉的目的，我们并不会选择那些自己都觉得恶心的烂代码来读，但如果是工作需要呢？我们别无选择。</p>\n<p>再来说说我买书的目的。<br>我是个书虫，不愿意错过任何的好书。而《Code Reading》这本书的价值，Productivity大奖应该是最好的一个诠释。当然，我购买的目的并非完全的盲目崇拜，更多的还是个人的需要。</p>\n<p>曾几何时，我企盼的是一步登天。不做好日常工作就能办好大事需要何等的天才。</p>\n<p>如果给自己一个评价的话，我觉得自己是个资质平庸的程序员。身边没有那种笑傲江湖的绝顶高手，更不用说那些高山仰止的大师级人物了。一个优秀的程序员会如何来做呢？我不知道，大多数时间，只有自己摸索。</p>\n<p>我对敏捷方法有着特别的好感，除了广告般的理由，我对更感兴趣的是其中一些个人实践方法，比如重构、比如测试驱动开发。有机会向世界级的程序员学习做事和思考的方式，这难道不是一种令人兴奋的事情吗？<br>我所处的位置决定了敏捷方法对我而言，只能从一些个人实践开始。作为一个普通程序员，首先要扮演好自己的程序员角色，不是吗？</p>\n<p>对我而言，《Code Reading》这本书拥有着同样的意义。我不是没有自己阅读代码的方法。但运用自己的方法时，我发现自己很难对程序有一个很好的把握，常常是只见树木，不见森林。人为什么要学习，不就是为了少走一些弯路吗？我知道自己的方法一定算不上好方法，所以，我选择了这本书。<br>通过向世界级程序员学习阅读源码的方法，我就可以省去了自己慢慢摸索的时间，何乐而不为！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404032025",
    "date": "2004-04-03",
    "time": "20:25",
    "tags": [
      "我眼看世界"
    ],
    "title": "代码阅读",
    "body": "<p>《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=125334\">我眼中的Spring</a>》成功的作了一块引出玉的砖。这块玉是<a href=\"http://osthoughts.blogbus.com/\">founder_chen</a>的《<a href=\"http://www.blogbus.com/blogbus/blog/diary.php?diaryid=126737\">Spring is comming</a>》。<br>谈及使用Spring可能遇到的一些问题时，founder_chen多次提及“代码阅读”。刚好今天买了拿走今年一个技术类图书Productivity大奖《Code Reading: The Open Source Perspective》（中文版《代码阅读方法与实践》），于是今天准备信口开一条关于代码阅读的河！</p>\n<p>Donald Knuth和Richard Stevens这两位大师级人物分别在在自己的旷世之作中点明了代码阅读对于程序员成长的重要意义。我想我是无论如何不可能再锦上添花了，于是我选择不再赘述。</p>\n<p>大多数程序员（包括我自己）在研究代码的时候，都希望准确的弄清楚来龙去脉。<br>在我身处C世界的那个年代，从平铺直叙的C代码挖掘自己所需的一切是那么轻松。走进Java，知晓OO，遭遇设计模式，事情突然发生了改变。</p>\n<p>面向对象程序设计中一个很重要的方法就是面向接口编程，这种做法的好处无需我多言。在我沉浸于设计模式之美，程序设计之妙的同时，代码阅读的问题浮出了水面。<br>从前阅读Tomcat的启动代码，配置文件加载完毕，然后Server启动，完了。Server是什么？一个接口。单从这段代码本身来说，它的功能我已经看明白了，但究竟这个instance的具体类型是什么，它是如何同Server联系到一起的，一头雾水。当然，后来我弄清楚了Tomcat利用commons digester完成系统配置的手法。<br>这是接口编程的好处，完全不关心具体实现。但对于喜欢刨根问底的人来说，绝对是一种折磨。<br>前不久，项目组的一个同事问我，为什么我的代码有这么多层，以致于无法一下子看清楚究竟实现了哪些功能。这么做当然有理由的，我还没有疯狂到平白无故增加层次的份上，但结果是无法清晰看透全部。</p>\n<p>眺望未来，如果AOP真能走入寻常百姓家，代码阅读的问题可能会再度加重。采用AOP思想的代码，将不同的逻辑进行了分离，造成的结果就是，仅仅阅读一部分代码根本无法获得全部的信息。</p>\n<p>难道我是在支持C的风格？我可没这么说。<br>我和我的那位同事都是以C起家，所以，拿到一段代码的时候，情不自禁就会以C的那套思想往OO代码上套，毕竟抢扭的瓜不甜。入乡要随俗，阅读OO代码之前，我们需要了解一些OO代码的基本习惯，设计模式就是一种OO习俗。对于Java之类可以动态干许多事的语言，动态配置的手法也是基本功之一。<br>阅读OO代码，和编写OO代码一样，也应该有个层次概念在那里，关注这段代码的时候就暂时不要考虑其它部分的所作所为，一切都混杂在一起，那就乱套了。<br>最近和几位做C的同事交流，探讨的过程中，我发现他们总是喜欢问上面的结构的同时又要了解底层实现。我不是说多了解东西不好，而是说混杂在一起不好。不知道为什么有这个东西，管它怎么做干什么？<br>仅仅“看”是看不出多少好处的，如果真行的话，我们的代码也就不必调试了。代码只有运行起来才具有生命力，就像猴毛在孙悟空身上只是毛，而吹了那口仙气它们就能活起来一样。所以，阅读代码之前，先让它编译运行起来，否则，我们只能看到猴毛。<br>阅读代码讲求技巧的，这也是我购买《Code Reading: The Open Source Perspective》的原因。我希望通过这本书的阅读，学习别人一些的经验。</p>\n<p>平铺直叙的代码最清楚，所以，我们系统1.x版本中代码获得了“很清楚”的称号。一篇平铺直叙的文章能赢得你多少的好感？如果我以标准中国式教材的语言写这篇blog，你能坚持看到现在吗？<br>同样，如果1.x真的那么好，我们也就没有开发2.0的必要了。<br>用Java不见得写出的就是OO代码。现实情况是，许多人用Java写出的是C代码，结果是这些可能看着清楚的代码为后期的扩展维护带来不知道多少的麻烦。</p>\n<p>如果你经常在自己参与的项目中看到一个个长达数千行的函数，恭喜你！你在和一群勤劳的程序员一起工作。能把代码写得如此冗长，需要有非常好的耐心。<br>对了，Perl语言的发明人Larry Wall说过，程序员的三大美德是：傲慢、急躁，以及懒惰（hubris，impatience and laziness）。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200404012000",
    "date": "2004-04-01",
    "time": "20:00",
    "tags": [
      "向上走"
    ],
    "title": "我眼中的Spring",
    "body": "<p>用Spring有一段时间了，最近在部门内部做个Spring的培训，一个很自然的问题出现大脑之中，Spring好在哪？<br>我可以摆出许多广告，但那不是我的感觉。于是，我向自己发问，要求一个属于自己的答案。</p>\n<p><strong>Dependency Injection</strong><br>原来，它叫IoC。<br>Martin Flower发话了，是个框架都有IoC，这不足以新生容器反转的“如何定位插件的具体实现”，于是，它有了个新名字，Dependency Injection。<br>其实，它就是一种将调用者与被调用者分离的思想，Uncle Bob管它叫DIP（Dependency Inversion Principle），并把它归入OO设计原则。<br>同Spring相比，它更早进入我的大脑。一切都是那么朦胧，直至Spring出现。<br>慢慢的，我知道了它还分为Interface Injection（type 1），Setter Injection（type 2），Constructor Injection（type 3）。Martin Flower那篇为它更名的大作让我心目关于它的一切趋于完整。<br>在Spring中，它是一切的基础。Spring的种种优势随之而来。<br>于我而言，它为我带来更多的是思维方式的转变，恐怕以后我再也无法写出那种一大块的全功能程序了。</p>\n<p><strong>动态配置</strong><br>这里提及的动态配置包括两个部分：系统的生成和系统的修改。<br>基于Spring的应用是依赖配置文件组织起来的，这意味着我们所编写的程序，更多的是在完成具体的功能，而各个功能之间的串连，就要靠配置文件了。<br>随之而来的一个好处就是，我们可以在不重新编译代码的情况下，改变系统行为。<br>或许不修改代码可以成为另一个理由，但在我看来，修改Java代码和修改配置文件没有什么本质区别，只要能把配置文件视为另一种语言，不是吗？<br>有位同事问我，Spring的配置文件的正确性是否只有运行时才能发现，道理上讲是这样的。每次修改配置文件，然后跑起来确定其正确性，这确实是一件费力不讨好的事。如果你是Eclipse的用户，你就幸福多了，已经有人开发了Spring的插件协助你完成这个工作。</p>\n<p><strong>易测的结构<br></strong>曾经有一次在现场，我改一个简单的小bug，简单到加在一起改的代码不超过五行。但从我定位到错误到完全把bug修正，用了两个多小时，这使得两个同伴最后只能对我怒目而视。<br>这其中固然有我自己糊涂的原因，代码不可测也是很重要的一个原因。每次修改了一句话，就要部署到应用服务器上，运行起来看结果。相信每个有在应用服务器上部署应用经验的人都知道那是多么漫长的过程。<br>如果以前对我说，对于一个好的应用来说，可测试性也非常重要，我摆出一副非常不屑的态度，惨痛的教训彻底的教育了我。<br>Dependency Injection让整个应用结构清楚了许多，我们可以针对每个具体的模块进行单元测试，而不必像过去一样，只有把整个应用部署到应用服务器上运行起来之后，才能测试。<br>局部的稳定带来的是更多的信心，当系统一点点整合在一起，信心就越来越足。</p>\n<p><strong>不存在的接口压力<br></strong>项目组中的一个同事对我说，用Spring跟没用一样。原因是我们的代码并没有继承Spring中的类，也没有实现Spring中的接口。<br>这恰好就是Spring的优势之一，这使得我们的应用不必困在Spring上。依赖于特定的API就意味着要在一棵树上吊死。我们原来系统中很难测试的另一个原因就是在代码中遍布HttpServletResponse，这使得我们的代码只有放在Web容器中才能跑起来。<br>Rod Johnson在评价一个Web框架的优劣时，将是否依赖于Servlet API作为一个及其重要的标准。<br>依赖于特定API就意味着要依赖于特定的容器或是框架，就像Servlet一定要跑在Web Container里，EJB一定要有AppServer一样。<br>没有了接口的压力，使得我们应用可以完全脱离Spring运行。在系统开发期间，我不断强调即便没有Spring，我们的应用依然可以自行组装来运行，给我这种底气的理由就是Spring没有侵略性的接口。另一个原因是当时我并没有对把整个系统放到Spring上有十足的把握。^_^</p>\n<p><strong>消除Singleton<br></strong>Singleton是二十三个经典的设计模式之一，不幸的是，到了J2EE的世界，由于classloader的原因，它几乎成了一个经典的反模式。曾经在自己的代码中大量运用Singleton，部署中遇到的问题加上太多的重复代码，给我留下了一段不堪回首的经历。<br>Spring的出现漂亮的解决这个问题，我只要在配置文件中配置一个bean，它缺省行为就是Singleton，我不必再为反模式抓空心思，不必再为了Singleton编码。</p>\n<p><strong>择其善者而从之</strong><br>不同于很多技术，Spring并不是一个“要么全部，要么没有”的东西，它是一个分层的结构。我们可以从中选取我们感兴趣的部分，而不必理会其它的部分。我用得最多的部分就是Spring的Core部分，也就是基于bean的配置框架，对于其上的MVC、ORM、DAO等等，我并不了解，但这丝毫不影响我的运用。</p>\n<p><strong>开阔视野</strong><br>Spring本身包含很多的东西，从Dependency Injection之类思想性的东西，到现在颇为流行的AOP、ORM之类实现技术。在Spring的路线图中，JMX、JMS、JCA等等已经都纳入了Spring未来的发展计划中。于我而言，沉浸于Spring的世界里，一段时间内不愁没东西可学。<br>Spring起源于Rod Johnson的《Expert One-on-One J2EE Design and Development》，所以，这本书成了Spring最好的辅导材料。书中的许多观点的提出完全是基于Rod本人的实际经验，比起不少假大空的理论或是广告来得实际得多。Spring邮件列表中有人这样评价，这本书值得“cover-to-cover”的读。如果你和曾经的我一样，迷失于J2EE纷繁复杂的世界中，这是一剂让你清醒过来的良药。</p>\n<p>这就是我眼中的Spring，这些理由比之许多Spring的广告显得单薄许多，因为我对Spring的了解实在有限，但这足以让我相信在Spring上花费时间是值得的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200403192315",
    "date": "2004-03-19",
    "time": "23:15",
    "tags": [
      "我眼看世界"
    ],
    "title": "又是一年Jolt时",
    "body": "<p>第14届的Jolt大奖评选结果揭晓了！</p>\n<p>通用类图书Jolt大奖被《Waltzing with Bears: Managing Risk on Software Projects》拿走，一本讲项目风险的书，Tom Demarco和Timothy Lister可是《Peopleware》的作者，大师出手果然不同凡响。开源先锋Eric S. Raymond的大作《The Art of UNIX Programming》只能屈居亚军了。</p>\n<p>技术类图书Jolt大奖是《Test-Driven Development: A Practical Guide》，敏捷的又一次胜利，不过，这可不是Kent Beck的那本。Kent的那本是By Example，这本是A Practical Guide，Amazon的四星之作。我所知道的另一本著作《Code Reading: The Open Source Perspective》拿到了Productivity大奖。另一本大师之作，Erich Gamma和Kent Beck所著的《Contributing to Eclipse: Principles, Patterns, and Plugins》榜上无名，只能怪选题略偏了。</p>\n<p>有不少我们熟悉的东西榜上有名，Eclipse夺走了语言与开发环境的Jolt大奖，IntelliJ IDEA是这项Productivity大奖。Hibernate是程序库、框架和组件类的Jolt大奖。IBM的developerWorks是网站类的Jolt大奖。Dreamweaver则走进了名人堂。</p>\n<p>Jolt大奖总是一个好东西集散地，按图索骥多半是没错的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200403192247",
    "date": "2004-03-19",
    "time": "22:47",
    "tags": [
      "我眼看世界"
    ],
    "title": "纪念Blogbus回归",
    "body": "<p>我果然是个习惯的动物，习惯了每隔几天就把自己凌乱的思维表达在blog上，习惯了时不时看看自己blog的访问量有多少的增加。</p>\n<p>从来没有意识到自己竟然对blog有着如此严重的依赖。<br>一夜之间，Blogbus停了。</p>\n<p>我忽然有了种不知所措的感觉，原来习惯的力量如此巨大。</p>\n<p>Blogbus停摆的原因众所周知。<br>游戏自有它的规则，参与其中自然是为了获得它的乐趣。伤及无辜的游戏者总是会受到其他游戏者的鄙夷。为了大家共同的乐趣，我们还是应该遵守游戏的规则。</p>\n<p>今夜，本来已经做好了睡觉的准备，无意间的尝试让我惊喜的发现blogbus的回归。</p>\n<p>欣喜之余，赶紧调动大脑中休息了几日的细胞为此纪念一番，于是有了这篇Blog。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200403112245",
    "date": "2004-03-11",
    "time": "22:45",
    "tags": [
      "我眼看世界"
    ],
    "title": "理想和现实",
    "body": "<p>gigix又一次再CSDN上受到了攻击，这次是因为开源。<br><a href=\"http://www.csdn.net/develop/article/25/25146.shtm\">http://www.csdn.net/develop/article/25/25146.shtm</a></p>\n<p>从去年开始，我逐渐成为了一个开源的忠实支持者，虽然我实际参与到开源活动并不是很多，但对于开源的文化，我充满了无限的憧憬。</p>\n<p>就我个人而言，已经从开源中受益匪浅了。<br>我是一个不喜欢被蒙在鼓里的人，所以，总想捅婆最后一层的窗户纸，开源项目给了我这个机会。看看开源项目涉及的范围，从操作系统到数据库，从应用服务器到应用框架，只要心存疑虑，完全可以打破沙锅。</p>\n<p>曾经在Windows上写过程序，那时的我心中完全没有开源的概念，MS带给我的Windows文化总是若有若无的说，少知道一点好。所以，对Windows下的程序，我总是心有不爽，除了自己的不够努力之外，文化的力量也不可小觑。</p>\n<p>开源，让我有了一个向高手学习的机会。想想吧！不经意间打开的那个文件，它的作者就是那个享誉程序设计世界的顶级高手，阅读源码，无异于同这位或许无缘谋面的高手面对面谈心。感慨地球果然是个“村”的同时，不忘偷学个一招半式，对于日后的闯荡江湖有利而无弊。</p>\n<p>G-Roller是我参与最多，同时也是受益最多的一个开源项目。<br>我们项目现在的底层结构完全是从G-Roller借鉴来的。<br>G-Roller是一个非常好的教材，不但演示了诸如Struts、Hibernate、SpringFramework等几个优秀的开源软件包的用法，同时很好的诠释了IoC的概念。<br>我就是从G-Roller开始了解SpringFramework，开始理解IoC的。</p>\n<p>回到gigix在CSDN上遭受攻击的话题上。<br>大多数的攻击都放在理想和现实的结合点上，做开源，生活怎么办？<br>大多数中国程序员归根结底一个字，穷。<br>物质生活无法得到保证的前提下，很难投入很大精力去做开源。像一些大公司投入专人做开源的情况毕竟是少数。说到这，想起了我的一个同学，他在一家大公司，做着Linux开发，职业结合开源，着实令人羡慕。<br>反过来，恐怕喊穷的这些人真的有一天富了起来，他们会愿意去做开源吗？不见得。<br>做开源的人多半要有一些理想主义，太过现实的人恐怕不愿意花费时间在无法获得收入的地方。<br>一个开源项目之初更多的依赖于其成员的付出，但想长时间的运作恐怕就不是那么简单了。<br>我的一个同事是国内一个知名开源社区的核心成员，他常常对我说，要是有笔资金注入，他们的项目可以做得更好。</p>\n<p>这就是理想和现实。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200403082218",
    "date": "2004-03-08",
    "time": "22:18",
    "tags": [
      "向上走"
    ],
    "title": "模拟语法结构",
    "body": "<p>项目组的一个兄弟提出一个令我目瞪口呆的想法，模拟语法结构。</p>\n<p>实际做法很简单，下面以Java语言讲解一番。</p>\n<p>学过编程语言的都知道，语句是程序设计中的一个基本单位，大语句由小语句组成。</p>\n<p>我们定义语句如下：<br>public interface Statement {<br>&nbsp;&nbsp;&nbsp; public void execute(Context context) throws Exception;&nbsp;&nbsp;&nbsp; <br>}</p>\n<p>其中context是用来存放执行语句所需的相关信息的一个接口。</p>\n<p>一旦看到了语句的出现，我们很自然就会联想到顺序语句、选择语句和循环语句等等，这几种语句也是语句，看起来这是废话，实际上我指的是LSP（Liskov替换原则）。所以，我们让这几种语句也成为语句，下面给出一种可能的顺序语句实现：<br>public final class Sequence implements Statement {<br>&nbsp;&nbsp;&nbsp; private Statement[] statements;&nbsp; </p>\n<p>&nbsp;&nbsp;&nbsp; public Sequence(final Statement[] statements) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.statements = statements;<br>&nbsp;&nbsp;&nbsp; }</p>\n<p>&nbsp;&nbsp;&nbsp; public void setStatements(final Statement[] statements) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.statements = statements;<br>&nbsp;&nbsp;&nbsp; }</p>\n<p>&nbsp;&nbsp;&nbsp; public void execute(Context context) throws Exception {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; this.statements.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.statements[i].execute(context);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p>\n<p>结构很简单，顺序语句由一堆“语句”组成，execute就是顺序调用就OK了。<br>我们可以用同样的方法实现选择语句、循环语句。</p>\n<p>到这里，我们可能还无法看出这种结构的优点：语言已经提供了很好的结构，为什么要模拟？<br>这么做最吸引我的地方就在于它的可配置性。</p>\n<p>IoC，Robert Martin叫它DIP，对了，Martin Flower给它改了个名叫Dependency Injection，最近比较火爆，《程序员》2004年第三期上有一篇gigix翻译Martin Flower的那篇《Inversion of Control Containers and the Dependency Injection pattern》比较详细的讨论了它。</p>\n<p>稍微对它熟悉一点的话，我们不难看出，上面Sequence的实现用到了setter和constructor，它们分别代表了IoC的type 2和type 3，通过这种方式，我们就可以很轻松的配置自己的应用了。</p>\n<p>我知道这么说，还会让人有一头雾水的感觉。</p>\n<p>我们应用的新版本是在SpringFramework的基础上构建起来的，SpringFramework就是一个很好的IoC容器。它让我们可以通过配置文件来构建整个应用。<br>假设BasicProcessor1和BasicProcessor2是两个实现了Statement接口的类。使用SpringFramework，我们可以这样构建自己的应用。<br>&lt;bean id=\"processor1\" class=\"BasicProcessor1\"&gt;<br>&lt;bean id=\"processor2\" class=\"BasicProcessor2\"&gt;</p>\n<p>&lt;bean id=\"flow\" class=\"Sequence\"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;property name=\"statements\"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ref bean=\"processor1\"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;ref bean=\"processor2\"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/property&gt;<br>&lt;/bean&gt;</p>\n<p>其中，processor1和processor2可以分别看作BasicProcessor1和BasicProcessor2的instance。flow是Sequence的一个instance。</p>\n<p>当系统生成时，SpringFramework会自动调用setStatements将processor1和processor2作为一个数组设置到flow中去。这样就省去了我们手工配置系统的繁琐工作。<br>说起来很神奇，其实这是利用了JavaBean的一些特性。</p>\n<p>回到我们前面的讨论上。<br>当这种配置方法和模拟语法结构相结合，威力就显现出来了。<br>我们完全可以在不改动系统源代码的情况下，修改系统生成的配置文件，从而达到改变流程的目的。<br>如果有了新的需求，我们可以单独开发一个Statement，然后再把它配置到系统中，而原有的代码无需任何改动。<br>多么美妙的一种想法啊！</p>\n<p>放任我们的思绪继续前行！<br>真正控制我们应用结构的是我们的配置文件。在SpringFramework中，在一个应用中可以有多个配置文件，我们可以把组件定义放在一起，而把流程控制的部分放在一起。于是，我们只要修改流程控制的部分就可以达到对整个系统的重新设定。<br>前面已经说过，模拟语法结构无非是顺序语句、选择语句、循环语句等等，从本质上说，它就是一门语言，而我们的流程配置文件就是这种语言的源代码，唯一的缺陷就是相对烦琐一些。<br>如果我们再向前迈一步，把模拟的语法结构变成真正的语法结构，那它就会成为一门真正的语言。编译器的工作就是将一种语言转化为另一种语言，而我们流程配置文件本身就是模拟语法结构的源文件。我们完全可以开发一个小型的编译器，将这种语言编译生成我们流程控制文件。<br>达到这一步的话，以后的应用开发就成了用这种小语言来编写控制流程，只有真正的新东西才需要我们编写Java代码，这将极大的降低我们开发的工作量。</p>\n<p>或许这会引起某些人的不屑，前面说过模拟语法结构是为了不编译代码，如果开发自己的编译器编译和用Javac编译有什么不同？<br>复杂程度。<br>二者所在的层次不同，我们用自己的语言控制的流程，而不是细节。<br>如果把我们的语言比作高级语言的话，那么直接用Java编写的代码无异于现在的汇编，想必大家对二者的开发速度都有自己的比较吧！</p>\n<p>模拟语法结构，这种做法本身上没有什么技术难度，难的在于把它提炼出来，惯性思维常常会局限我们的思路。</p>\n<p>或许不经意间，又一个好想法浮现于脑海之中。<br>不要犹豫，赶快操起键盘实现它！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200403042046",
    "date": "2004-03-04",
    "time": "20:46",
    "tags": [
      "脚下的路"
    ],
    "title": "平凡也伟大",
    "body": "<p>把自己的《Expert One-on-One J2EE Design and Development》借给了一个同事。在他读了一些内容之后，我建议他将自己所学给大家讲讲。得到的答案出乎我的意料。</p>\n<p>“有什么好讲的？”<br>“你不是已经看了一些了吗？”<br>“就是没有什么值得讲的，又不像你前两天讲的东西，那么有深度。”<br>“就讲讲你看的数据访问。”<br>“不过是对JDBC封装的一些小技巧。”<br>“你可以和你做的进行对比，分析哪种手法更好。”<br>“它只不过给异常分了个层次，我们的项目中用不上。”</p>\n<p>每每学习新东西，我总有一种心潮澎湃的感觉。我更喜欢解惑后的快感，虽然可能对实际工作起不了什么作用，所以，我热爱学习的感觉。当然，有时心中多少会存在一些盲目。<br>在我看来，当新鲜事物的神秘面纱在我的这位同事面前掀起的时候，事实的真相会让他顿失探索的乐趣，于是一切也就失去了最初的魅力。</p>\n<p>这位同事对自己的探索结果如此不屑，却给别人的成果以神奇的评价。如果把我前两天讲的那些东西交由他来研究，研究完的结果很可能又会是“不过如此”，而面对我的信口开河，他却觉得这是一个有深度有难度的问题。</p>\n<p>平凡琐碎的事情确实不如宏图大业来得让人热血沸腾，但能够做好平凡小事的人依然让人尊敬。明天又是毛主席为雷锋题词的纪念日，我们印象中的雷锋除了助人为乐，是否还有做好平凡小事呢？</p>\n<p>找出平凡中的不平凡，其乐无穷。苹果年年熟，为什么只有砸在牛顿头上的引出万有引力？我们鄙夷平凡的同时也就丧失了从平凡中获得发现的机会。</p>\n<p>人与人不同，这大概就是社会存在分工的原因吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200403032045",
    "date": "2004-03-03",
    "time": "20:45",
    "tags": [
      "我眼看世界"
    ],
    "title": "历史的延续",
    "body": "<p>历史得以延续，虽然不是什么光荣的历史。</p>\n<p>一个差劲的韩国队和一个更为差劲的中国队为我们上演令人作呕的奥运预选赛，如果不是其中一支背负中国的名义，我实在想不出这场比赛有什么吸引我的理由。</p>\n<p>这不是那支在世界杯威风八面的韩国队，球场上稀稀拉拉的观众也没有2002时的胜景。开场之后的频频失误让我误以为中国队改写历史的机会终于来临。经过象征的抵抗，中国队开始自己的防守演练。</p>\n<p>“宁愿轰轰烈烈死，不愿窝窝囊囊活”，记不清当年是哪位喊出这样的口号了，但这支中国队又一次为我们展示了什么叫“窝窝囊囊死”。</p>\n<p>好像这些到韩国公费旅游的家伙脑子压根就没有“赢”这个字，除了偶尔有几个人站在前场尝试一下或许罗纳尔多能够完成在人群中的突围之外，剩下的人都和自己的半场无比亲近，根本不想背井离乡。</p>\n<p>这就是所谓的超白金一代，除了哀叹金价的下跌，又能如何？<br>赛前频繁露面的亚青赛对韩国战而胜之的陈年旧闻，在无情的0:1面前显得那么一文不名。</p>\n<p>“如果不是有队服的差别，实在很难分出这是两支球队在比赛”，这是和我一起看球的一个兄弟对场面的评论。</p>\n<p>平心而论，以这两支球队今天所展现的实力而言，任何一支如果能够侥幸突破亚洲重围，站到雅典赛场，也只能为亚洲球队再添一笔耻辱的记录，或许，下次讨论各洲的名额分配时，其他大洲的代表又可以为自己增加一条减少亚洲参赛名额的理由。</p>\n<p>最近几个星期，我见识了起码拥有胜利的中国国家队世界杯外围赛，看过米兰德比的惊心动魄，欣赏了罗马奉献的赏心悦目。<br>终于，今天对自己进行一次毫不留情的摧残，无论从视觉上，还是从心理上。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200403022253",
    "date": "2004-03-02",
    "time": "22:53",
    "tags": [
      "脚下的路"
    ],
    "title": "编码培训",
    "body": "<p>今天又在部门内部做了一个培训，这次是关于编码的。</p>\n<p>编码是整个软件过程最为基础的一环，在各位软件工程大师对过程的拼命鼓吹下，编码似乎成了无足轻重的一环。编码，在我的心目中要远远高于所谓的过程，毕竟软件开发归根结底还是要靠编码来完成。</p>\n<p>少了物质基础，再多的文明都无异于水中月。</p>\n<p>关于编码，有许多东西值得探讨，从编码风格到语言特性，从面向对象到重构习惯。</p>\n<p>我列了一个很长的提纲，涉及了许多我认为与编码相关的方面。有人建议我精简一下，毕竟一次讨论这么多的东西显然不现实，即便一一点到，也只能是浅尝辄止。于是，我把这次培训的范围定在了Java语言上。</p>\n<p>为什么要讨论语言本身？<br>我的理由来自《C++沉思论》，“语言的设计就是程序库的设计，程序库的设计就是语言的设计”。<br>程序库的作者往往面临的是比普通应用程序员更严格的考验，他们要想尽一切办法，防止自己的客户对自己程序库的误用。语法上的保证显然比文档或是行政的力量更为强大。所以，他们将把语言的语法研究到无以复加的地步。于是，Java世界关于编码最重要的一本书《Effective Java》出自一位程序库的作者——Joshua Bloch，JDK Collection的实现者之一。<br>高质量的程序库显然不是程序库作者一厢情愿就能完成的，语言本身在这个问题上的表现同样举足轻重。C++之父在《C++语言的设计与演化》中为我们讲述了C++的进化过程，从中不难看出，程序库对于语言的演化起了多大作用。</p>\n<p>我的讨论基本采用的是从语法到语义，再到实现的方式。</p>\n<p>让我感觉惊讶的是，一些已经写许多Java程序的同事居然问出“static method不能override吗？”之类的问题。<br>太多的同事将精力集中于问题的本身，而对解决问题的方法却很少进行深入的思考，于是，我也不难理解，为什么他们做了几年，除了经验增多，水平并无多少长进。</p>\n<p>还有一些令我遗憾的东西，如果说大家对于语法和语义还稍有热情的话，对于实现，则没有多少人有兴趣。于我而言，只了解上层语法语义而不了解具体实现无异于“浮沙筑高台”。</p>\n<p>人和人，真的是不同的！<br></p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402291030",
    "date": "2004-02-29",
    "time": "10:30",
    "tags": [
      "我眼看世界"
    ],
    "title": "技术的文字",
    "body": "<p>技术的进步给普通老百姓带来的是无比的便捷，给如我一般的程序员带来的却是无尽新知。<br>于是，学习成了程序员生活的一部分。</p>\n<p>除了言传身教，阅读大概是程序员们最熟悉的一种学习方式。</p>\n<p>从小就是书虫的我，在开始计算机的技术阅读之前，从未考虑过文字的力量。<br>曾几何时，捧起一本书，我总是能够兴致勃勃的读下去。精彩的文字经常让我在老妈数次催促之后，才依依不舍地放下手中书去解决温饱问题。</p>\n<p>开始自己的程序人生之后，每每捧着一本本“砖头”，苍白干涩的文字总让我有种味如嚼蜡的感觉。硬着头皮的阅读使得瞌睡虫总能够按时来访。<br>渐渐，我习惯了这种文字，技术文字因严谨而生涩成了我心中一条无需证明的公理，折磨自己成了成长路上的必然。</p>\n<p>侯捷先生优美而亲切的文字，颠覆了我的这条个人公理。<br>我几乎拜读过侯先生网站上的所有文章。在不知不觉中学到知识，获得长进是我对侯先生文章极尽推崇的原因之一。泥泞中跋涉的艰难，使我对于一马平川充满了无尽的热爱。<br>榜样的力量是无穷的。<br>侯先生之后，诸多俊才纷纷开始展现自己的才华。myan、gigix、kingofark以及刘天北先生是我比较欣赏的几位。<br>他们的文章不但文字感染力极强，而且旁征博引，往往可以获得许多技术之外的收获。</p>\n<p>遗憾的是，太多的程序员大概受到了太多如我先前一样的折磨，那条本不该存在的公理却已根深蒂固。<br>最有趣的例子莫过于CSDN上的大论战。<br>许多人指责这种文章废话太多，看了半天不知道在说些什么，他们需要的是直接了当。<br>太多的镀金让人无法承认真金的存在。</p>\n<p>在我眼中，技术资料分为可用和可读两种。</p>\n<p>可用的资料属于快餐，方便快捷，没有营养。<br>每每遇到问题，我们如何解决：找来一本“砖头”，或是挥动google。<br>我们通常会采用“百万军中取上将首级”的方式，直指要害。<br>杀得兴起之际，谁会在意一个普通的小兵是何长相。<br>这种资料如同字典，用的时候能找到地方足矣！</p>\n<p>相比之下，可读的资料属于大餐，果腹之外，回味无穷。<br>《Expert One-on-One J2EE Design and Development》的作者Rod Johnson提出一个观点，好的J2EE应用首先应该是一个好的Java应用。<br>如此类比，一本好的技术图书首先应该是本好书，一篇好的技术文章首先应该是一篇好的文章。</p>\n<p>没有人愿意品味字典中用词造句，同样，也没有人愿意品味生涩的文字。<br>所以，可用的资料只要内容真实，文字是否优美倒在其次。<br>可读的资料往往需要细细品味，文字背后除了技术，作者融入其中的个人体会常常也能使人受益匪浅。<br>当然，我们不能指望所有的技术资料都写得可读性极强，就像不能期待字典同金庸武侠共美一样。<br>显然，社会分工是有意义的。</p>\n<p>在郑渊洁的童话中，有一个评判书籍优劣的标准：翻开任意一页，读上五分钟，如果还不能吸引你，扔了它！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402262255",
    "date": "2004-02-26",
    "time": "22:55",
    "tags": [
      "脚下的路"
    ],
    "title": "同Darwin聊天",
    "body": "<p>今天同Darwin聊了好长时间。<br>Darwin是我在实际生活中认识的、为数不多令我真正尊敬的高手，我们部门的拳头产品有很大程度是因为他才有今日辉煌，他曾经自己动手开发了一个小型的操作系统。遗憾的是，大概他已经离开我现在所在的公司。</p>\n<p>他刚刚忙完了一个项目，在C++中的程序中添加一些调试所需的信息（大概如此）。这个程序因为需要在源文件中加入一些东西，于是涉及到对源文件进行词法语法分析。大约三个星期之前，Darwin在与我聊天的时候，显得对这个项目信心不足。虽然之前他对gcc中C部分进行分析，但C++那比C复杂得多的语法有些让人望而却步。他说如果给他半年时间，他可以很好的完成，但老板给的时间只有一两个月。</p>\n<p>结果呢？他用了三个星期。</p>\n<p>每次同Darwin聊天我都感觉收获颇丰，他是我在实际生活中认识的人中在探讨技术时最谈得来的，我们俩对于许多问题的基本看法都惊人的一致，同他谈话，我会觉得研究技术就该是一件令人兴奋的事。</p>\n<p>Darwin的话经常可以引起我的共鸣，经常是他说我几年前如何如何，我就大叫我现在就是这个感觉。</p>\n<p>今天同我聊天时，说话没有了往日激情四射的感觉，大概是刚刚经过狂野开发比较疲惫的结果吧！</p>\n<p>Darwin觉得自己经过OS和编译器的锻炼，对于整个计算机软件结构的认识又有一个提升，现在这些东西在他的心目中，早已不再像从前那么神秘。做到现在的份上，实现一个软件对他来说，可能只是一个时间和耐心的问题。他有时会觉得，许多软件让他佩服的并不是作者如何实现了某种令人叫绝的技术，而是作者的耐心。几年前看过一篇文章，作者写到一个软件写到最后，并不是在于谁实现了了强大的功能，调用了未知的API，而是耐心的比拼。</p>\n<p>Darwin说自己现在已经不像从前那样对技术细节非常感兴趣了，做了很多，看了很多，功能实现彼此有太多相通的地方，他现在所要解决的问题本身，我戏言他应该做Java了。</p>\n<p>他偶尔会惊讶于自己学习新知识的速度，对于自己在三个星期完成自己认为半年才能完成的项目，他感觉非常吃惊。细想一下，Darwin认为这是一个技术积累的原因，毕竟技术的相通之处太多。于此，我也有一些感觉，现在学习一些Java方面的新知识，我感觉自己已经可以很快的上手了，但对于研究低层技术，我并没有太多的感觉。</p>\n<p>也许以后可以考虑去做集成电路了，Darwin的这个想法让我有些吃惊，做到现在，对于软件实现，心中的疑惑越来越少，反倒是每每写驱动程序的时候，只能通过手册的指令写程序，对于指令的来龙去脉却并无感觉，所以，集成电路应该是个解惑的方向。他的想法让我想起以前看过的一个牛人的故事，从最开始做应用软件逐步转型，最后去做了芯片。这是一种黑客解惑的追求。</p>\n<p>在我看来，Darwin现在对于技术比较淡然，做过几年的程序之后，对于软件是什么样子已经有了一个比较完整的认识。Darwin现在的境界是我比较向往的，曾几何时，我投身软件开发为的不也是解心中之疑惑吗？常常埋头开发时，竟忘记了自己最初的方向。</p>\n<p>每每同Darwin聊天能给我带来一次思考，看到自己的不足。</p>\n<p>走好自己的路！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402242212",
    "date": "2004-02-24",
    "time": "22:12",
    "tags": [
      "脚下的路"
    ],
    "title": "守、破、离",
    "body": "<p><a href=\"http://alistair.cockburn.us/\">Alistair Cockburn</a>，世界顶级OO专家，、《Surviving Object-Oriented Projects》以及Productivity 大奖图书《Writing Effective Use Cases》（2001）、《Agile Software Development》（2002）的作者。</p>\n<p>他的主页上有这样三个汉字：“守”、“破”、“离”。<br>对此，他给出了这样的解释：<br>对于用例的初学者来说，肯定要先遵守一定的规范，经过一定时间的使用之后，用例编写者就可以尝试以不同的方法编写用例。</p>\n<p>用一个具体的做面包的例子来说，守就是一个从来没有做过面包的人，就需要有一个菜单似的东西告诉他具体应该怎样去做，第一阶段“守”最重要的是我要知道菜单给我提供的是一种正确的方式，我只要照着去做，就能够做出面包来。</p>\n<p>到了第二阶段，也就是“破”的阶段，这时你不满足做普通的面包，你想做酥松的面包、薄一点或是厚一点的面包，这个时候就需要不同的配方，根据不同的方式，做出不同的面包来。</p>\n<p>到了“离”的阶段，就和那两个层次不一样了，只需凭手感，抓一些面粉，倒一些水，弄点鸡蛋在面里揉揉就能做出想要的面包。</p>\n<p>就像编程序，一开始要老老实实从第一步做起，到了技术越来越好时，你自己就能判断用什么方法来使编程满足你的需要。这样我们很容易理解为什么一些会碰到这样的情况，一名老练的程序员，他熟悉各种编程技术，用这种也可以，用那种也可以。当一个初学者来问他怎样编程时，他会说，你可以这样，也可以那样。这不是初学者想要听到的。初学者总是会问，“什么是最好的办法”，老程序员说，没有最好的方法，这样也行，那样也行。其实自然的规律总是有一个“守”、“破”、“离”的阶段，随着时间的推移，会达到“离”的阶段。<br>（以上的内容摘自《非程序员》第三十一期《Alstair Cockburn与UMLChina交流会》）</p>\n<p>虽然Alstair Cockburn说的是用例的初学者，但其内涵确完全适用用于如我一般的小程序员。<br>很是敬仰这位大师级的人物，短短的一段话，把一个规律性的东西解释得如此清晰。<br>很遗憾，迄今为止，尚未拜读过这位大师的任何一部著作，今天看在大师教导的份上，我决定把Alstair Cockburn的几本经典之作列入自己的读书计划中，只是为什么这个计划中的书越来越多啊！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402232232",
    "date": "2004-02-23",
    "time": "22:32",
    "tags": [
      "脚下的路"
    ],
    "title": "SOAP，有必要吗？",
    "body": "<p>今天在部门内部做了一次Web Service的培训。</p>\n<p>本来这个培训去年就要做了，只因为去年实在太忙，四个月出差在外的滋味不好受。<br>讲的东西都是我多半年前掌握的一些东西，现在看来，不够新鲜。</p>\n<p>要不是前不久接着在CSDN上回答一个SOAP开发的问题写了一个《Web Service开发的层次》，我都快把Web Service的知识压箱底了。</p>\n<p>在讨论的过程，一个同事问了一个很有趣的问题，Web Service为什么要用SOAP？<br>我们从协议层往上来看，承载协议一定是不能少的，否则Web Service岂不成了空中楼阁。<br>再来看XML，XML相对于普通编码的好处，在于用文本的方式描述出协议的内容，增强了可读性。<br>SOAP？先跳过去。<br>看看WSDL，WSDL是用来描述Web Service，要用函数的话就要声明，这也是显而易见的。</p>\n<p>回过来看SOAP。<br>SOAP到底好在哪呢？因为它定义了envelope、header、body的结构，一个站不住脚的理由。</p>\n<p>SOAP之外，还有一种以XML实现的通信，就是人们常说的XML-RPC。<br>XML-RPC就是一种用XML作为内容的通信方式，可能与SOAP不同的在于，SOAP定义了一种格式，而XML-RPC没有。<br>其实准确的说，以SOAP通信也是一种XML-RPC。</p>\n<p>如果为SOAP找个辩护的理由，除了它是个标准广为采用的标准之外，只能从它具备的结构入手了。<br>可惜的是，我前面已经否定了这个理由。</p>\n<p>冥思苦想，不得其解。<br>找找高人言论吧！<br>结果得到的是一篇SOAP无用论——<span class=\"ts\"><a href=\"http://www.artima.com/webservices/articles/whysoap.html\">Why Use SOAP?</a><br></span><br>呵呵，SOAP的幽默。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402192250",
    "date": "2004-02-19",
    "time": "22:50",
    "tags": [
      "我眼看世界"
    ],
    "title": "绿色编程",
    "body": "<p>先来说一点与编程无关的东西，昨天中国队踏上了第八次冲击世界杯的行程。<br>我对这支新国家队一直缺乏关注，鉴于这场比赛和世界杯联系在一起，我才坐到电视机前。<br>赢了的比赛，出乎意料的过程，理想的结果，不理想的比分，这是我对这场比赛的观点。<br>中国队一如既往的失误频频，非常符合我心目中的中国队形象，但能够偶尔打出一些流畅的配合，出现一些诸如脚后跟传球，让我有些惊讶。全场比赛科威特没有一脚射门，只能用这支队伍实力太差来解释，很难想象这是昔日的西亚劲旅。李玮峰脸上被吐了痰居然没有动手，我诧异于中国队的成熟。<br>小组赛在我心目中是个无足轻重的角色，现在的中国队比起施大爷那支折戟沉沙于伊比尔德的中国队已经成熟多了。</p>\n<p>好了，切到绿色编程的话题。<br>提起绿色，人们首先想到的应该是环保，而绿色编程是我想起一个形容程序环保卫生的名词。<br>我现在多半是在用IntelliJ IDEA写Java程序，通常IDEA会在静态的状态下对程序进行一些分析，如果有语法错误，它会以红色提示出来，遇到了一些不是错误但可能会有问题的地方，它会以黄色警告，而绿色代表了静态分析中的万事大吉。<br>通常的情况下，红色的部分一定要进行处理，霸王硬上弓得到还是编译器的语法错误。一旦红色消声匿迹，编译器基本上也就不再滋事，程序就可以跑了。</p>\n<p>问题在黄色。<br>先来看看可能出现黄色的几个例子：import的类没有用到；多余的类型转换，变量赋值而未使用，private方法或变量没有使用，某些变量或是参数可以声明为final等等一般来说，黄色的警告并不意味着问题，程序多半可以悠哉游哉继续跑下去。黄色更多的是代表着一种程序设计风格。</p>\n<p>程序设计风格对程序员来说意味着什么呢？<br>贝尔实验室的大师级程序员Brian W.Kernighan和Rob Pike在他们的经典之作《程序设计实践》开篇第一章讨论就是风格。大师们如是说：“风格的作用主要就是使代码容易读，无论是程序员本人，还是对其他人。好的风格对于好的程序设计具有关键性作用。”</p>\n<p>积沙成塔应该是一个人人都清楚的道理，任何的软件都是由一行行的代码所组成，好的程序风格既是编码者本人良好素质的体现，也是对于阅读代码者的尊重。代码风格与代码质量密切相关。<br>Effective系列之作的火爆充分反映了程序员们对于编写高质量的渴求，谁不希望自己超越平凡呢！<br>实际上，好的程序设计风格同好的程序设计实践和一些编程惯用法之间很难做出明确的区分，比如以多态替代if-else是风格还是什么呢？<br>拥有良好风格的代码，使得基于此编写烂代码成了困难，软件质量将由此得到提升。</p>\n<p>代码风格直接影响到后期的维护。<br>没有良好的程序设计风格，胡乱拼凑出来的代码绝对是跟后来的维护者过不去（多半这个维护者就是编码者本人）。所以，经常有宁愿重写不愿阅读的说法。看看一些开源作品，精致的代码是许多项目持续稳定发展的基础。</p>\n<p>当然，并不是说好软件的代码就是那么的完美无缺，拜读一些开源精品的时候，偶尔也会遇到一些让人难以恭维之处。</p>\n<p>好的程序风格绝不是一两天就可以养成的，更多需要日积月累。<br>既然能够现如今已经有了许多可以助我们一臂之力的工具，我们更有理由写出高质量的程序。<br>一切从细微之处入手，让黄色成为过去，开始绿色编程。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402162108",
    "date": "2004-02-16",
    "time": "21:08",
    "tags": [
      "脚下的路"
    ],
    "title": "内力的风险",
    "body": "<p>晚上吃饭的时候，几个兄弟谈起了部门的另一个项目。</p>\n<p>这个项目是我们部绝对的拳头产品，毫不夸张的说，我们部以前完全靠这一个项目养活着。1.x的版本为我们部门打下了天下。2.x版本和我一起开始在公司的生活，迄今已一年半有余，于情于理都是开发新版本的时候了。和我同屋的兄弟是这个项目组的主力之一，近来聊天的时候，他常常和我谈起项目升级的一些问题。编码之前一定要弄清楚要做些什么，于是他们项目组最近一直在疯狂讨论新版本应该具有哪些特性，按照这位兄弟的说法，从讨论的内容上来看，这将是一个“上天入地、无所不能”的版本。</p>\n<p>问题随之而来，这么强大的东西由谁来做？这似乎是废话，当然是我那位兄弟所在项目中的那班善男信女。在业务方面，他们绝对个个是专家，他们甚至比制定规范的人还清楚，但在技术方面……</p>\n<p>一个产品，在其初级阶段，只要完成最基本的功能就足以赢得一切，那时没人知道这是个什么东西，没人会对它提出什么高要求，这个时候的市场应该是最为暴利的。这个时候对于技术也没有太高的要求，于是人人能做，这也就是为什么一旦有了一样好东西，随即就有大量模仿之作问世的原因了。</p>\n<p>社会在发展，人们在进步，以抢钱为目的来到这个市场的人们渐渐发现，钱也不是那么好挣的。于是有人要想新的生财之道：<br>换到新的抢钱市场，这么做给人的感觉是随波逐流，哪里有钱哪里跑，结果哪里都没赚着。<br>降价，现在的彩电市场是最好的表现，结果是我没好，你也别想有，N败俱伤。<br>提升产品的品质，用那些即便人们用不到的东西来赚钱，微软的系列产品是个好例子，Office 97对于大多数人就够用了，可它依然不依不饶推出新品，让人掏钱买那些用不着的东西。</p>\n<p>我不否认，最后一招的高明，微软就是靠这个成就的帝国神话，但这着却并非人人可为。再进一步除了要有好的想法，更要有技术作为最基本的保障。</p>\n<p>初中的时候，政治老师讲起助人为乐的时候，提出一个前提，要有助人为乐的本领。<br>技术进步何尝不是！<br>当产品晋升到比拼内力的时候，就不再是任谁都能做的了，这时候需要的是专家。</p>\n<p>我们部的这个项目面临就是这样一个处境。<br>经过几年的发展，这个项目已经不再是那个最初的产品了，如果不能够进一步提升内在品质的话，在未来的市场上打拼将十分艰难。</p>\n<p>这个项目的未来发展方向是分布式系统。系统本身需要支持大业务量的处理，为了将来能够更好的扩展，所以既定方向中还要实现集群。</p>\n<p>这个方向的专家们，你们也许并不觉得这是多复杂的问题，但我们这帮资质一般，又没有经过系统培训的家伙，这些概念只是从别人那里有所耳闻，真的轮到自己来实现，需要恶补的东西太多了。</p>\n<p>我的那位兄弟近来在看一些CORBA的东西，他觉得应该在项目中运用CORBA来实现所谓的分布式。<br>并不是我低估他的能力，CORBA本身就是一个十分复杂的东西，也正是这个原因他才一直未能深入普通程序员的生活中，也才给Web Service蓬勃兴起的机会。以大家普通的资质，想在短时间之内就掌握CORBA的精髓显然不太现实，画龙画虎难画骨，徒俱形似，只能给自己的未来添麻烦。<br>更为关键的问题在于，CORBA是否适合项目需要。他觉得也许用得上，他只是简单了解了一些CORBA的基本概念，对于CORBA的适合如何使用并不清楚。所以，他的说法不得不令人怀疑。<br>他们项目组其余几个人对待技术的态度，同他比起来，差了许多，就技术而言，他也许已经是项目组中最好的了。</p>\n<p>具体技术之外，对于软件架构的设计，这个兄弟对于软件设计也并没有很多的经验。和我同来的他，是在2.x最初开发已经完毕的情况下加入项目组的。没有参与到项目最初的设计中，让他错过了最好的提升个人能力的机会。所以，对于原有系统，他并非100%的成竹在胸。真正了解一个系统的是这个系统的设计者，遗憾的是，这个系统的设计者已经离开了公司。无可否认，他很努力，机缘巧合是人力无法控制的。</p>\n<p>这或许就是风险吧！</p>\n<p>想到我们的系统，经过了1.x的混乱，2.0的稍显有序，应该说我们的系统正在进步。我也一直想让这个系统再上层楼，但以我目前的水平而言，很难，所以我必须研究一些已有的东西，从中借鉴一些比较好的东西。超越的前提是模仿。比之他们的项目，我们项目还处于初级阶段，时间给我们留有提升的空间。</p>\n<p>这个项目做出来对于个人和公司绝对都是极具价值的，因为它不再是人人能做，个体之间的差距可以就此体现，个人的能力与价值也将由此得到提升。公司也可以凭借这个产品更好的占领市场。</p>\n<p>前提是做出来。<br>祝这个项目好运！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402141959",
    "date": "2004-02-14",
    "time": "19:59",
    "tags": [
      "脚下的路"
    ],
    "title": "情人节离开的兄弟",
    "body": "<p>宿舍的一个兄弟在情人节这天离开了公司。他和我一样在公司完成的毕业设计，那时我们就在一个宿舍。算起来，我们在一个宿舍的时间以近两年。“天下无不散之筵席”的道理我早已懂得，而且从来的那一天开始，我就知道这些兄弟不可能都永远在公司干下去。去年年中的时候，有几个和我一起入司的家伙离开了，由于彼此并不熟悉，那种感觉也并不强烈。当自己宿舍兄弟离开的时候，我才真正有了感觉。<br>之前更熟悉的是，宿舍的一群愤青围在一起抱怨公司的种种不是，叫嚣自己有一天炒了公司。那是一种完全的阿Q式自我满足。终于有人踏上了离开的列车，这种感觉变得如此真实。</p>\n<p>回头看看，毕业到现在已经一年半有余。公司早已不再是初来乍到时想象那般让人充满无尽期待的舞台，自己也不再期许能为公司做出巨大的贡献。再美好的愿景在无情的现实面前也就不再美丽。<br>扁鹊三兄弟的故事在这里得到充分的体现，程序写得越差，后来的问题越多，显得越是忙碌，在领导眼里，这个人越是能干。而活干好的人由于轻闲，在领导眼里却是那么别扭。原以为只有以体力谋生的人才需要以忙碌体现自己的能力，居然智力谋生者也需要如此。也许，在这里追求卓越本身就是一种错误。<br>不过有一点要承认，即便是现在，我依然可以在公司中学到很多东西，遗憾的是，更多的是教训，它告诉我这么做不对。怎么做才是对的呢？我无法得到答案，无论是技术还是管理。</p>\n<p>记不清是哪位说过，即便不跳槽，也不要失去跳槽的本领。<br>我有时也问自己，自己离开的话，公司的损失有多大？自己凭什么换取更好的工作？<br>《梓人传》告诉我，个人的价值完全取决于其不可取代的程度。<br>我的不可取代程度有多大呢？不大。<br>现在公司中拼命在提倡所谓的“蓝领”，对于个体之间的差异几乎是视而不见，所以，在公司的眼里，我即便离开了，也是可以随便找个人替上，不知到这是公司的“幸”还是“不幸”。</p>\n<p>早上看《执行：如何完成任务的学问》，这是一本写给管理者的书，我不是管理者，但我依然可以从中获得提升自己的东西。<br>这本书给我最大的提示是，有了想法要去做。<br>我一直是想法多于行动的人，所以迄今为止并没有做出什么有价值的东西。有想法绝不是什么坏事，没有想法就根本不会去做，没有执行的想法属于胡思乱想。</p>\n<p>最近一直在思考的问题是，我究竟应该做些什么才能将自己的价值体现出来。<br>我将自己定位于技术，所以提高自己的技术水平是必经之路。但我从来没有想过，究竟该如何提高，目标是什么，我的探索基本上提留在自己盲目的努力上。<br>我承认，比之初到公司之时，我的技术水平和对技术的理解都有了很大的长进，但这是否是我期望达到的呢？我不知道，因为我最初就没有个方向。<br>职业生涯规划并不是简单的口号，如何落到实处是其真正价值所在。<br>难得今年年初就计划今年的学习内容。本来计划换到Unix做开发，可是领导不同意，我只好继续在Java上用功。今年的学习重点就是研究几个比较成熟的产品，学习其中架构和技术实现。第一个列入计划的是Tomcat，紧随其后的是SpringFramework。如果可能，我还希望了解一下Java虚拟机的实现。</p>\n<p>毕业之前，一位老师在课堂上对我们说过一句话，“别以后失业了都不知道自己怎么失业的”。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402132257",
    "date": "2004-02-13",
    "time": "22:57",
    "tags": [
      "我眼看世界"
    ],
    "title": "微软也开源",
    "body": "<p>今天最有震撼力的一条消息莫过于，微软的拳头产品WindowsNT和Windows2000部分核心源代码泄露。<br>关于这条消息，CSDN上很快就有了大量的网友评论。<br>最让我感兴趣的评论来自于一位名叫getit911的网友“M$终于要开源了，呵呵”。</p>\n<p>近一段时间，我对开源运动、对自由软件颇感兴趣，陆陆续续看了不少相关的东西，也因此对开源和自由充满了向往。<br>微软似乎是全世界的敌人，每当人们讨论开源软件的时候，总是不忘扯出MS斥责一番。<br>我个人对MS并没有很大仇恨，毕竟日常的工作环境还是由人家提供的。比尔和保罗当年创业的故事也深深激励着当年懵懂无知的我。当年甚至对MS充满了敬仰，一直认为MS就是计算机的唯一，如同早年间许多人认为五笔就是计算机一样。<br>当Linux走进我的视野，我才知道MS的世界之外也有精彩的世界。<br>与MS复杂封闭相比，Linux带来的文化简单开放。<br>遗憾的是，时至今日，并没有和Linux有很深的亲密接触，所以只能徘徊于Linux的心门之外。<br>另一个拓展让我视野的是Java。看看Apache、转转SourceForge，众多的开源项目让我们有机会接近世界软件开发的前沿。<br>相比之下，MS一直坚守着自己阵地，封闭着自己的源代码。</p>\n<p>《开源软件文集》上的一篇文章提到了这样的一种说法，开放源码如同开放科研成果，对于人类的进步起着推动作用，可以节省大量的重复劳动。</p>\n<p>开放源码让软件开发人员喝西北风吗？<br>如果是这样，恐怕就没人原意奉献了。JBoss为大家做出了一个好榜样，源码奉送，服务收费。<br>软件业自MS创造了帝国神话之后，一直是一个暴利的行业。这也是许多软件人投身这一行的最大动力。同许多行业一样，暴利只能停留在行业初成之际，随着行业的发展和介入者的增多，暴利时代将逐步离这个行业而去。不愿意坐以待毙的软件企业势必要寻找新的经济增长点。现在看来，软件服务成为了软件业的一个方向。技术出身的软件一方面要努力提升自身的技术水平，另一方面要在这个追求个性的年代，为自己的客户提供更加个性化的服务，满足用户的特殊需要。</p>\n<p>扯远了，我现在距离思考软件企业生存的管理者的身份尚有十万八千里的距离，想多了，累！</p>\n<p>回到程序员的身份。<br>事实上，即便有了源码也不见得就可以获得作者的全部思想。今天研究SpringFramework的时候，以为自己已经看明白了。回头再读《Expert One-on-One J2EE Design and Development》，忽然发觉原来作者在设计的过程中经过了许多的思考。源码实际上只是思考的最终结果，作者在源码的形成过程中必然要经历许多权衡。从学习软件的角度来看，正是这样的反复过程使得程序员对软件开发的认识有了本质上的提高。<br>以我个人的实践而言，之前所编的代码基本上都是在人家设计好的结构上进行，顶多是在局部提出一个自认为比较不错的解决方案。新系统的设计让我彻底体会把握全局的艰难，上至系统整个架构，下至系统局部细节，如何让各个部分彼此配合默契着实让我经历一番煎熬。新系统设计开发前后一个月左右的时间，是我感觉最累却收获最大的一个月。虽然，现在项目的大面积编码已经结束，但我的心中却已经有了些新的想法。<br>以前不是很明白为什么做好一个软件，需要N年的时间，难道不能一开始就做好吗？事实给我的答案是，一来个人经验需要时间积累，二来不可能在一开始就知道需要的一切，更重要的是，在一个版本完成之后，脑子中就会产生更好的想法。</p>\n<p>许多人对于泄漏出来的源码有着浓厚的兴趣，纷纷要求提供下载。在我看来，随风跟潮的占了大多数，估计down的人不会少，真正读的恐怕就没几个了，这一方面是个人能力的问题，另一方面，中国IT之浮躁是如我一般身处其中的IT个体体会颇深的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402112229",
    "date": "2004-02-11",
    "time": "22:29",
    "tags": [
      "向上走"
    ],
    "title": "Java路漫漫",
    "body": "<p>自以为对Java中基本的内容了如指掌，今天所发生的一切告诉我，Java路漫漫啊！</p>\n<p>在我们的项目中使用了大量的枚举类。众多枚举类的最初雏形来自当年利用Castor做XML到对象映射时生成那些枚举类。</p>\n<p>每次写一个新的枚举类，基本上都是把一个写好的枚举类复制过来，把枚举项改一改就告完工。久而久之就产生了大量的重复代码。以我通常的习惯，如果重复代码必然会遭到我的当头一击，可偏偏这些枚举类得到了我的纵容。于是，添加新的枚举类成了真正的体力活。</p>\n<p>终于，我幡然省悟，决心治理这些毒瘤。</p>\n<p>处理这种重复类，最好的办法就找出公共部分，抽出一个公共基类，说干就干。</p>\n<p>枚举的应用很广泛，所以有很多值得借鉴的解决方案。我也找到了两个帮手，它们是JDK源码中的java.util.logging.Level和Apache Avalon项目的org.apache.avalon.framework.Enum。</p>\n<p>很快，一个枚举基类完成了，其基本的几个字段是这样的：<br>private static List memberList = new ArrayList();<br>private static int counter = 0;</p>\n<p>private final String name;<br>private final int value;<br>private final String resourceBundleName;</p>\n<p>其中name是这个枚举的一个标识，value代表着一个整数值，在C中枚举都对应着一个整数值，resourceBundleName可以用来实现国际化。<br>memberList用来存放具体某个枚举类的所有枚举值的内容，通过这种方式，可以是对枚举值的遍历，或是根据name或是value构造一个枚举值的工厂方法。counter是一个计数器，其作用就是在不设置枚举值的value的情况下，下一个值的value比上一个值大1，这是一种模仿C中枚举性质的实现方式。</p>\n<p>编写简单的测试，运行，没问题，心情不错，吃午饭去！</p>\n<p>下午重新打开这个基类，突发奇想：<br>对于不同的具体枚举类，memberList应该不同，为什么？想啊！static字段应该是对于每个类来说只有一个，所以，不同的具体类应该有不同memberList。写个测试验证一下。<br>测试不通过？怎么会？<br>嗡！大脑短路！</p>\n<p>仔细想想，bingo！<br>static字段对每个类只有一个确实不假，但问题是这个类是谁？我之前的理由中，犯了一个很低级的错误，认为这个应该是子类，出现这种认识的一个原因在于我认为继承的时候，static字段也应该继承到这个类中来。</p>\n<p>这个类应该是基类！<br>从类加载的角度分析一下，一个类加载的时候会把和类相关的所有的内容放入到方法区中，与类相关的内容其中就包括static字段，类的对象通过一个地址定位这个方法区。如果涉及到对类的内容进行访问就通过这个地址找到方法区中自己类型相关的信息。<br>子类加载的前提是它的基类已经加载，而基类加载的时候，通常不知道子类的信息，如同我们编写一个基类的时候，并不知道将来会有哪些类继承这个类一样。所以，它会把所有类信息放到它自己的方法区。<br>就上面枚举基类而言，memberList一定在这个枚举基类的方法区中，而并不会出现在子类的方法区。<br>从语法的角度来看，static变量我们可以通过类来访问，换句话说，我们可以在没有子类的情况下对基类的static字段进行访问，如果每个子类拥有一份memberList，那么通过基类访问的会是哪个呢？所以，显然不可能。</p>\n<p>要实现每种子类都有自己memberList，别无它法，只有在每个具体的子类中声明各自memberList。</p>\n<p>突然想起Avalon中Enum的实现，它有一个构造函数是这样的<br>protected Enum( final String name, final Map map )<br>其中的map所起的作用等同于memberList。<br>开始的时候，我还在笑话Enum实现的笨拙，现在彻底明白了，这个构造函数的作用就是让基类在完成构造对象之后，把枚举值放入这个存储之中。五十步笑百步，迂腐！</p>\n<p>或许看官们会奇怪，我的程序如何通过自己的测试。这一方面有自己测试不完整的原因，另外一方面，虽然在原来的实现中memberList对于所有的子类只有一个，因为每次插入的时候，都是一个简单的add，它会把这个对象插入到memberList的最后，而memberList add方法的参数是Object，所以，插入的内容即便错误也不会发现。强烈期待咖啡猛虎（JDK 1.5，代号Tiger）的到来，至少新增的泛型语法可以减少犯下这种错误的可能性。<br>查找的时候，只要两个枚举值的name不同，就没有问题，而恰恰我的测试中就没有相同name的枚举值。<br>TDD和重构都在强调测试的重要，经过我的实践，证明了一个道理，测试在用以证明别人的正确性之前，必须保证自己的正确性。</p>\n<p>不怕出问题，就怕找不到问题的根本原因。找到问题的原因，改起来还是很快的。有一点不可否认，改过的代码因为每个子类都要有自己的memberList，所以从代码效果上来看，明显不如原来的代码那么优雅。<br>没办法，谁让static是OO中不大不小的一个瑕疵呢！</p>\n<p>JDK 1.5中引入了一些新的语法，其中就有这里提及的enum，有了真正的enum，我的枚举基类就算彻底的Game Over了，换句话说，这个枚举基类可是一个真正的费力不讨好的东西。不过这只咖啡猛虎小荷才露尖尖角，等到实际应用还要好长的一段路要走，所以这个枚举基类还是可以苟延残喘些日子。</p>\n<p>Andrew Koenig和Barbar Moo夫妇在《C++沉思录》中提出的观点，“语言设计就是库设计，库设计就是语言设计”，对于语言本身良好运用可以极大提高程序的质量，随着自己实践的增多，越发可以体会到这句话的真谛了。</p>\n<p>Java路漫漫其修远兮，吾将上下而求索！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402102304",
    "date": "2004-02-10",
    "time": "23:04",
    "tags": [
      "我眼看世界"
    ],
    "title": "G-Roller",
    "body": "<p><a href=\"http://cosoft.org.cn/projects/groller/\">G-Roller</a>是我参与的第一个开源项目。<br>G-Roller是由<a href=\"http://gigix.blogdriver.com/\">gigix</a>发起的一个开源项目，gigix这样描述它。<br>G-Roller是基于J2EE的weblog服务器应用，支持Blogger API和Meta-Weblog API发贴、RSS feed、在线浏览及张贴。除了实现weblog的功能之外，G-Roller致力于展现J2EE设计、开发的优秀思想和技术。</p>\n<p>抛开虚的东西不谈，看看G-Roller涉及到的内容就可以看出它是多么激动人心的一个东西——至少对于一个J2EE开发人员如此。</p>\n<p>首当其冲是Weblog，千万别说不知道Weblog，你现在正在看的这个就是。Weblog简称blog，写blog的人成为blogger，它有个很棒的中文名“博客”，博学之士。在网上四处转转，现在blog俨然已经成为一种时尚。我不想多谈blog的意义，因为已经有了太多。如果我犹抱琵琶的介绍激起了你的一丝兴趣，我有一篇文章推荐，gigix的<a href=\"http://www.csdn.net/develop/read_article.asp?id=21269\">《懒惰者的阅读、写作与偶像崇拜》</a>，我对blog的兴趣就是从这里开始的。</p>\n<p>回归技术，G-Roller的实现采用IoC的基本思想，使用<a href=\"http://www.springframework.org/\">SpringFramework</a>完成组件的拼装。我们项目的底层代码就是G-Roller中借鉴过来的，正是有了这个基础才使得上层的开发简化了许多。我也是在开发的过程中加深了对SpringFramework和G-Roller的认识。这个部分也是整个G-Roller中我最熟悉的部分。</p>\n<p>G-Roller的表现层通过<a href=\"http://jakarta.apache.org/struts/index.html\">Struts</a>完成。虽然现在看来Struts已经算不上什么新鲜东西了，但其受欢迎程度却丝毫不弱。我们部门从2003年年初开始，在管理系统中引入Struts，从根本上改变原来的“JSP中访问数据库”的悲惨景象。遗憾的是，我并没有机会在系统中实际运用Struts，所以对Struts的理解比较浅薄。</p>\n<p><a href=\"http://www.hibernate.org/\">Hibernate</a>是G-Roller中完成持久化的工具。Hibernate是一个OR mapping的工具，可以完成对象到数据库的一个映射。正好今天部门开会讨论Hibernate，研究在项目运用Hibernate的可行性。比较悲哀的是，大家更多的关注在于如何用Hibernate做数据访问，也就是大家更多的是把Hibernate简单当作JDBC的替代品。这让我有种只见树木，不见森林的感觉。其原因我想大概是大家更习惯于以数据库的方式理解问题，而对于OO知之甚少，何谈OR mapping了。</p>\n<p>从开发人员的角度来看，G-Roller是一个非常棒的学习教材，它展示了许多优秀的思想和工具。从这一点上来说，研究G-Roller绝对是物有所值的。通过参与G-Roller，与gigix进行交流，我确确实实学到了很多东西。gigix的想法和眼界使我受益匪浅，从这个角度来看，gigix是个好老师。：）</p>\n<p>遗憾的是，前一段时间工作实在太忙，以致于好长一段时间都没在关注过G-Roller。</p>\n<p>借由一个关注G-Roller的朋友给我发来的一封求助mail，我今天又重新拾起G-Roller，所以有了这篇《G-Roller》。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402082310",
    "date": "2004-02-08",
    "time": "23:10",
    "tags": [
      "脚下的路"
    ],
    "title": "体系职位的思考",
    "body": "<p>公司准备进行体系职位改革。<br>周五的时候开了个“技术体系职位评估及能力提升规划宣导会”，昨天收到了一封关于评估的mail。</p>\n<p>如果说大会还不能激起我们对这个问题的关注，那么这封mail成了昨晚宿舍论坛的一个导火线。<br>这次的评估采用的公司建议的方式对职位进行申报，根据公司一贯的作风，所谓建议基本上就是定到那了，想职位再高一点可能性趋近于零。激起我们这潭死水的石头就是不同的建议，我们宿舍一个兄弟觉得给自己的建议低了，于是愤青们纷纷把肚子里的苦水倒出。</p>\n<p>中国人善于糟蹋好东西，看看我们现在的教育、看看不幸着陆中国的MBA、微软认证等等不难发现这句话的正确性。在我看来，体系职位改革是一件好事。如果能够真正的落到实处，无论对公司还是对个人都有好处。能引起我们争论的就在于换汤不换药的本质。本来体系职位应该是一个人与个人能力与绩效挂钩，而并非与工作年限和学历直接相关。</p>\n<p>从我们现在的“建议”来看，基本上是按照现有工资水平往所谓的职位上去对应。如果说现有工资水平能够反应一个人的能力和绩效，那么也就不需要什么调整了。在这里，许多的老员工和研究生拿的工资都是我们这帮本科毕业没几年家伙的几倍，而很多人干的活的却无法让人恭维。由于他们的原来的工资水平比我们高，所以，在“建议”的时候，理所当然级别就比我们高。一个兄弟说他旁边的一个研究生干活很费劲，有一次，干了一个月都没拿出东西来，结果领导调他去帮忙，他用两个星期搞定了。“建议”的时候，这位研究生比我的这个兄弟高了一个级别。</p>\n<p>就我个人而言，“建议”已经超出我的预计，单从这个角度来看，我没有什么值得抱怨的。人比人，气死人。问题源自比较。看到那些无法拿出令人信服表现的老员工和研究生的级别在自己之上，我也觉得非常气愤。想想自己每次为了项目辛辛苦苦费尽心力，总是想方设法让项目做得更好一些，而这帮家伙却每每草率了事。年底面谈的时候，负责人和我说过，各人对自身的要求是不一样的，可能在他们眼里90分的活在我眼里只有60分，我可以接受这种说法，但这意味着我就因此而同意我们付出的努力是一样的吗？显然不可能。</p>\n<p>从公司的角度来考虑，这个体系职位的改革是一次很大的变动，可能影响到公司的很多方面。让公司尽可能少的受影响应该是比较现实的一个考虑。所以在“建议”的时候，就会把一些员工按现有薪资水平往职位上去对。这样可能对原有的体系影响较小。</p>\n<p>但公司忽略了一点，这种做法实际上多少有一些奖懒罚勤的作用。正如一个兄弟所说，原来的差距只是“利”上的，因为自己来得晚学历低也就罢了，现在在“名”上也有了差距，对自己的打击就更大了。公司辛辛苦苦保护的是那些比较稳定的员工，但从公司多年积累下来状态看，这些员工多半都是能力要差一些的，对项目顶多只能起到锦上添花的作用，而有能力的一批人往往因为无法得到自己所需而最终选择离开。这次的做法还要保护这些人，伤的还是那些有能力的。从公司提出的种种口号来看，它习惯于认为人和人之间没有区别，而忽视个体之间可能具有的差异。这也就是公司虽然很大，但并没有什么技术可言，项目总是由一批新人来支撑着，这或许对新人而言是个机会，但对公司而言绝不是什么好现象。鉴于中国的现状，我觉得公司继续生存下去不成问题，但再进一步获得更多的尊敬很难，除非有新的改变。</p>\n<p>在我看来，二月份定级，三月份根据级别调整工资之后，会有一批人因为对这个级别的不满而选择离开。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402062246",
    "date": "2004-02-06",
    "time": "22:46",
    "tags": [
      "脚下的路"
    ],
    "title": "咖啡猛虎、状态机和不认识的师兄",
    "body": "<p>JDK 1.5 Beta版正式出炉是昨天的消息了，懒惰的我昨天就应该写这篇Blog，就像我应该在2003圣诞节那天把JDK 1.5试用版出炉的消息写出来一样，遗憾的是，我都没做。<br>我赶在得知此消息的第一时间就把它down了下来，用了一个下午的时间，写了几个例子，体验了一下。<br><br>虽然所谓的新特性早在去年年中的时候，我就已经有知晓，但真正编写几个这样的程序还是感觉不错。<br>仔细想想，其实新东西并不多。<br>泛型是C++早就拥有的特性，近两年泛型比较火，以致于Java、C#这些后起之秀也不得不把它加进来。同C++的泛型不同，Java的泛型只是语法上的简化，经过编译器之后，还是和原来的直接用Object的方式没有区别，而C++则是直接展开，相对来说，效率要高一些。时间和空间的问题，Java通常会不吝惜时间的。<br>for循环的增强在去年刚接触的时候还有一些好奇，经过对C#的了解，就不足为奇了。学过Perl，才知道原来两家都是抄别人的东西。<br>经过《Effective Java》的谆谆教导和自己经常定制枚举的实践，类型安全的枚举也已深入我心了。<br>变参虽然用得少，从C过来的我也不会对此有何惊讶。<br>了解一点C#，接受基本类型的Autoboxing和Auto-unboxing就显得那么自然而然，不过是语法上的一个sugar而已。<br>静态导入是稍微新鲜点的东西，同普通的导入只导入类相比，它导入了类的成员，鉴于通过类访问，所以只能导入静态成员，因为非静态成员必须通过类的实例才能访问。<br>唯一让我感觉难以理解的是Metadata，虽然对Metadata的耳闻也算不少，但真正用遇见了才觉得很神奇，照着例子抄了一遍，运行了一下，没问题，但一点没看懂。只好去down JSR的规范来看看究竟神奇何在。等研究一下再说吧！<br>至于库的扩展，只是一个多了一些API而已，需要的时候才会用到，我对此并不是很关心。</p>\n<p>昨天的说完了，该今天的了。<br>早在去年我们系统刚刚开始做1.0版的时候，我就提出了一个状态机的想法，但究竟如何运用状态机来做，我也不知道。系统逐步改进到了现在，我忽然发现状态机确实是个不错的想法，于是，以状态机实现的念头又冒了出来。<br>一个同事推荐给我一个状态机的框架<a href=\"http://unimod.sf.net/\">Unimod</a>，我用了一下午时间研究，理出一个大概思路。鉴于Unimod刚刚出了Alpha版，我们不会把它真正用到系统中，但其中对于状态机的实现倒是可以参考一下。说起来很简单，就是来了一个事件之后，根据当前的状态做相应处理得到一个新的状态。<br>Unimod真正有趣的是它可以利用UML来生成状态机，其中集成了ArgoUML，我的兴趣不在于此，所以，没有深入进去。</p>\n<p>晚上在网上闲逛，发现了一个网站<a href=\"http://www.linuxsports.com/\">http://www.linuxsports.com</a>，站长居然在和我的大学老师一起翻译《Linux Kernel Development》，曾经听老师提起过，算起来，也算是我的师兄，可惜大学里有这样的高人我却不曾认识。于是，赶紧发了mail过去，希望能够结识不曾相识的师兄。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402051111",
    "date": "2004-02-05",
    "time": "11:11",
    "tags": [
      "向上走"
    ],
    "title": "Web Service开发的层次",
    "body": "<p>Web Service是最近几年比较火的一个东西，它带来了一大堆的新名词，所以显得比较炫。看透其华而不实的表面，它也就不再神奇。下面的讨论均以Java为参考。</p>\n<p>1 访问一个Web Service实际上可以看作调用一个函数，唯一不同的就是这个函数是远程的，这么一说，它和RMI就没有什么本质的区别了。<br>&nbsp; 既然是一个函数，当然要有函数的声明了，完成这个工作的就是WSDL，它详细的定义函数的原型，包括函数名、入口参数、出口参数，这就是WSDL中opertion完成的工作。<br>&nbsp; 既然是一个远程的函数，还要涉及与远程地址的一个绑定，这是WSDL中service的任务。<br>&nbsp; Axis是一个可以通过WSDL生成相应访问代码的开发包，JBuilder中将它集成了进去，通过Wizard的方式简化了原本需要在命令行中手工完成的操作。</p>\n<p>2 既然是远程访问，就一定要有一个访问协议，Web Service的访问协议就是SOAP，SOAP建立在XML之上，不同的就是对XML原本没有限制的格式加上了一些限制，需要有envelope，在envelope中，还要分header和body。<br>&nbsp; 如果利用SOAP开发Web Service的程序，那就需要根据WSDL的定义来自行组装SOAP包，这显然要比利用WSDL直接面向Web Service开发要复杂一些。<br>&nbsp; JAXM是一个利用SOAP进行通信的开发包，它简化了SOAP消息的打包过程。</p>\n<p>3 SOAP是建立在XML之上的，那么显然XML的开发包同样适合于SOAP。<br>&nbsp; 在这个层次上开发Web Service，除了要完成上一层的工作外，还要自行按照SOAP的格式组装SOAP消息，这显然又增加了工作量。<br>&nbsp; XML的开发工具就比较多了，从最简单的SAX和DOM到DOM4J、JDOM，还有不少XML到对象绑定的工具，如JAXB、Castor等等。<br>&nbsp; 其实，不考虑Web Service，完全用XML做通信协议的情况也并不少见。知晓XML-RPC的存在，就不难理解了XML做通信的含义了。</p>\n<p>截至到这里所讨论的内容，Sun提供了JWSDP（Java Web Service Developer Pack），其中包含从XML解析到WSDL生成的全套解决方案。</p>\n<p>4 上面讨论的所有东西实际上都还停留在传递消息的内容上，并未涉及通信的过程。不要一看到Web Service的Web就想当然认为它只能通过HTTP来传输。前面的讨论可以看出，所有的消息内容与传输并无直接关系，所以，无论是以HTTP传输，还是SMTP或是自定义的协议都没有问题。<br>&nbsp; 在这个层次上开发Web Service，前面的种种险阻之外，还要完成对XML的手工解析工作。<br>&nbsp; 这里还是以最常见的HTTP方式来讨论。&nbsp; <br>&nbsp; HTTP的开发就将Server和Client区别对待，Server的实现通常的选择是Servlet，让Web Server替我们完成HTTP协议的解析可以省去我们很多的作。Client的实现可以选择JDK自带的Http Client，Apache的Jakarta项目下的Commons子项目也提供了一个HttpClient。</p>\n<p>5 无论是HTTP还是SMTP，抑或是自定义协议，归根结底都是应用级的协议，底层的实现都是由Socket完成。到了这个层次基本就是原始时代了，什么都没有，一切都要手工完成。<br>&nbsp; 在这个层次上开发Web Service，所有前面的困难都要一一经历，此外，还有协议的开发等待着不幸至此的人们。<br>&nbsp; 到了这里，也不需要其它的工具了，JDK自带的Socket可以保打天下。</p>\n<p>6 还想往下吗？再往下就是操作系统的实现了，Java的平台无关就失去了意义，也超出了我目前所了解的范围，到此打住吧！</p>\n<p>前面所提及应该算是Web Service的一个基本知识结构，这里并没有讨论UDDI等等的内容，一来我对它并不了解，二来那应该属于应用，不应该算Web Service实现中。</p>\n<p>虽然我们可能不会从最下层开发Web Service，但遇到底层的问题的情况却在所难免。<br>我就曾经在开发一个Web Service应用的时候，被人抓住HTTP头中的SOAPAction大小写与某个所谓的规范不同，我查了半天HTTP规范和SOAP规范，知道了HTTP是区分大小，而SOAPAction就是应该这么写，据理力争，指出所谓规范的错误。</p>\n<p>经过前面的讨论，我们可以看出，Web Service并没有什么神秘可言，所有的东西都是建立在已有东西的基础之上。技术的发展不会是无中生有，只会是一个更好的解决方案而已，在追新求变之前，一个比较牢固的基础才是最重要的。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200402022022",
    "date": "2004-02-02",
    "time": "20:22",
    "tags": [
      "脚下的路"
    ],
    "title": "开工了！",
    "body": "<p>经过了半个月的春节假期，我又回到了工作岗位。<br>休息的日子总是短暂。早上同事见面彼此寒暄时，总是不免露出对假期已逝的惋惜。一天下来，晕晕乎乎，实在不知道自己在干什么。</p>\n<p>或许是长大了的缘故，今年的春节过得特别没有感觉，比之去年的除夕忽然感受到又是一年，今年从始至终一点过年的感觉都没有，与平日的不同就在于多吃了几顿大鱼大肉，多串了几次门。或许是离家太近的缘故，没有了大学假期归乡的那种亲切。加之去年几个好朋友时常见面，春节相会便也少了几分激动。</p>\n<p>脑子里突然冒出的一句话是“距离产生美”。</p>\n<p>当大学宿舍的老大突然给我来电话时，这一句再次得到验证。屈指算来，大家分开已经一年多了。那时候，整天摸爬滚打在一起，丝毫不觉得彼此之间有何值得珍惜。如今拿着电话相互调侃时，忽然觉得一同快乐的日子已经离我们好远了。</p>\n<p>给初中的班主任拜年时，她谈及自己一些学生的近况，对比起来，我觉得自己只能以堕落形容。遥想当年，我是所谓的好学生，是父母和师长自豪的资本。如今的自己已经不再值得骄傲，比起同龄人，我几乎没有丝毫的优势。</p>\n<p>一段时间以来，我一直考虑的一个问题是如何脱贫？不是自己的远大理想，而是很现实的一个问题。记得《程序员》杂志有一期讨论了程序员为何焦虑，其中谈到为何中国的程序员为何没有在世界软件业做出巨大共享，根本原因在于穷。精神文明建设的前提是物质文明建设，这真的不只是出现在政治课本上的虚言，而是真实得不能再真实的真理。</p>\n<p>当然，以我现在的想法，我无法指望如何赶超Bill，更真实的是让自己不必为生活而发愁，这样就可以把更多的精力放在我所喜欢的事情上。</p>\n<p>“首先要敢想，想好要去做。”<br>初中班主任的一席话引起了我新的思考。不敢想是根本不会去做的，想了不做等于胡思乱想。</p>\n<p>我对自己的评价是，鬼点子比较多，但懒于行动让我更多的局限于胡思乱想的境地。真的该动一动了！</p>\n<p>在<a href=\"http://www.csdn.net/\">CSDN</a>上，看到<a href=\"http://www.javafox.org/\">银狐999</a>的文章<a href=\"http://www.csdn.net/develop/article/22/22540.shtm\">《听用友总裁何经华先生讲座随感》</a>，其中引起我思考的一个观点是“知识将取代现金”。在我头脑中，这句话被我偷梁换柱为“用知识换取现金”。</p>\n<p>从小到大，一直受到应该好好学习的教育，但好像除了“为建设四化”之类离自己比较遥远的目标之外，学习的目的何在我思考的并不多。既然自己拥有的是知识，就应该考虑如何把知识换成让自己脱贫的现金，好让自己有更多的精力去继续智力游戏。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200401162148",
    "date": "2004-01-16",
    "time": "21:48",
    "tags": [
      "我眼看世界"
    ],
    "title": "完成Perl版Hello,World",
    "body": "<p>春节之前最后一天的工作也结束了，终于可以休息了。<br>这两天家在外地的同事大多为了一张回家的车票忙得焦头烂额，家近的幸福在这时候体现得最明显。<br>前不久，收到2003年毕业的一个朋友的mail，mail里有这样一段话：“今年终于不用为考试和赶火车而头疼了，但是却又有些怀念那时的日子。”<br>去年的我多多少少也有这种感觉，习惯的力量还真是可怕。</p>\n<p>晚上，看了《Perl语言入门》（Learning Perl）的第一章，写了一个Perl版的“Hello,world”。<br>写程序也有一段时间了，但几乎所有的程序都是编译型的，无论是C/C++、Java还是很早以前用过的Pascal。所以，总想找点别的东西来感受一下。<br>一个朋友和我说，之前完全用C的他使用了一种脚本语言之后，觉得很不错，解决一些问题很方便，现在遇到问题，脑子里已经不像过去那样先想到以C搞定了。<br>受他的影响，我也想找一种脚本语言来感受一下。<br>选择Perl，因为它是开源社区中最为著名的一种脚本语言。此外，Larry Wall的传奇也深深的吸引着我，所以，准备体会一下这个传奇人物制造的传奇语言。<br>下面就是我的第一个Perl程序。<br>#!/usr/bin/perl</p>\n<p>print \"Hello, World!\\n\";</p>\n<p>再来说说《Perl语言入门》这本书。<br>最初听说这本书的名声是在Stanley Lippman的《Essential C++》的前言中。Lippman被要求用Perl编写一个工具。为了迅速上手，他选择了《Perl语言入门》，阅读此书，“立即上手进展神速，而且颇具趣味”，这是这个原因促使Lippman编写了《Essential C++》，为C++的初学者提供了一个快速入门教程。<br>这本《Perl语言入门》是我第一次电子购书中的一本，选择它名声之外的原因就是特价了。从今天的拜读经历来看，这本书特价的原因绝不是品质差，实在Perl在国内的地位不高。<br>阅读应该是一种享受，但对我这样经常阅读译版的图书的人来说，追求享受简直是就是一种奢求，不能说没有，只能说太少了。<br>今天就享受了一把。阅读《Perl语言入门》是一个幸福的经历，这一方面归功于作者高超的写作技巧，另一方面要感谢译者辛勤的工作。正如Lippman所说，这本书读起来“颇具趣味”，仅仅一章的内容把Perl需要为人了解的基本知识一一道出，时不时穿插几个幽默的故事，“润物细无声”般把Perl的文化注入到我的脑海之中。<br>大多数的技术书籍，我的阅读经历是硬着头皮啃一段，然后放下，休息一段时间再来。而这本书的第一章我是一口气读下来的，因为我实在不愿意放手，写得着实精彩，译得又没有很重的翻译味道，难得的优秀译本。</p>\n<p>回家过年去了！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200401152215",
    "date": "2004-01-15",
    "time": "22:15",
    "tags": [
      "脚下的路"
    ],
    "title": "惯性思维",
    "body": "<p>有没有压力的感觉果然不一样。</p>\n<p>经过近乎疯狂的编码，项目顺利拿出手，一根紧绷了近一个月的弦一下子松了下来。这两天感觉整个人特别懒散，什么都不想干，就连blog都懒得写了。</p>\n<p>在我们传统的开发方式中，比如用C/C++，我们会把自己应用的所有东西放到自己应用的目录下，比如bin下放可执行文件，conf下放配置。通常顶层目录则是由我们任意指定。<br>对于J2EE部署，我的认识基本上是，把所有class和部署描述符打成一个包，可能是EAR、可能是WAR，然后部署到应用服务器上。一般部署的结果就是放到了应用服务器的目录上。<br>这是我脑子里一直难以解开的一个结，我们无法按照传统的方式部署我们的应用。</p>\n<p>我们的新系统中，一个同事创造性的解决了这个问题，使我们按照传统的方式部署我们的应用。具体做法很简单：部署时，只把描述符部署到应用服务器上。而我们应用的class文件打成一个JAR文件，把它配置到应用服务器的classpath中。至于可能用到JAR文件，我们也不像原来一样打入应用的包中，而是单独部署，放到我们应用的lib下，然后也是配置到应用服务器的classpath中。至于配置，程序会读一个环境变量确定配置文件的位置，于是配置文件的位置也成了可配的。</p>\n<p>由此，我们的应用彻底与应用服务器分开，我们可以按照传统的方式组织自己的应用。</p>\n<p>或许从表面上并不能看出这种做法的好处，如果你能够亲身经历一次打包发布的漫长煎熬，现在这种只要自己手工就可以简单完成打包，发布变成了一个FTP的过程，估计就能体会我们用这种方法的幸福。另外，我们的实施人员更习惯于原本的那种部署方式，而并非J2EE那种一切尽在应用服务器的方式。</p>\n<p>最初接触到这种做法，我惊讶的嘴都合不上了，太精妙了。回过头来想想，其实这只是一个惯性思维的问题，太过于习惯现有的东西，有些很好的解决办法其实只要简单的转化一下思路就OK了。</p>\n<p>突然想起前不久调系统的一个bug，费了好大的劲，最终的bug是出在一个已经用了几个月的类上。这是一个读XML配置文件的类，现在的系统用了多个配置文件，一读就错。最终发现一个成员被写成了静态的，所以第二加载的时候会覆盖掉第一个，之所以以前没错，因为以前只有一个配置文件。</p>\n<p>调这个bug费了好大的劲并不是因为这个bug如何之难以找到，关键是因为我根本没有想到这个类会错，因为它已经是我多次维护过，并且稳定运行了好长一段时间了。这还是一个惯性思维的问题。</p>\n<p>偶尔跳出三界外，一片海阔天空。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200401112140",
    "date": "2004-01-11",
    "time": "21:40",
    "tags": [
      "脚下的路"
    ],
    "title": "迟到的2004年开篇Blog",
    "body": "<p>成为Blogger以来，头一次这么长时间没有留下只言片语，一个字，忙！</p>\n<p>以前的系统，相对来说，我并不是个中心人物，完成自己手头的工作也就罢了。成为“架子工”之后，对于系统担负的责任一下子大了起来。系统上线的日期一天天临近，压力也就越来越大。</p>\n<p>我们的元旦假期是三天，我背着笔记本回家休息，除了元旦当天是真正在休息以外，假期都在写代码中度过。直到今天，我的弦都是绷得紧紧的，每天工作到晚上11点。现在的感觉，无论精神还是身体，都是非常累的。</p>\n<p>累是累了些，收获还是蛮大的。毕竟这个系统的整个设计是由我完成，并且完成了其中很大一部分的代码。自我感觉编码能力又有了一些长进，对代码也有了更好的感觉。</p>\n<p>Uncle Bob的《敏捷软件开发》中一个附录的标题是《源代码就是设计》，我的看法是编码能力和设计能力是个相互影响的过程。缺乏编码实践的人，设计能力很难有大的提升。随便在网上转转，许多关于编程的金玉良言都有多写代码的忠告，由此可见，在这点上大家是多么的有共识。这和我们应试教育的题海战术有着异曲同工之妙。</p>\n<p>以前没想通这个道理，以为多看书多学习就能提高自己的水平，于是书买了不少，也看了不少，实际经验的缺乏使得阅读过程痛苦不堪，而且收效甚微。2003年，在经过一段时间的实战之后，我拜读了《敏捷软件开发》，阅读此书不时可以感受到其中奥妙，于是常常大呼过瘾。现在再来看设计模式、再来讨论重构等等，就不像从前那样纸上谈兵，不知所云了，“实践是检验真理的唯一标准”。</p>\n<p>这次开发本来只是需要添加一些新功能，如果我们基于原有系统进行开发，恐怕几天就搞定了。由于原来系统从结构上来说很差，于是新负责人决定另起炉灶，重新设计。换句话说，我们要再不到一个月时间里，把原来系统完全实现出来，还要增加新的功能，现在看来，当时确实有些冒进了。就我的性格而言，我是比较喜欢挑战的，原有系统已经让我有些厌恶了，为它写代码对我来说，只能是折磨自己。</p>\n<p>原有系统最大的问题在于重复代码过多，结果造成发现一个bug改了一个地方，同样的问题还会出现。</p>\n<p>2004年第一期的《程序员》有一篇文章名为《代码地震》，有这个词来形容原有系统再恰当不过了。单从代码量的角度考虑，就可以看出新系统和旧系统的差别，原来的系统纯代码量（不算注释、空行等）一共4万多，而新系统的纯代码截至到我写篇blog的时候，还不到2万，也就是连原来的一半都没用上。</p>\n<p>这两天大家一起奋战的时候，负责人和我说，现在的代码结构看起来舒服多了。</p>\n<p>当然，并不是说新系统有多么多么完美无暇。随着编码的深入，新系统的问题也逐渐的暴露出来。显然不能指望马上修改新系统解决不理想的地方，真要是那么做了，恐怕我们的系统永远也开发不完。改进只能是有限度的。</p>\n<p>今天累了，准备休息了。关于这次设计开发，我还有很多心得，留下的话当然是且听下回分解。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312302225",
    "date": "2003-12-30",
    "time": "22:25",
    "tags": [
      "脚下的路"
    ],
    "title": "早到的祝福——新年快乐！",
    "body": "<p>明天就是2003年的最后一天了，鉴于我多半会选择明天下班之后立刻回家，所以，估计今天的blog就是我2003年的终结之作了。</p>\n<p>最近和大学的一个老师联系，得知她现在正在翻译《Linux Kernel Development》，于是厚着脸皮问她要来部分译稿看看。由于不能辜负了老师对我的信任，所以，看的同时当然要提一些意见。我是个书虫，有事没事闲逛于各大图书网站之间，网上对于图书翻译的精彩论战着实见识了不少。很早以前，总以为翻译对懂外语的人来说是件轻而易举的事。曾经尝试翻译过一些东西，险些吐血，明明一句懂得不能再懂的英文，转成中文之后，自己都觉得不知所云，深感翻译工作之艰辛。这次阅读译稿，进度是相当缓慢的，一晚上只能读一点点。把一些自己觉得别扭的话作为意见提出来，在没有原文的情况下读译稿，好处在于可以不受原文的干扰，全心于译稿，劣势在于遇到糊涂的地方，连个参照都没有。</p>\n<p>做技术的人大多在意的是技术，对于自己的表达工具——文笔和口才——重视确实不够。现在已经不是“酒香不怕巷子深”的年代了，好的水平需要配以好的表达才能尽显风采。最明显的一个例子就是我的梦想风暴。虽然，我对自己码字的功力多少有点自信，但没有很好的宣传使得梦想风暴的访问率一直居低不上（等梦想风暴再壮大一些，我就得宣传一下了。^_^）。笔和嘴其实并不是很难练，多动足矣！这和写程序是一个道理。看看林锐的《大学十年》，他从笨嘴拙腮到伶牙俐齿的经历就是最好的证据。</p>\n<p>这两天对我来说，另外一件不同以往的事是头一次电子购物的东西到了。虽然是借用的是别人的帐号，虽然一切的操作过秤都是那哥们替我完成，但最终的钱出自我的腰包。自己算起来也是个网虫，每天泡在网上的时间也不算短，但电子购物却是头一次，多少有些落伍了。电子购物的感觉？没有感觉，这和刷卡消费差不多，没有亲手送出钞票，好像钱不是自己的一样，也难怪有那么多人喜欢电子购物。这话说出来，真对不起我无产阶级和穷人孩子的身份。不过，电子购物确实方便，足不出户，东西进门。当然，对这东西的需求急不得，我决不会在饿得眼冒金星的时候，选择上网去买方便面。：）</p>\n<p>虽然还有一天，提前送上新年的祝福，想必没有人反对，新年快乐！<br>2003年，再见吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312282241",
    "date": "2003-12-28",
    "time": "22:41",
    "tags": [
      "脚下的路"
    ],
    "title": "部门活动",
    "body": "<p>年关岁末，部门活动。</p>\n<p>大概平时给人太多闹将的印象，这种时候是绝对无法逃脱的，即便工作很忙，即便我自己的心中期待的是悄无声息蒙混过去。我清楚，100%的逃避是不现实的，于是第一个找我演节目的同事出现提出让我一起去唱歌的时候，我毫不犹豫的答应了。没想到的是，还有第二个，让我演广告。我们的广告实际上就是个小品，只是捎带了自己的产品。鉴于去年的部门活动，我曾经扮演一头奶牛，演绎了一段还算精彩的光明牛过秤的广告，部门的同事在今年考虑广告人选的时候，一下子就定位到我了。这次是聪明智慧人见人爱的“猪八戒”，有人戏言，我从牛魔王升级到天蓬元帅。罢了罢了，演就演。我真希望这就是终点，我愿未遂。主持节目？我怎么会又被牵连进去了，难道我就这么全才吗？我自己都没有对自己这么相信过，怎么会有这么多人相信我。</p>\n<p>昨晚的联欢对我而言，是最混乱的一个联欢，不是联欢混乱，是我的事太多了。联欢是在大家酒足饭饱之后立刻开始的，我甚至都来不及考虑紧张的问题，就已经站在了台上。一会主持节目、一会去演广告、一会去唱歌，基本上，我的角色就是去搞笑。运气还算不错，联欢中的抽奖，我中了二等奖，一个128M的U盘。我还不够时尚，还没有自己的U盘，这下有了。大概我唯一比较正经的时候，是得知部门颁发的“青年突击手”奖有我一份时。奖品是一台DVD，记得今年家里买VCD时，我曾极力劝谏老妈购买DVD，结果，提议被否，现在看来，我还是无法媲美老妈的远见卓识。</p>\n<p>我记不大清楚昨晚曾经我站在台上具体说过些什么了，只记得说出了今年最大的心得，工作时注意一下身体。</p>\n<p>狂欢中的我们不再是一个个程序员，而只是一个个普普通通的人。尽情体现着我们最真实的一面，尽情的笑，尽情的叫。</p>\n<p>一年一次如此狂欢，难得悠闲。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312252153",
    "date": "2003-12-25",
    "time": "21:53",
    "tags": [
      "脚下的路"
    ],
    "title": "圣诞快乐！",
    "body": "<p>今天是圣诞节。</p>\n<p>先祝所有看过和没看过梦想风暴的朋友和我自己圣诞快乐！</p>\n<p>印象中，前几年圣诞节还是传说中西方人的节日，而今中国人已经开始把它当作一个自己的节日像模像样庆祝起来。唯一的差别可能是由于圣诞节尚未列入法定节日而不得因故休息吧！</p>\n<p>不能休息不等于不是节日。</p>\n<p>昨天的平安夜，同住的兄弟们相约共同庆祝，实际上是给大家一个聚会的机会，平时工作繁忙，平安夜也就成了一个充分放松自己的理由。</p>\n<p>如果说今年的平安夜于我而言，有什么收获的话，那应该是进了一趟教堂。在我看来，平安夜去教堂就如吃饺子讲究的原汤化原食一样，在于一个味道。虽然来去匆匆，虽然我并不信基督耶稣，但那种感觉，加上恰如其分的时间，美妙极了！</p>\n<p>圣诞之于西方人，等价于春节之于我们中国人。</p>\n<p>几个兄弟在街上信步而行，人山人海的壮观景象让我们突然产生了一种过春节的感觉。街上的人，脸上无不洋溢着喜庆的神情，更有甚者，放起了烟花爆竹。估计兄弟们由于春节大多会选择回家，在一起过春节的机会几乎为零，于是大家调侃，就把平安夜当成兄弟们一起过的除夕夜吧！</p>\n<p>近来工作忙了一些，有机会放松一下才让自己认识到，我不仅仅是个程序员。虽然写程序是我所爱，但它并不是我生命中的一切。很多大师都是多才多艺，博学多才，所以他们才能广开思路，创造出一个个旷世经典。</p>\n<p>于是，我告诉自己，程序技术之外，还应该来点别的调剂一下。</p>\n<p>圣诞已至，新年还会远吗？又是一个狂欢的理由。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312231952",
    "date": "2003-12-23",
    "time": "19:52",
    "tags": [
      "我眼看世界"
    ],
    "title": "程序员？Why？",
    "body": "<p>和一个朋友聊天的时候，谈及许多未来发展的话题，基于对现实情况的考虑，那位兄弟对于程序人生持有相当悲观的态度。这个兄弟说得头头是道，把我的思路也带出去好远，多少也有些悲观了。我不禁问了自己这样一个问题“我为什么要作一个程序员？”。想来想去，我能给自己的答案是为了乐趣，这恰恰等同于Linux之父Linus那本自传的名字——Just For Fun。</p>\n<p>对我而言，写程序如同一场智力游戏，解决问题的过程可以给我带来无尽的快感，所以我愿意写程序。</p>\n<p>为了把这场游戏玩得更好，我必须投入更大的精力，这和其它游戏玩家为自己喜欢的游戏倾尽全力别无二致。在网络游戏的世界中，一个人必须不断的修炼，不断的成长，才能成长为在游戏中呼风唤雨的人物。同样，只有不断的修炼，让自己不断成长，才能让自己更好与计算机合作，共同创造出一个属于自己的世界来。</p>\n<p>所以，我现在可以深深的体会到为什么许多人愿意为了游戏牺牲了许多东西。</p>\n<p>Linus在《Just For Fun》中提到过，写程序实际上是在创造一个世界，在这个世界里，你就是上帝。</p>\n<p>做Java给我的感觉就是在一个别人为你划定的舞台上舞蹈，虽然一样可以创造出一些东西来，但一切都在别人的掌控之中，没有了自己的自由。在我眼中，SUN的Java世界和MS的Windows帝国没有什么本质的区别。所以，我更喜欢自由的GNU。</p>\n<p>在别人的舞台上舞蹈并不见得一定就是一件坏事，我对Java开发效率已经有了一个比较好的认识。站在巨人的肩膀上，可以看得更远。</p>\n<p>但这一切要有个前提，足够的实力，对计算机足够的认识。各种舞台要求的舞姿可能不尽相同，一旦领会其中神韵，舞台将不在是一个限制。</p>\n<p>写了一段时间之后，我最近发觉自己并不能领会编程的真谛，甚至我开始视自己为不会写程序的人。我现在对侯捷先生在《深入浅出MFC》所用的“勿在浮沙筑高台”感受越加深刻了，随着自己的经验越多，这种感觉越发强烈。</p>\n<p>在我眼中，只有GNU的世界可以给我想要的感觉，Java世界对于现在的我而言，并不是最好的舞台。于是我开始思索离开Java的世界，投入GNU的怀抱。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312192221",
    "date": "2003-12-19",
    "time": "22:21",
    "tags": [
      "脚下的路"
    ],
    "title": "保重身体吧！",
    "body": "<p>我们项目之前的负责人月初的时候对我们说，这个月会过得比较充实。借他吉言，这个月真的很充实，甚至累得快直不起腰来了。最近几天身体明显有些不适，这让想起头两天体检的结果，我已经不是100%的健康了。所以，这里要对所有和我一样的程序员兄弟姐妹们说一声，保重身体。身体是革命的本钱，没有本钱，拿什么做买卖啊！</p>\n<p>我所做出的决定就是9:10之后，不再写工作代码。为什么有零头？因为我们这里最后一班出软件园的班车是9:10，虽然我不必坐车出园，但我仍选择了这个时间作为工作代码编写时间。</p>\n<p>这两天听说<a href=\"http://www.huihoo.org/jfox/\">JFox</a>要做AOP，于是到<a href=\"http://211.99.144.3/forum/forumdisplay.php?fid=129\">JFox的AOP论坛</a>上发了个帖子，侃谈一下我的观点，如下：</p>\n<ol>\n<li>看到<a href=\"http://www.huihoo.org/jfox/jfoxaop/jfoxaop_plan.html\">JFoxAOP的项目设想</a>，突然冒出这样一个疑问，为什么要用AspectJ？<br><br>首先要说的是，我并不想否认AspectJ的优越，AOP之父领导出来的东西并非浪得虚名。直接采用全新的语法，使得AspectJ相对于许多使用Dynamic Proxy完成的AOP有着相对的效率优势。<br><br>Java世界一个重要的游戏规则就是标准，这也是Java社区与MS抗衡所倚赖的一件利器。AspectJ最为缺少的恰恰就是标准。AOP之父在其访谈录中谈到，AOP思想经历了这么多年，也到了该有标准的时候了。当然，基于现在AspectJ的成熟程度，很可能这个新的标准会取其精华，但指望AspectJ完全成为标准，显然不那么现实。<br><br>如果Java真把AOP纳入语言之中，那么AspectJ其地位如何呢？可能就是一种Java方言了吧！不要认为好的东西进入语言/JDK中就那么理所当然，Log4J已经是一个不良的例子了。<br><br>如果AspectJ真的那么好，为什么JBoss会选择另起炉灶呢？有个朋友对我说过，他并不看好AspectJ的静态weaving，我想最主要的原因在于AspectJ对语言的修改吧！这么做不是不好，只是现在还不是很好。<br><br>作为学习AOP思想之用，AspectJ可能会省去了不少麻烦，但以它作为一个项目的开发语言现在来看是否有些冒进呢？<br><br>看到的，想到的，一家之言，大家一起讨论一下吧！<br><br>\n</li><li>现在对于AOP的实现方式通常分成静态和动态两种。<br><br>静态的实现方式正如AspectJ所做，实际上是相当于在普通Java的编译器之前加上了一个预处理器，对aspect进行预处理，使得AspectJ的代码变成普通的Java代码，于是AspectJ产生出来的代码就可以在普通的JVM上运行。<br><br>动态的实现方式可以以nanning和spring为代表，它们采用的手法是运行时根据配置信息进行加载，并在其中插入动态代理，这种实现方式最大的问题就是效率。<br><br>JBoss的AOP实际上介于二者之间，修改class loader，于是优缺点也在二者之间。<br><br>我对Jython的了解（这里提到Jython是因为论坛中有人认为扩展语法的手法不错，并以它作为证据）仅限于听说个这个名词，我不清楚Jython现在的流行程度如何，也不清楚向其它语言扩展，其目的何在。所以也无法得出“采用全新的语法就是好的”这样的结论。<br><br>我在论坛中提出这个问题的原因并非批驳AspectJ，而是希望与大家讨论，得出一个让大家都比较满意的结果。</li></ol>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312142245",
    "date": "2003-12-14",
    "time": "22:45",
    "tags": [
      "向上走"
    ],
    "title": "AOP初印象",
    "body": "<p>这两天看一下《DDJ软件开发》上关于AOP的两篇文章，算是对AOP有了个最初的印象。</p>\n<p>在我看来，AOP所提倡的实际上是个哲学问题，“从不同的角度看问题”。<br>所以，如果把AOP中的\"方面（aspect）”换成我们熟悉的“角度”，我觉得这个概念就可以更好的理解了。</p>\n<p>我是一个Java程序员，和我同住的一个兄弟是C程序员。<br>某天，他突然问我，对网络的了解多少，我说很少，他很惊讶，你们项目不也是基于网络的程序吗？怎么连对网络了解得都不多。</p>\n<p>其实，这就是一个关注点的不同。<br>如果用C写程序，那就不得不面对直接编写网络程序的问题，解决诸如Socket连接、并发等等问题，为什么，因为如果自己不做，没人会帮忙。<br>如果用Java写程序，恰好又是一个基于Http的应用，那就省去对网络程序的关注，因为这些问题已经有人完成了这些工作，他们就是那些开发WebServer（比如Tomcat）和AppServer（比如JBoss）的那群人，在此基础上开发应用的人，大可不必理会究竟请求是如何进来、并发如何处理，只要放心大胆的去做自己的应用就好了。</p>\n<p>关注点不同，对于同样的问题就会产生不同的理解。如果因此争论不休，才真正是“风马牛不相及”，网上许多关于语言或工具的争论往往都是这样开始的。</p>\n<p>回到AOP上，其实一个aspect就是我们看问题的一个角度，我们所关注的一个问题，一个关注点。</p>\n<p>再来说说《DDJ软件开发》上的两篇文章，《AOP之父Gregor Kiczales访谈：15%解决方案》放在《AOP入门》之前，于是我按部就班的先看了《访谈》，结果连一半都没看下去，几乎看不懂。只好先看《AOP入门》，对程序员来说，是有代码的东西最实际，看过《AOP入门》回过头来看《访谈》，许多疑问迎刃而解。所以，如果哪位和我一样对AOP感到陌生的兄弟姐妹想要读这两篇文章，我推荐先看《AOP入门》。</p>\n<p>就上面所举的例子再多说两句，例子无非是用来说明我的观点。对于我对网络知之甚少的情况，我自己是深感愧疚的。鉴于大多数时间把精力都集中在应用上，以致于我现在只能以“架构”、“模式”等比较“炫”的词来敷衍别人。在我看来，只有有了良好的基础，写起代码来才能虎虎生风，否则，无异于盲人摸象，很难看清事务的本质。</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312132210",
    "date": "2003-12-13",
    "time": "22:10",
    "tags": [
      "脚下的路"
    ],
    "title": "买了《算法导论》",
    "body": "<p>经过了一段的实践，忽然发现自己最应该掌握的是一些基本的东西，比如数据结构，比如编译原理，比如操作系统，这种感觉随着自己实践经验的增多而愈加强烈。</p>\n<p>学习编译原理和操作系统的意义并不在一定要实现出一个编译器或是操作系统，关键在于学习其中的许多思想，开阔自己的思路。很可惜，念书的时候，我没能找到一种很好的学习方式，以致于虽然不断的告诫自己这两门课的重要性，最终仍未能让其刻骨铭心。</p>\n<p>以我现在的眼界来看，学习这两门课最好的方式是结合源码，操作系统当之无愧就是Linux了，编译器我觉得Gcc不错。<a href=\"http://oldlinux.org/\">oldlinux.org</a>上的赵博士为0.11版的Linux做了份注释，写了本书，我只看了开头不多的一点，感觉还是很不错的。有了问题还可以到网站上去问问题，赵博士挺热心。</p>\n<p>相对来说，Gcc的资料趋近于0。最近我认识的一个高手在研究Gcc，我有幸分享了他的一些成果，受益匪浅。等我小有心得的时候，也把自己的学习成果贡献出来，和别人一起分享。</p>\n<p>说了半天，都快忘了我今天blog的题目了，我买了《算法导论》，这可是本经典的作品。</p>\n<p>Pascal之父Wirth博士的经典论断就是“程序=数据结构+算法”。</p>\n<p>我不知道别的大学是怎样的，我的大学课程中，数据结构进行了专门的讲解，但对算法几乎没有涉及，加上大学中误把二者等同起来，结果造成了现在基础不是很扎实的结果。</p>\n<p>书买回来了，最大的疑问是我能从中获得多少东西。我并不怀疑这本书的经典程度，我怀疑的是自己的学习态度。<br>1 书的厚度近1200页<br>2 书是英文的<br>买书的时候，同去的兄弟就对此提出了置疑，我大言不惭的说，我一定会好好看看，认真的去实践，心里却在打着鼓。</p>\n<p>写下这篇Blog的目的，一是纪念一下为《算法导论》而阵亡的诸多Money们，二是告诫自己，开始学习吧！</p>\n                                    <div class=\"clear\"></div>"
  },
  {
    "timestamp": "200312110836",
    "date": "2003-12-11",
    "time": "08:36",
    "tags": [
      "脚下的路"
    ],
    "title": "开始“信口开河”了",
    "body": "<p>早早就申请了这个Blog，却迟迟没有写过一篇，对于多少还算比较喜欢码字的我来说，有点说不过去。于是决定多多少少写点东西，也算对得起自己了。</p>\n<p>既然是个程序员的Blog，话题当然离不了程序。近来比较忙，一个已经做了一年的项目又有了新需求，加上我们项目组的人那么积极上进，于是乎，大家决定为系统设计一个新的架构，版本号也顺理成章的由1.X变成了2.0。</p>\n<p>部门里人事变动，负责人升级了，我们项目中本来负责系统架构的兄弟成了负责的，于是他的活转到我的手里，我成了这个新架构的“架子工”。</p>\n<p>近两个月在看Uncle Bob的《敏捷软件开发》，终于对OO有点开窍了。最近一期的《程序员》gigix那篇关于IoC的文章看得我心潮澎湃。IoC实际上和Uncle Bob所讲的DIP基本上是一回事，有了DIP的一点底子，看IoC就有感觉多了。手头上有gigix的Groller，文章加代码看得我越发有感觉，于是想在新架构中对这些“感觉”进行尝试。</p>\n<p>Groller中的IoC基本上是借鉴了Spring中Bean操作来完成的，所以我也投了一些精力在Spring上，随着对Spring的了解，我的思维开始发散。既然能够把一些组件（bean）配在xml文件中，由Spring来替我们完成组合，那我把整个系统都看作一个组件集如何呢？</p>\n<p>gigix在Groller里进行了一些尝试，他把一些service按照组件进行配置，只不过他的service组合还是比较简单的。我想可以再进一步，把整个系统都以这种方式组合起来，即大的service由小的service组成，这样一点一点把整个系统拼接出来，所有的配置都由配置文件完成。</p>\n<p>和gigix就这个问题讨论了一下，他觉得小service应该是大的service的一个aspect，可惜我不懂AOP的概念，所以，我只能以“小service是大service的一个组成部分”来理解。</p>\n<p>渐渐的，我开始觉得AOP是个好东西了。有人说面向过程如果是一条线，那么面向对象就是一个面，到了AOP就是一个体了。既然可以由一维逐渐演化为多维，看来还可以再进一步，让它变成一个多维的。</p>\n<p>类比一下，我觉得操作系统的文件系统也可以设计成一个多维的。比如我们组织自己手头的资料，可能C中有电子书、有网页，Java中也有电子书、有网页。如果我们换个角度来看：电子书里有C的、也有Java的，网页中同样有C有Java。由此看来，现在的文件系统也可以再进步一下，不必维持现在这种单一的树形结构了。</p>\n<p>呵呵，已经偏离起始的内容好远了。这就是思维混乱的结果，随性而行，差之毫厘，谬以千里。</p>\n                                    <div class=\"clear\"></div>"
  }
]
