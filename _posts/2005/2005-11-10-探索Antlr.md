---
layout: post
title: 探索Antlr
author: dreamhead
date: 2005-11-10 16:00:00 +0800
tags: [  ]
categories: [  ]
---

简介 Antlr（ANother Tool for Language Recognition）是一个工具，它为我们构造自己的识别器（recognizers）、编译器（compiler）和转换器（translators）提供了一个基础。通过定义自己的语言规则，Antlr可以为我们生成相应的语言解析器，这样便可以省却了自己全手工打造的劳苦。 目标 如同程序设计语言入门大多采用“Hello World”一样，编译领域的入门往往选择计算器。而这里迈出的第一步更为简单：一个只能计算两个数相加的计算器，也就是说，它可以计算“1+1”。 基础知识 先来考虑一下如何下手，如果你曾经接受过编译原理的教育，权当忆苦思甜了。这个计算器工作的前提是有一个需要计算的东西，不管我们是以文件的形式提供，还是手工输入，至少我们可以让我们的计算器知道“1+1”的存在。 有了输入之后，我们要先检查输入的正确性，只有对正确的输入进行计算才是有意义的。如同写文章有形式和内容之分，这里的检查也要细分一下，率先完成的检查当然是面子功夫——形式上的东西，看看是否有错别字的存在，我们要做的是数值相加，结果人家给出了一个字母，这肯定不是我们希望得到的，所以我们有权力拒绝这个不合法的东西。对于程序员来说，如果在自己的程序里写了一个语言不接受的标识符，比如在Java里用“123r”做标识符，那编译器肯定会罢工，拒绝让程序通过编译的。在编译原理里面，这个过程叫做词法分析。在我们的计算器中，我们只接受整数和加号，其它的一概不理。这里我们说的是“整数”，而非“1”、“2”……，对我们来说，它们代表着同一类的东西，编译原理教导我们把这这种东西叫做token，那些数字对我们来说，都是一样的token，不同的仅仅是它们的值而已。 形式说得过去并不代表内容就可以接受，南北朝时期许多骈体文让我们看到了隐藏在华丽的外表下的空虚灵魂。你可以说“我吃饭”，如果说“饭吃我”，除非是在练习反正话的场合，否则没有人会认为它是有意义的。只有在闯过了词法分析的关口，才能到达这里，在编译原理里面，我们把这个阶段叫做语法分析。如果说词法分析阶段的输入是字符流的话，那么语法分析阶段的输入就是token流——词法分析的输出。我们这里接受的合法语法是“整数 加号 整数”。 编写语法文件 好了，制订好自己的语言规则之后，我们需要以Antlr的语言把它描述出来。 下面便是以Antlr的语言描述的语法： class CaculatorParser extends Parser; expr: INT PLUS INT; class CaculatorLexer extends Lexer; PLUS : '+' ; INT : ('0'..'9')+ ; Antlr的语法文件通常会保存在一个“.g”的文件中，我们的语法文件叫做“caculator.g”。 先来看看Lexer部分，它便是我们前面所说的词法分析器。首先声明自己的Lexer： class CaculatorLexer extends Lexer; 这句话有两个作用，其一，为生成代码中的词法分析器定义名字，其二，告诉Antlr，我要定义词法规则了。既然说到词法规则，紧接着我们就定义了两条词法规则： PLUS : '+' ; INT : ('0'..'9')+ ; 这里的规则很容易看懂： \* PLUS定义的token，就是一个单一的“+” \* INT定义的token，由从'0'到'9'之间任意的数字组成，后面的加号表示它是可以重复一次到多次 定义好Lexer之后，便轮到Parser了： class CaculatorParser extends Parser; 它的作用同Lexer的定义一样，之后是语法规则： expr: INT PLUS INT; 有了词法分析的经验，这条语法规则也很容易看懂，不同于Lexer中规则使用字符定义，这里我们用Lexer中定义的token定义语法。这也符合前面所说的，词法分析的输入是字符，语法分析的输入是token。我们定义了一个表达式： \* 一个INT，后面跟着一个PLUS，后面在接着一个INT。 编译语法文件 如同不编译的程序是无法发挥其威力一样，单单语法文件对我们来说，并没有很大的价值。我们的工作就是使用Antlr提供工具对我们的语法文件进行编译，不同于日常的编译器输出可执行文件，这里的输出是程序语言的源文件。Antlr缺省目标语言是Java语言，它也可以支持C++和C#语言，2.7.5之后，Python也走入这个家族。 将antlr.jar加到classpath中，然后把语法文件的名称作为参数传给语法编译器： java antlr.Tool caculator.g 在确保命令正确执行，且语法文件编写正确的情况下，Antlr为我们生成了几个文件： CaculatorLexer.java CaculatorLexerTokenTypes.java CaculatorLexerTokenTypes.txt CaculatorParser.java CaculatorParserTokenTypes.java CaculatorParserTokenTypes.txt 这里我们主要关心的是CaculatorLexer.java和CaculatorParser.java，它们就是我们在语法文件中定义的Lexer和Parser。其它几个文件只是定义了一些常量，让我们暂时忽略它们的存在。 运行程序 生成代码之后，就是如何使用这些生成的代码。下面就是我们的主程序，它负责将Lexer和Parser驱动起来： public class Main { public static void main(String[] args) throws Exception { CaculatorLexer lexer = new CaculatorLexer(System.in); CaculatorParser parser = new CaculatorParser(lexer); try { parser.expr(); } catch (Exception e) { System.err.println(e); } } } 从这段代码中可以清晰的看出，Lexer的输入是一个字符流，而Parser则需要Lexer的协助来完成工作。一切就绪，我们让它跑起来，尝试输入一些内容，看它是否能够通过验证。事实证明，我们的程序可以轻松识别“1+1”，而对于不合法的东西，它会产生一些抱怨。 计算结果 还记得我们的目标吗？我们的目标是计算出“1+1”的结果，而现在这个程序刚刚能够识别出“1+1”，我们还要继续前进。 熟悉XML解析的朋友对于SAX和DOM一定不陌生，二者之间差别在于SAX属于边解析边处理，而DOM则是把所有的内容解析全部解析完（在内存中形成一棵树）之后，再统一处理。Antlr也有与之类似的两种处理方式，SAX的朋友是在Parser中加入处理动作（Action）处理将随着解析的过程进行，而DOM的伙伴则是解析形成一棵抽象语法树（Abstract Syntax Tree，AST），再对树进行处理。 加入Action 先来看看SAX的朋友。因为处理动作是加在Parser中的，所以，我们的Lexer保持不变，下面是修改过的Parser。 class CaculatorParser extends Parser; expr returns [int value=0] : a : INT PLUS b : INT { int aValue = Integer.parseInt(a.getText()); int bValue = Integer.parseInt(b.getText()); value = aValue + bValue; }; 看到常用的字符串转整数的方法，熟悉Java的朋友想必已经露出了会心的微笑。没错，这里定义Action的方法采用就是Java语言，因为我们生成的目标是Java，如果你期待另辟蹊径，那这里的代码就要用你的目标语言来编写。 仔细看一下不难发现，action完全是在原有的规则基础上改造的来。首先用returns定义了这个Action的返回值，它将返回value这个变量的值，其类型是int，我们还顺便定义这个变量的初始值——“0”。接下来，我们用a、b拿住了两个token的值，我们前面说过，在检查的过程中，我们并不关心每个token具体的内容，只要token的类型满足需要即可，但在action中，我们要计算结果，那必须使用token具体的内容，所以，我们用变量拿住了token。在生成的代码中，a的类型antlr.Token，因此，我们通过a.getText()来获得token的具体值。剩下的动作就很简单了，把文本转换为数字，进行加法运算。 是不是对我们的计算器有些迫不及待了，那就挥动工具生成全新的Parser。不过，在新的体验之前，我们还要稍微修改一下主程序，以体现我们的劳动成果。 public class Main { public static void main(String[] args) throws Exception { CaculatorLexer lexer = new CaculatorLexer(System.in); CaculatorParser parser = new CaculatorParser(lexer); try { System.out.println(parser.expr()); } catch (Exception e) { System.err.println(e); } } } 好了，让这个计算器来为我们求证“1+1”吧！ AST SAX的朋友表演完了，下面就是DOM的伙伴登场了。 建立AST的方式很简单，只要我们Antlr一个建立AST的选项即可，下面就是新的Parser： class CaculatorParser extends Parser; options { buildAST=true; } expr: INT PLUS^ INT; 稍微有些不同的地方在PLUS上面的“^”，这个符号用来告诉Antlr创建一个节点，以此作为当前树的根节点。 你也许会有些疑问，怎么没看到计算的加法的地方？别急，大戏要压轴。下面登场的是Antlr整个故事最后一个大角，TreeParser： class CaculatorTreeParser extends TreeParser; expr returns [int value = 0;] : #(PLUS a : INT b : INT) { int aValue = Integer.parseInt(a.getText()); int bValue = Integer.parseInt(b.getText()); value = aValue + bValue; }; Antlr可以接受三种类型语法规范——Lexer、Parser和Tree-Parser。如果说Lexer处理的是字符流、Parser处理的是Token流，那么TreeParser处理的则是AST。前面Action的处理方式中，我们看到，规则同处理放到了一起，显得有些混乱，而采用了AST的处理方式，规则同处理就完全分离了：在Parser中定义规则，在TreeParser中定义处理，如果我们需要对同样的语法进行另外的处理，我们只要重新TreeParser，而不必在规则与Action混合的世界中苦苦挣扎。 有了前面Action的基础，来看TreeParser如何编写也就简单许多，需要说明的就是： #(PLUS a : INT b : INT) 除去变量的说明，简化一下这段代码 #(PLUS INT INT) 第一个符号PLUS对应了表示着根节点，两个INT则分别代表了两棵子树。 再来看看重新打造的主程序 public class Main { public static void main(String[] args) { CaculatorLexer lexer = new CaculatorLexer(System.in); CaculatorParser parser = new CaculatorParser(lexer); try { parser.expr(); AST t = parser.getAST(); CaculatorTreeParser treeParser = new CaculatorTreeParser(); System.out.println(treeParser.expr(t)); } catch (Exception e) { System.err.println(e); } } } 结语 体验过最简单的Antlr程序，我们就有了让它更为丰富的基础，接下来便是自己动手的时间了。 参考资料 《ANTLR入门》 2004年第三期《程序员》 《ANTLR Reference Manual》


