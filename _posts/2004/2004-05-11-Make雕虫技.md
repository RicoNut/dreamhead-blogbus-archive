---
layout: post
title: Make雕虫技
author: dreamhead
date: 2004-05-11 16:00:00 +0800
tags: [ '向下走' ]
categories: [ '向下走' ]
---

在一个规模相对较大的项目中，常常许多目录中都有自己的Makefile，负责处理这个目录中的内容。  
顶层Makefile中可以使用不同的方法调用子目录中的Makefile，下面是我所知道的两种:  
1 进入子目录编译，比如:  
&nbsp; cd kernel; make clean;  
2 利用Makefile的特性，比如:  
&nbsp; $(MAKE) clean -C kernel  
Linux的makefile使用了后一种方法。

随之而来的是一个有趣的问题。

编写Makefile的时候，我们常常定义一些变量，比如：  
CC&nbsp;= gcc

基于程序员懒惰的特性，我们当然不想在多个地方定义这个变量，我们期望的效果是顶层定义，底层使用，也就是说，上面的定义只出现在顶层的文件中，至于底层Makefile，我们只是简单$(CC)就可以使用了。

虽然这是一个合理的要求，但如果你只把这个变量定义在顶层的Makefile中，就期望使用前面提到方式的执行子目录的makefile能够如你所愿，那你只有失望的份了。底层Makefile是无法看到顶层Makefile定义的变量，make没有提供这种支持。

要解决这个问题，我知道的也是两种方法:  
**包含文件**  
同我们了解的C/C++一样，Makefile中也支持包含文件。只要把定义了变量的文件包含在Makefile中，Makefile就可以看到这个变量定义了。  
听了这种说法，性子急的人直接就在底层的Makefile中把顶层的Makefile包含进来。请再给我个说话的机会，不要这么直接，好吗?  
我们可以这样做，把变量定义同具体的编译内容分离开来，专门用一个文件存放变量定义，假设这个文件叫Make.rules，用这种方法，我们把原来定义在顶层Makefile中的变量分离了出来，而我们只要对这个Makefile稍做修改，加上一句  
&nbsp; include Make.rules  
对于底层需要这些变量的Makefile，只要按照目录结构包含Make.rules就可以顺利的工作了。  
如果你问为什么不直接包含整个Makefile，那你一定算不上一个好程序员，好程序员怎么能容忍过分的暴露呢?  
&nbsp;   
**导出变量**  
这种方式是在变量定义之后，将它导出来，对于上面CC定义，我们还要额外的写上  
&nbsp; export CC  
这样，采用前面提到过的方式处理子目录的时候，就可以使用这些变量了。  
这是Linux的makefile使用的方式。  
同包含文件相比，这种方式有一个缺陷，因为这些变量都是在make执行的过程中定义的，所以如果没有在顶层执行make，那么这些变量实际上是不存在的。换句话说，直接在某个子目录中执行make，很有可能的结果是因为变量没有定义而执行失败。  
&nbsp;   
其实，对于解释我们的问题来说，CC并不是一个很好的例子。  
可能你会遇到这样的现象，底层的makefile中并不包含CC的定义，但它依然可能编译代码，我知道你已经准备置疑我前面的结论了。  
但在置疑之前请仔细看一下，执行的是我们定义的gcc吗?  
真正运行的是cc。

为什么会这样?  
原因很简单，因为make中有一批预定义的变量，其中就包括CC，它预定义的值就是cc。如果你在应用中定义的变量同预定义的变量具有相同的变量名，那么起作用的将是你定义的值。  
用下面这个命令可以了解make有哪些预定义变量：  
make -p


